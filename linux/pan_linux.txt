usr是是 Unix System Resource

_______________________________________________

bash基本命令功能：

显示全部环境变量：
env

显示自定义变量与环境变量：
set

显示内容
echo $PATH

设置内容(没有空格)
name=pan

追加内容
name=${name}aaa

取消内容
unset name

读取输入内容
read name

读取输入内容，有提示和输入时间限制
read -p "Enter:" -t 10 name

将自定义变量变为环境变量
export name

声明变量类型
declare name
参数：a：数组；i：后面的内容为数字；x：与export一个功能；r：只读
符号：-：设置该功能；+：取消该功能

数组
var[1]=aaa
var[2]=aaa
var[3]=aaa
echo "${var[1]},${var[2]},${var[3]}"

变量的修改删除
name=aaa:bbb:ccc:ddd

从前向后最短删除：
echo ${name#*:}
bbb:ccc:ddd

从前向后最长删除：
echo ${name##*:}
ddd

从后向前最短删除：
echo ${name%:*}
aaa:bbb:ccc

从后向前最长删除：
echo ${name%%:*}
aaa

替换第一个匹配
echo ${name/bbb/BBB}
aaa:BBB:ccc:ddd

替换全部匹配
echo ${name//:/::}
aaa::bbb::ccc::ddd

判断变量是否设置，没设置则赋值
name=${name-haha}

如果是空字符串，则上述操作需要变更
name=""
name=${name:-haha}

定义别名
alias lm='ls -l | more'

取消别名
unalias lm

查看类型
file *.cpp
type pwd

同名命令的优先执行顺序
type -a ls

无需重新登录直接更新配置文件的配置信息(下面两条命令一样的)
source ~/.bashrc
. ~/.bashrc

将正确的输出和错误的输出分开存在文件里（2>,2>>代表错误的输出定向）
find / -name .bashrc > stdoutfind 2>stderrfind

无条件顺序执行几条命令
make clean;./build.sh;make

按顺序执行，一旦出现错误则停止
ls /tmp/abc && touch /tmp/abc/hehe (有前面的那个目录，则创建后面的文件)

顺序执行，一旦成功则停止
ls /tmp/abc || mkdir /tmp/abc (有目录就不执行了，没有目录则创建目录)

不知道是否有目录，但是要在目录下创建文件
ls /tmp/abc || mkdir /tmp/abc && touch /tmp/abc/hehe

三目表达式
ls /tmp/aaa && echo "abc" || echo "ddd" （有目录，则输出aaa，否则输出ddd）

ll显示第一列
ll | cut -d ' ' -f 1

sort参数：
-f	忽略大小写
-b	忽略空格
-M	按月份排序(JAN,DEC之类的排序)
-n	纯数字排序
-r	反向排序
-u	去重
-t	设置分隔符，默认是tab
-k	按照那个区间进行排序

默认按照首字母排序
cat /etc/passwd | sort

按照按':'分隔，第三列按照数字排序
cat /etc/passwd | sort -t ':' -k 3 -n
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin

uniq参数：
-i	忽略大小写
-c	记数

登录帐号第一列排序、去重、显示登录次数
last | cut -d ' ' -f 1 | sort | uniq -c


wc参数：
-l	行数据
-w	词数据
-m	字符数据

显示文件的行、词、字符数
cat /etc/man.config | wc

显示总共登录次数
last | grep [a-zA-Z] | grep -v wtmp | wc -l


tee双向重定向，参数：
-a	已累加的方式操作（>>）

last内容保存在last.txt中，同时用cut输出第一排内容
last | tee last.txt | cut -d ' ' -f 1


tr字符串删除或替换（translate）
-d	删除字符串
-s	替换掉重复的字符

last的所有输出转为大写
last | tr '[a-z]' '[A-Z]'

将输出的内容的':'删除
cat /etc/passwd | tr -d ':'

去掉dos换行符的一种方法：
tr -d '\r' file > newfile

col(tab \字符替换功能……额)
-x	将tab换成空格
-b	将反斜杠和后面的符号做处理

join将两个文件根据相同字段按照行连接起来
-t	符合条件的行连接的分隔符
-i	忽略大小写
-1	第一个文件的判断列
-2	第二个文件的判断列

用':'连接两个文件，第一列帐号名不会重复显示
join -t ':' /etc/passwd /etc/shadow

按照第几列来进行合并
join -t ':' -1 4 /etc/passwd -2 3 /etc/group


paste将两个（多个一样的）文件无条件按行连在一起
-d	分隔符，默认是tab
-	标识内容来自标准输入

连接两个文件
paste /etc/passwd /etc/shadow
cat /etc/shadow | paste /etc/passwd - 

expand将tab换成空格(unexpand是反过来将空格转化成tab)
-t	设置换成的空格数量，默认为8个

显示文件符合MANPATH开头的前三行
grep '^MANPATH' /etc/man.config  | head -n 3 | cat -A

替换tab为6个空格，并显示出来
grep '^MANPATH' /etc/man.config  | head -n 3 | expand -t 6 - | cat -A


split文件切割
-b	切分大小(可加单位:b,k,m等)
-l	按行分隔

分隔文件，每个文件上限10m，最后一个参数为文件前缀名
split -b 10m op_server op_server 
-rw-r--r-- 1 root root 10485760 4月  14 11:31 op_serveraa
-rw-r--r-- 1 root root  9563552 4月  14 11:31 op_serverab

合并分隔的文件：
cat op_server* >> op_server_sp

按行分隔，用标准输入(-)作为内容
ls -al | split -l 10 - lsroot


xargs参数代换(默认调用echo命令)(因为好多命令不支持管道，所以可以通过xargs来代替传入参数)
-0	特殊字符处理，如`,\,空格等，有这个参数就会将标准输入内容解析为普通字符串
-e	EOF,遇到它后面的字符串时，停止命令执行（字符串需要紧跟这e，否则不正常）
-p	在执行每个命令的参数时，询问
-n	每次命令执行的参数的个数

将帐号的前三名输出出来
cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs

增加确认提示
cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -p

每次只取两个参数传入
cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -p -n 2

遇到某个字符串后停止传入参数
cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -e'daemon'

强制杀死op_server这个程序
ps aux | grep op_server | awk '{if($11!="grep"){print $2;}}' | xargs kill -9


-减号的用途
代替标准输入输出
例子：前面的代表输出，后面的代表输入，额，好神奇，不知道做什么用的。
tar -cvf - /home | tar -xvf -


显示非root帐号登录的所有帐号
last | grep -v root | cut -d ' ' -f 1

diff文本、目录比较(按行比较)
cat /etc/passwd | sed -e '4d' -e '6c no six line' > passwd_n	创建测试比较文件
diff /etc/passwd passwd_n	两个目录比较文本区别
4d3	第4行不同，d：删除了，3：基准是右边第三行
< adm:x:3:4:adm:/var/adm:/sbin/nologin	左侧第四行内容
6c5	第6行不同，c：被替换了，济春航是右边第五行
< sync:x:5:0:sync:/sbin:/bin/sync	左侧内容
---
> no six line	右侧内容

cmp比较，按字节比较，可以比较二进制文件
cmp /etc/passwd passwd_n
/etc/passwd passwd_n differ: byte 106, line 4


根据比较的文件内容不同，可以创建补丁文件，并可以根据补丁文件更新和还原版本
diff -Naur passwd.old pass.new > passwd.patch	创建补丁文件
patch -p0 < passwd.patch	根据补丁更新文件
patch -R -p0 < passwd.patch	根据补丁还原旧版本


将搜索到的内容用颜色区分
grep --color=auto 'MANPATH' /etc/man.config 

grep参数：
--color=auto	显示颜色
-c	计算查找到的次数，不显示内容
-i	忽略大小写
-n	输出行号
-v	反向查找，不包含内容的行
-A	after，查找行后面的几行内容也显示
-B	before，查找行前面的几行内容也显示

正则特殊符号：
[:alnum:]	0-9,a-z,A-Z
[:alpha:]	a-z,A-Z
[:lower:]	a-z
[:upper:]	A-Z
[:digit:]	0-9
[:xdigit:]	0-9,a-f,A-F
[:blank:]	空格、tab
[:graph:]	空格、tab以外以他所有按键
[:cntrl:]	CR,LF,TAB,DEL
[:print:]	任何可以被打印出来的字符
[:punct:]	标点符号："'?!;:#$
[:space:]	会产生空白的字符：Tab,CR等

测试例子：
regular_express.txt ：
"Open Source" is a good mechanism to develop programs.
apple is my favorite food.
Football game is not use feet only.
this dress doesn't fit me.
However, this dress is about $ 3183 dollars.
GNU is free air not free beer.
Her hair is very beauty.
I can't finish the test.
Oh! The soup taste good.
motorcycle is cheap than car.
This window is clear.
the symbol '*' is represented as start.
Oh!	My god!
The gd software is a library for drafting programs.
You are the best is mean you are the no. 1.
The world <Happy> is the same with "glad".
I like dog.
google is the best tools for search keyword.
goooooogle yes!
go! go! Let's go.
# I am VBird

EOF

grep -n 'the' regular_express.txt	查找the在xxx文件中
grep -vn 'the' regular_express.txt	反向查找不包含the的行
grep -in 'the' regular_express.txt	忽略大小写查找
grep -n 't[ea]st' regular_express.txt	查找test或者tast包含的行
grep -n 'oo' regular_express.txt	查找oo内容
grep -n '[^g]oo' regular_express.txt	查找不是g开头的oo包含的行
grep -n '[^a-z]oo' regular_express.txt	查找大写字母接oo
grep '[^[:lower:]]oo' regular_express.txt	同上
grep -n '[0-9]' regular_express.txt	查找包含数字的行
grep -n '[[:digit:]]' regular_express.txt	同上
grep -n '^the' regular_express.txt	行首查找
grep -n '^[a-z]' regular_express.txt	开头是小写字母
grep -n '^[[:lower:]]' regular_express.txt	同上
grep -n '^[^a-zA-Z]' regular_express.txt	不是字母开头的行
grep -n '^[^[:alpha:]]' regular_express.txt	同上
grep -n '\.$' regular_express.txt	查找行尾是.结尾的行
grep -n '^$' regular_express.txt	查找空白行
grep -v '^$' /etc/sysctl.conf | grep -v '^#'	查找非空、非#开头的行
grep -n 'g..d' regular_express.txt	查找g??d的行
grep -n 'o*' regular_express.txt	因为o*标识有o或者没有o都可以，所以会把所有文件内容都显示出来，这个查找没有用
grep -n 'ooo*' regular_express.txt	查找两个及以上的连续o行
grep -n 'goo*g' regular_express.txt	查找gog,goog,gooog...行
grep -n 'g[[:alpha:]]*g' regular_express.txt	查找g开头,g结尾的单词
grep -n 'o\{2\}' regular_express.txt	查找两个oo的行
grep -n 'go\{2,5\}g' regular_express.txt	查找g/g中间有2-5个o的行
grep -n 'go\{2,\}g' regular_express.txt		查找g/g中间至少有2个o的行
ll /etc/ | grep '^l' | wc -l	查找文件夹下是连接的文件数量


sed参数：
-n	停止屏幕输出
-e	直接在命令行模式下操作，每个e后面都可以接一段命令
-f	执行文件内的命令
-r	使用扩展正则表达式语法
-i	直接修改读取的文件内容，而不是输出，修改源文件，危险！
n1,n2function	n1,n2标识操作范围是n1-n2行
a	追加在下面
c	替换行
d	删除
i	插入
p	打印
s	替换

例子：
nl /etc/passwd | sed '2,5d'	2-5行删除不显示，其他显示
nl /etc/passwd | sed '2d'	2行删除不显示，其他显示
nl /etc/passwd | sed '2,$d'	只显示第一行
nl /etc/passwd | sed '2a drink tea'	在第二行下面追加一行内容为drink tea
nl /etc/passwd | sed '2i drink tea'	在第二行上面追加一行内容为drink tea
nl /etc/passwd | sed '2,5c haha'	将2-5行内容替换为一行的haha
nl /etc/passwd | sed -n '2,5p'	只显示2-5行内容，同nl /etc/passwd | head -n 5 | tail -n 4
ifconfig eth0 | grep 'inet addr' | sed 's/^.*inet addr://g' | sed 's/Bcast.*$//g'	查找ip地址
cat /etc/man.config | grep 'MAN' | sed 's/#.*$//g' | sed '/^$/d'	查找所有包含MAN并且不是注释的行
sed -i 's/\.$/\!/g' regular_express.txt	将文件结尾的.替换成！
sed -i '$a # This is a test' regular_express.txt	将在文件结尾添加一行文字


扩展正则表达式
egrep -v '^$|^#' regular_express.txt	去除空行和注释行，正则之间可以用'|'标识或
+	go+d	一个或多个	god,good,goood...
?	go?d	零个或一个	gd,god
|	gd|good	或匹配	gd,good
()	g(la|oo)d	按组匹配	glad,good
()+	a(bc)+d	按组匹配扩展	abcd,abcbcd...


printf格式化输出
printf.txt：
AAAAAAA	BBBBBBBBB	CCCCCCCC
a	aaa	111
b	bbb	222
c	ccc	333
d	ddd	444


printf '%10s\t%10s\t%10s\n' $(cat printf.txt)	按格式输出内容
printf '\x45\n'	显示E,ascII的输出


test判断条件是否成立
文件类型：test -e file
-e	文件名是否存在
-f	文件名是否存在并且为文件
-d	文件名是否存在并且为文件夹
-b	文件名是否存在并且为block device设备
-c	文件名是否存在并且为character device设备
-S	文件名是否存在并且为Socket文件
-p	文件名是否存在并且为一个FIFO(pipe)文件
-L	文件名是否存在并且为一个链接文件
文件权限检测：test -r file
-r	文件名是否存在且可读
-w	文件名是否存在且可写
-x	文件名是否存在且可执行
-u	文件名是否存在且具有SUID的属性
-g	文件名是否存在且具有SGID的属性
-k	文件名是否存在且具有Sticky bit的属性
-s	文件名是否存在且为非空白文件
文件比较：test file1 -nt file2
-nt	判断文件1是否比文件2新 newer than
-ot	判断文件1是否比文件2旧 older than
-ef	判断两个文件是否为同一文件，文件是否指向同一个inode上
数值比较：test n1 -eq n2
-eq	== equal
-ne	!= not equal
-gt	> greater than
-lt	< less than
-ge	>= greater than or equal
-le	<= less than or equal
字符串判断：test -z $str
-z	字符串是否为空
-n	或没有参数，字符串是否不为空
=	test str1 = str2 两个字符串是否相等
!=	test str1 != str2 两个字符串是否不等
多重判断参数，逻辑与或非：test -r file -a -x file
-a	and 是否同时成立
-o	or 任意一个成立
!	非 test ! -x file 没有可执行权限才返回真

[]用法和test基本一样，注：中括号内要有空格分隔，否则会报错，因为和正则表达式、通配符等有冲突
[ "$a" == "$b" ]	判断两个字符串是否相等
[ "$param" == "Y" -o "$param" == "y" ] && res="Yes"	判断字符串是否为y或Y


shell的参数：
$#	参数的个数(不包含脚本名)
$@	整个参数
$*	整个参数
$0	当前脚本名
$1	第一个参数
$2	第二个参数

shift参数偏移
将参数下标前移，例：
a.sh 1 2 3 4 5
$1 1,$2 2,$3 3,$4 4,$5 5
shift
$1 2,$2 3,$3 4, $4 5
shift 3
$1 5

date操作
date -d '20150415' +%s	获取20150415的时间戳
1429027200
date -d @1429027200	将时间戳转化为具体日期
2015年 04月 15日 星期三 00:00:00 CST
date +%s	当前时间戳
date	当前时间

ls	显示文件夹下内容
ll	显示文件夹下内容详细信息
ll -d	显示文件夹详细信息

____________________________________________________________

iconv编码转换
-f	从xxx编码
-t	转化到xxx编码
-o	输出文件
-l	列出支持的编码

iconv -f gbk -t utf8 protocol.txt -o protocol.txt_

dos2unix protocol.txt	# 去除^M符号

____________________________________________________________


shell script：

条件判断：
if []; then
fi

if []; then
else
fi

if []; then
elif []; then
fi

条件：
[] && [];
[] || [];

算术运算：
declare -i res=$(($a+$b))

case判断：
case $1 in
	"a")
	;;
	"b")
	;;
	*)
	;;
esac

while循环 条件为真循环
while []
do
done
while []; do
done

until循环 条件为真退出循环
until []; do
done

for循环
迭代方式：
for in
do
done
for in; do
done
for in $(seq 2 100); do # 2-100循环99次
done
递增方式
for ((i=1;i<=$max;i=i+1)); do
done


函数：
function fun()
{
	echo "aaa $1"
}


语法检查，shell的追踪和调试
sh命令的参数来实现
-n	不执行脚本，仅查询语法问题
-v	在执行脚本前，先输出script的内容（额，这个不如-x方便，不好看）
-x	将使用到的script的内容显示到屏幕上


____________________________________________________________

帐号管理


创建帐号
useradd pan
创建密码
passwd pan
删除用户 比较危险
userdel pan	参数:-r 连目录也一起删除
查找某个用户的相关文件
find / -user username


创建帐号包含默认组
useradd -g groupname pan
锁定帐号密码（无法登录，锁定帐号）
passwd -l pan
解锁帐号密码
passwd -u pan
修改自己帐号的密码
passwd
创建一个默认密码，并在第一次登录时强制对方修改密码
useradd test	# 创建用户
echo "test" | passwd --stdin test	# 创建初始密码
chage -d 0 test	# 修改创建密码的日期为0，从而强制修改密码
新建帐号文件夹的模版：/etc/skel
设置追加增加帐号组(覆盖)
useradd -G groupname pan	有效分组被覆盖(基本不会用)
useradd -aG groupname pan	真正的追加，不改变现有有效分组
删除用户 包含主文件夹/mailbox/crontab 危险
userdel -r pan

查询当前的登录信息
who
查询帐号信息
id	默认查询自己
id root

新建用户组
groupadd groupname
用户组改名
groupmod -n goldname gnewname
删除用户组(初始用户组不能这样删除)
groupdel groupname

用户组管理功能
gpasswd
gpasswd group1	# 给group1增加管理密码
gpasswd -A user group1	# 将用户user设为group1的管理员
用user登录
gpasswd -a user1 group1	# 将用户user1加入group1组中

gpasswd -a user group	# 用户添加到分组
gpasswd -d user group	# 用户删除出分组

给几个帐号创建一个共同的工作目录，可以在这里修改、创建、访问文件
groupadd proj	# 创建分组
useradd -G proj -c "proj user" pro1	# 创建分组帐号
useradd -G proj -c "proj user" pro2
useradd -G proj -c "proj user" pro3
echo "proj" | passwd --stdin pro1	# 创建帐号密码
echo "proj" | passwd --stdin pro2
echo "proj" | passwd --stdin pro3
mkdir /srv/proj	# 创建工作目录
chgrp proj /srv/proj	# 变更工作目录分组
chmod 2770 /srv/proj	# 设置权限2标识sgid,同组人员在文件夹内创建的文件都是这个组的文件

acl权限设置，可针对用户、组、来单独设置对文件、文件夹的权限操作

判断acl是否可用：
mount	查询是否有acl功能信息
dumpe2fs -h /dev/sda2	查询是否有acl功能信息
没有的话可以开启
mount -o remount,acl /

setfacl/getfacl参数
-m	增加权限
-x	减少权限
-b	删除所有acl权限
-R	递归操作
-k	删除默认的acl参数
-d	设置默认的acl参数(目录)

setfacl -m u:pan:rx file1	# 设置pan对文件有rx权限(对设置后新增文件无效)
getfacl file1	# 查看文件acl信息，其中mask的功能是限制最大开放权限，mask:r,user:rw的话，user只有r权限
setfacl -m g:group1:rx file1	# 设置组group1对文件有rx权限(对设置后新增文件无效)
setfacl -m d:[ug]:[rwx] file1	# 通过默认权限来设置后续新增文件的acl权限
setfacl -b file1	# 取消acl权限


su/sudo切换到root权限帐号

su	# 直接切换nologinshell的root，path等信息不变
su -	# 直接切换loginshell的root，相当于root登录一样;PAHT/USER/MAIL环境变量的区别
su -c "head -n 3 /etc/shadow"	# 只运行一个命令,就切换回来

sudo
支持无密码登录，并且可以登录nologinshell的帐号
配置文件 /etc/sudoers
修改的话，用visudo命令
帐号		登录主机名=(可以切换的帐号)	可执行的命令
root		ALL=(ALL)			ALL
添加用户组权限
%groupname	ALL=(ALL)			ALL
无密码使用sudo
%groupname	ALL=(ALL)			NOPASSWD:ALL

只让userA可以使用root权限修改他人密码
userA		ALL=(root)			/usr/bin/passwd	# 命令必须是绝对路径，但是可以修改root的密码……需要处理
userA		ALL=(root)			!/usr/bin/passwd, !/usr/bin/passwd root, /usr/bin/passwd [a-zA-Z]*	# 解决上面的问题,!标识不准许执行

可以通过别名来批处理权限命令(别名必须大写)
User_Alias ADM_U = user1, user2
Cmnd_Alias ADM_CMD = !/usr/bin/passwd, !/usr/bin/passwd root, /usr/bin/passwd [a-zA-Z]*
ADM_U	ALL=(root)	ADM_CMD	# 即可实现多用户可已执行相同命令

用sudo切换到su(额，好多的root帐号，不安全)
userA	ALL=(root)	/bin/su -


用户登录日志
/var/log/secure
/var/log/messages

____________________________________________________________


本文总结了Linux添加或者删除用户和用户组时常用的一些命令和参数。
1、建用户：
adduser phpq                             //新建phpq用户
passwd phpq                               //给phpq用户设置密码

2、建工作组
groupadd test                          //新建test工作组

3、新建用户同时增加工作组
useradd -g test phpq                      //新建phpq用户并增加到test工作组

注：：-g 所属组 -d 家目录 -s 所用的SHELL


4、给已有的用户增加工作组
usermod -G groupname username

或者：gpasswd -a user group

5、临时关闭：在/etc/shadow文件中属于该用户的行的第二个字段（密码）前面加上*就可以了。想恢复该用户，去掉*即可。

或者使用如下命令关闭用户账号：
passwd peter –l

重新释放：
passwd peter –u

6、永久性删除用户账号
userdel peter

groupdel peter

usermod –G peter peter   （强制删除该用户的主目录和主目录下的所有文件和子目录）

7、从组中删除用户
编辑/etc/group 找到GROUP1那一行，删除 A
或者用命令
gpasswd -d A GROUP

8、显示用户信息
id user
cat /etc/passwd

更详细的用户和用户组的解说请参考
Linux 用户和用户组详细解说
本文主要讲述在Linux 系统中用户(user)和用户组(group)管理相应的概念；用户(user)和用户组(group)相关命令的列举；其中也对单用户多任务，多用户多任务也做以解说。

本篇文章来源于 PHP资讯 原文链接：http://www.phpq.net/linux/linux-add-delete-user-group.html

____________________________________________________________


主机帐号状态信息查询
目前的登录状态：
w/who

历史登录记录，从系统安装完成开始
last

所有帐号的最后一次登录信息
lastlog

____________________________________________________________

主机上用户间通信
who	# 查询目标通信用户
write pan pts/1	# 发送消息即可，单独发送
hello!
this is a test.
<C-D>

mesg	# 显示当前接收信息的状态
mesg n	# 如果不想接收信息
mesg y	# 开启接收消息

wall "hahahaha……everyone on this machine can see"	# 广播

____________________________________________________________

邮件mailbox功能

邮件配置文件(可以配置用默认的邮件或者是配置的邮件)
/etc/mail.rc
邮箱目录
/var/spool/mail/$user

mail	# 进入邮箱
?	帮助
h	显示列表，可包含参数数量
d	删除，后加邮件序号(q后生效，x后失效)
s	保存成文件 s 1 abc.txt
x	退出不保存邮箱操作
q	退出保存邮箱操作
[num]	输入序号可以直接查看邮件

mail username@localhost	# 本地帐号不需要操作
标题
正文
.	# .标识邮件结束

____________________________________________________________

用现有硬盘模拟一个新硬盘(模拟硬盘)
dd if=/dev/zero of=loopdev bs=1M count=512	# 创建硬盘数据文件
mkfs -t ext4 loopdev	# 格式化成ext4格式的硬盘
mkdir loop	# 创建一个挂载目录
mount -o loop loopdev loop	# 将数据文件模拟硬盘挂载到创建的目录上
umount /home/pan/test/dev/loopdev	# 用完后可以卸载硬盘数据文件
____________________________________________________________

quota
限制用户、用户组磁盘数据量的使用空间

quota使用记录

quota开启
mount -o remount,usrquota,grpquota loop	# 重新挂载硬盘，加入quota的支持（本次启动有效，启动自动生效，要修改/etc/fstab文件（注意修改测试）），会修改/etc/mtab的配置文件
mount | grep loop	# 查看是否加入quota支持成功
quotacheck -avug	# 根据/etc/mtab文件来初始化quota信息(跟挂载目录生成aquota.group，aquota.user)
quotaon -avug	# 开启quota功能（开一次，以后重启系统自动开启/etc/rc.d/rc.sysint）（关闭：quotaoff -[aug]）
edquota -u pan	# 编辑帐号pan的quota信息（单位kb）
edquota -p pan -u user1	# 将pan的配额配置复制给user1
edquota -g pan	# 编辑用户组pan的quota信息
edquota -t	# 编辑宽限时间
setquota [-u|-g] 名称 sblock hblock sinode hinode 文件系统	# 通过命令、参数直接设置quota

quota配置查询
quota [-ugvs]	# 针对用户
reqquota -a [-vugs]	# 查询文件系统的配置

quota测试
dd if=/dev/zero of=bigfile bs=512k count=5	# 创建测试数据文件
loop0: warning, user block quota exceeded.	# 错误提示信息,quota查询reqquota可以看到超时时间已经开始计时了
dd: 正在写入"bigfile2": 超出磁盘限额	# 再次操作超出限额，多出的数据无法写入

通知用户所有磁盘配额已用完
warnquota	# 直接运行即可，mail通知
vim /etc/warnquota.conf		# 修改warnquota发送的邮件信息
每日自动执行warnquota：
vim /etc/cron.daily/warnquota:添加：/usr/sbin/warnquota
chmod 755 /etc/cron.daily/warnquota

____________________________________________________________

RAID磁盘阵列
Redundant Arrays of Inexpensive Disks

建立soft raid流程
虚拟机增加硬盘5G
fdisk -l	# 查看目前使用的硬盘，可以看到下面新增的没有使用的/dev/sdb
fdisk /dev/sdb	# 磁盘分区
n 创建;p 主分区;1 序号1;<CR> 起始位置;+100M 分区大小;	# 创建主分区
n 创建;e 扩展分区;2 序号2;<CR> 起始位置柱面;<CR> 终止柱面使用最大值（硬盘完全使用）;	# 创建扩展分区
n 创建;l 路基分区;<CR> 起始柱面位置;+100M 分区大小;	# 创建逻辑分区*5

partprobe	# 不重启更新内核的partition table 新建分区后需要调用

mdadm --create --auto=yes /dev/md0 --level=5 --raid-devices=4 --spare-devices=1 /dev/sdb{5,6,7,8,9}	# 创建raid5磁盘阵列

mdadm --detail /dev/md0	# 查询阵列磁盘状态
cat /proc/mdstat	# 查看系统的磁盘阵列情况

mkfs -t ext4 /dev/md0	# 格式化硬盘

mkdir raid	# 创建挂载目录
mount /dev/md0 raid/	# 挂载磁盘阵列硬盘


模拟阵列磁盘错误处理
mdadm --manage /dev/md0 --fail /dev/sdb8	# 人为设置磁盘错误来模拟实际错误
mdadm --detail /dev/md0	# 查看磁盘阵列状态
cat /proc/mdstat	# 查看磁盘阵列状态
结论：单一磁盘出现错误后，系统会自动将spare磁盘顶替错误的磁盘，这中间有一个很短的时间处理过程

出错恢复后后续处理
用一个同样大小的词牌来替代错误的磁盘
fdisk /dev/sdb;n;l;<CR>;+100M;w	# 创建一个同样大小的磁盘
partprobe	# 通知系统更新磁盘变化信息
mdadm --manage /dev/md0 --add /dev/sdb10 --remove /dev/sdb8	# 用新磁盘代替旧磁盘

设置开机自动识别raid并挂载
mdadm --detail /dev/md127 | grep UUID	# 找到设备的UUID
vim /etc/mdadm.conf	# 编辑设置raid配置文件，设置设备名和对应的uuid的关联信息
ARRAY /dev/md0 UUID=51910498:e6401b70:9cd58c3a:994f9727	# 添加关联文件
vim /etc/fstab	# 设置开启自动挂载
/dev/md0                /home/pan/test/dev/raid ext4    defaults        1 2	# 配置自动挂载配置文件
!!重要
umount /dev/md0; mount -a	# 重新挂载md0，测试/etc/fstab文件是否正常使用，有问题要修改，否则系统无法启动
df /home/pan/test/dev/raid	# 查看、检查挂载信息

关闭软件RAID
因为是测试，不需要使用的话，就关闭这个东西
umount /dev/md0		# 卸载md0
vim /etc/fstab	# 注释或者删掉自动挂载文件系统信息
#/dev/md0                /home/pan/test/dev/raid ext4    defaults        1 2
mdadm --stop /dev/md0	# 停止/dev/md0的软件阵列
cat /proc/mdstat	# 阵列信息已经不存在在这个文件当中了
vim /etc/mdadm.conf	# 注释掉或者删除掉相应的配置信息
#ARRAY /dev/md0 UUID=51910498:e6401b70:9cd58c3a:994f9727

PS:
磁盘阵列只有多个磁盘使用才有效果，单一磁盘写入读取是一样的，并且数据损坏了也没有办法还原，因为实际只有一个硬盘

____________________________________________________________

常用功能alias添加~/.bashrc

grep='grep --color=auto'


____________________________________________________________

特殊权限管理
suid,sgid,sticky bit
suid	4	s	文件	执行文件时可以让用户获得程序owner的权限
sgid	2	s	文件	执行文件时可以让用户获得程序group的权限
			文件夹	在该目录下新建文件的组将自动为该文件夹组
sbit	1	t	文件夹	该文件夹下新建文件只能创建人和root可以删除
使用方法：
chmod 7777 fileName	最前面的那位为特殊权限，fileName的权限是:-rwsrwsrwt
另外
当没有x权限时，上面的设置会变成大写的S、S、T，无效


____________________________________________________________

搜索：
which
	功能：
		按照PATH路径顺序查找所有binary文件，用于查找命令
	参数：
		-a	全部搜索
	注：
		只能搜索完整名称

whereis
	功能：
		搜索档案或目录名
	参数：
		-b	2进制文件
	注：
		只能搜索完整名称

locate
	功能：
		查找文件
	参数：
		-b	basename
	注：
		搜索完整文件名：locate -b "\fileName";\表示前面没有内容

find
	功能：
		硬盘搜索
	参数：
		-name 按文件名搜索
	注：
		例子：find /etc -name httpd.conf;find很灵活，可以搜索时间，权限，大小等内容

type
	功能：
		显示文件的类型，可执行文件显示路径，内建，别名等信息

____________________________________________________________


字符串操作
str="aaazbbbzccc"
echo ${str/z/y}	aaaybbbzccc
echo ${str//z/y}	aaaybbbyccc
____________________________________________________________


$()	在中间为子 shell 的起始与结束
$[]	在中间为字符的组合
${}	在中间为命令区块的组合

____________________________________________________________

各种登录日志查看

登录日志
more /var/log/secure
最近登录信息
who /var/log/wtmp

干了些什么？
root账户下输入su - username
切换到username下输入
history
能看到这个用户历史命令，默认最近的1000条

使用root登陆使用last -x可查看用户登陆历史
last 命令：
　　功能说明：列出目前与过去登入系统的用户相关信息。
　　语 法：last [-adRx][-f ][-n ][帐号名称…][终端机编号…]
　　补充说明：单独执行last指令，它会读取位于/var/log目录下，
　　名称为wtmp的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。
　　参 数：
　　-a 把从何处登入系统的主机名称或IP地址，显示在最后一行。
　　-d 将IP地址转换成主机名称。
　　-f 指定记录文件。
　　-n 或- 设置列出名单的显示列数。
　　-R 不显示登入系统的主机名称或IP地址。
　　-x 显示系统关机，重新开机，以及执行等级的改变等信息。


____________________________________________________________

分割拆分大文件并合并

分隔
split
	split -b 100m bigFile tarFile
	->	tarFileaa tarFileab ...

合并
	cat tarFile* >> tarFile
____________________________________________________________

比较文件不同，制作补丁，打补丁，回滚补丁
	原始内容：
		a:
		1
		22
		333
		4444
		b:
		1
		222
		333
		diff a b
		2c2
		< 22
		---
		> 222
		4d3
		< 4444
	
	制作补丁(a 旧文件; b 新文件)
		diff a b > patch_file
	
	给a打补丁
		patch a patch_file
			cat a
				1
				222
				333
	
	回滚a
		patch -R a patch_file
			cat a
				1
				22
				333
				4444

____________________________________________________________


显示所有端口监听占用？
netstat -tuln

____________________________________________________________


判断后面是否需要接';'与后面是否有其他代码有关，有代码就有';'没有代码则没有';'
[]

条件判断1
	if []
	then
	elif
	else
	fi

条件判断2
	case 内容 in
		"数值1")
			...
			;;
		"数值2")
			...
			;;
		*)
			...
			;;
	esac

函数(需要在调用之前定义,否则无效不报错)
	function 函数名(){
		echo "参数个数:$#,函数名:$0,参数1:$1,参数2:$2..."
	}
	函数名 参数1 参数2 ...

循环1
	sum=0
	a=1
	while [ "$a" -le "100"  ]
	do
		sum=$(($sum+$a))
		a=$(($a+1))
	done
	echo $sum

循环2
	sum=0
	a=1
	until [ "$a" -gt "100"  ]
	do
		sum=$(($sum+$a))
		a=$(($a+1))
	done
	echo $sum

循环3
	sum=0
	a=1
	for ((i=0; i<=100; i=i+1))
	do      
		sum=$(($sum+$i))
	done
	echo $sum

循环4
	for a in "aaa" "bbb" "ccc"
	do
		echo $a
	done

调试
	sh
		参数
			-n	不执行，检查语法
			-v	执行脚本前，先输出脚本
			-x	按步骤输出并执行脚本

____________________________________________________________

linux帐号组相关
帐号文件
/etc/passwd
密码文件
/etc/shadow
组文件
/etc/group
组密码文件
/etc/gshadow

显示用户详细信息
id 用户名
显示登录帐号的组信息	并且第一个显示的就是当前的有效组(创建文件的所属组是这个有效组)
groups

切换当前的有效组(是切换，不是新建~，另外该操作新开了一个shell，是子shell)
newgrp 组名
	exit	可以退出切换组，回到原来的shell里


____________________________________________________________

定时执行：
at	执行一次	atq(显示列表)	atrm(删除at队列的内容)
cron	每隔时间执行

at 执行时间
	04:00
	04:00 2005-12-03
	04pm December 3
	now+5minutes
	04pm+3days

crontab
	参数：
		-l 显示列表
		-e 编辑
		-r 删除

		代表意义 分钟 小时 日期 月份 周
		数字范围 0-59 0-23 1-31 1-12 0-7

		特殊字符 代表意义
		* 代表任何时刻都接受的意思！举例来说，上表的范例一，那个日、月、周都是 * ， 就代表着『不论何月、何日的礼拜几的 12:00 都执行后续指令』的意思！
		, 代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是：0 3,6 * * * command 还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！
		- 代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作： 20 8-12 * * * command 仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！
		/n 那个 n 代表数字，亦即是『每隔 n 单位间隔』的意思，例如每五分钟进行一次，则： */5 * * * * command 很简单吧！用 * 与 /5 来搭配，也可以写成 0-59/5 ，相同意思！

还有建议您：『指令下达 时，最好使用绝对路径，这样比较不会找不到执行档喔！』

____________________________________________________________

jobs
	显示当前背景中的工作
	-l	都显示
	-r	显示运行的
	-s	显示暂停的

fg
	将jobs的内容切换到前景来显示，默认显示有+标识的，其他需要加序号

bg
	将jobs的内容切换到后台执行，就是命令后面加&

____________________________________________________________

man x command 中x的标识说明

1、Standard commands （标准命令）
2、System calls （系统调用）
3、Library functions （库函数）
4、Special devices （设备说明）
5、File formats （文件格式）
6、Games and toys （游戏和娱乐）
7、Miscellaneous （杂项）
8、Administrative Commands （管理员命令）
9 其他（Linux特定的）， 用来存放内核例行程序的文档。


____________________________________________________________

top [-d] | top [-bnp]
参数：
-d ：后面可以接秒数，就是整个程序画面更新的秒数。预设是 5 秒；
-b ：以批次的方式执行 top ，还有更多的参数可以使用喔！
 通常会搭配数据流重导向来将批次的结果输出成为档案。
-n ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。
-p ：指定某些个 PID 来进行观察监测而已。
在 top 执行过程当中可以使用的按键指令：
 ? ：显示在 top 当中可以输入的按键指令；
 P ：以 CPU 的使用资源排序显示；
 M ：以 Memory 的使用资源排序显示；
 N ：以 PID 来排序喔！
 T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。
 k ：给予某个 PID 一个讯号 (signal)
 r ：给予某个 PID 重新制订一个 nice 值。

top 主要分为两个画面，上面的画面为整个系统的资源使用状态，基本上总共有六行， 显示的内容依序是：
? 第一行：显示系统已启动的时间、目前上线人数、系统整体的负载(load)。 比较需要注意的是系
统的负载，三个数据分别代表 1, 5, 10 分钟的平均负载。 一般来说，这个负载值应该不太可能
超过 1 才对，除非您的系统很忙碌。 如果持续高于 5 的话，那么.....仔细的看看到底是那个
程序在影响整体系统吧！
? 第二行：显示的是目前的观察程序数量，比较需要注意的是最后的 zombie 那个数值，如果不是
0 ，嘿嘿！好好看看到底是那个 process 变成疆尸了吧？！
? 第三行：显示的是 CPU 的整体负载，每个项目可使用 ? 查阅。需要观察的是 id (idle) 的数值，
一般来说，他应该要接近 100% 才好，表示系统很少资源被使用啊！ ^_^。
? 第四行与第五行：表示目前的物理内存与虚拟内存 (Mem/Swap) 的使用情况。
? 第六行：这个是当在 top 程序当中输入指令时，显示状态的地方。 例如范例四就是一个简单的
使用例子。

至于 top 底下的画面，则是每个 process 使用的资源情况。比较需要注意的是：
? PID ：每个 process 的 ID 啦！
? USER：该 process 所属的使用者；
? PR ：Priority 的简写，程序的优先执行顺序，越小越早被执行；
? NI ：Nice 的简写，与 Priority 有关，也是越小越早被执行；
? %CPU：CPU 的使用率；
? %MEM：内存的使用率；
? TIME+：CPU 使用时间的累加；

____________________________________________________________

pstree
	显示进程树，找父进程子进程关系用
	-A	乱码用
	-u	显示程序执行用户
	-p	显示pid(可讲所有省略到一起的内容显示出来(完全没有用……))

____________________________________________________________

杀死某个grep出来的程序
kill -SIGHUP `ps aux|grep 'syslog'|grep -v 'grep'|awk '{print $2}'`


____________________________________________________________


free
	查看内存的使用状态

	free命令、buffer与cache的区别 
		free 命令相对于top 提供了更简洁的查看系统内存使用情况：
			http://blog.chinaunix.net/uid-78363-id-2039911.html
			# free
				     total       used       free     shared    buffers     cached
			Mem:        255988     231704      24284          0       6432     139292
			-/+ buffers/cache:      85980     170008
			Swap:       746980          0     746980

			Mem：表示物理内存统计 
			-/+ buffers/cached：表示物理内存的缓存统计 
			Swap：表示硬盘上交换分区的使用情况，这里我们不去关心。
			系统的总物理内存：255988Kb（256M），但系统当前真正可用的内存并不是第一行free 标记的 24284Kb，它仅代表未被分配的内存。

			我们使用total1、used1、free1、used2、free2 等名称来代表上面统计数据的各值，1、2 分别代表第一行和第二行的数据。

			total1：表示物理内存总量。 
			used1：表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用。 
			free1：未被分配的内存。 
			shared1：共享内存，一般系统不会用到，这里也不讨论。 
			buffers1：系统分配但未被使用的buffers 数量。 
			cached1：系统分配但未被使用的cache 数量。buffer 与cache 的区别见后面。 
			used2：实际使用的buffers 与cache 总量，也是实际使用的内存总量。 
			free2：未被使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存。

			可以整理出如下等式：

			total1 = used1 + free1
			total1 = used2 + free2
			used1 = buffers1 + cached1 + used2
			free2 = buffers1 + cached1 + free1
			buffer 与cache 的区别
			A buffer is something that has yet to be "written" to disk. A cache is something that has been "read" from the disk and stored for later use.
			 
			两者都是RAM中的数据。简单来说，buffer是即将要被写入磁盘的，cache是被从磁盘中读出来的。
			buffer是由各种进程分配的，被用在如输入队列等方面，一个简单的例子如某个进程要求有多个字段读入，在所有字段被读入完整之前，进程把先前读入的字段放在buffer中保存。
			cache经常被用在磁盘的I/O请求上，如果有多个进程都要访问某个文件，于是该文件便被做成cache以方便下次被访问，这样可提供系统性能。


____________________________________________________________

uname
	查看系统信息
	参数：
		-a	全部
		-r	核心版本

____________________________________________________________

uptime
	开机时间，用户数，负载
	就是top的第一行

____________________________________________________________


netstat
	这个 netstat 也是挺好玩的，其实，这个指令比较常被用在网络的监控方面， 不过，在程序管理方面也
	是需要了解的啦！这个指令的执行如下所示：基本上， netstat 的输出分为两大部分，上面是网络接口相
	关的联机，下方则是与 unix 程序有关的项目。
	[root@linux ~]# netstat -[atunlp]
	参数：
	-a ：将目前系统上所有的联机、监听、Socket 数据都列出来
	-t ：列出 tcp 网络封包的数据
	-u ：列出 udp 网络封包的数据
	-n ：不已程序的服务名称，以埠号 (port number) 来显示；
	-l ：列出目前正在网络监听 (listen) 的服务；
	-p ：列出该网络服务的程序 PID

	找出目前系统上已在监听的网络联机及其 PID
		netstat -tulnp

____________________________________________________________


dmesg
	开机日志
	内容比较多，可以用grep或者less帮助显示查找

____________________________________________________________

修改机器时区
1、修改/etc/sysconfig/clock         ZONE=Asia/Shanghai
2、rm /etc/localtime3、链接到上海时区文件       
 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
执行完上述过程后，重启机器，即可看到时区已经更改。

____________________________________________________________

sar
	统计系统当前平均状态的工具程序
	参数
		-u	cpu状态
		-r	内存状态

	例子：
		统计目前主机 CPU 状态，每秒一次，共计三次！
		sar -u 1 3
		Linux 2.6.32-431.el6.x86_64 (localhost.localdomain) 	2015年10月18日 	_x86_64_	(1 CPU)

		17时03分07秒     CPU     %user     %nice   %system   %iowait    %steal     %idle
		17时03分08秒     all      1.00      0.00      4.00      0.00      0.00     95.00
		17时03分09秒     all      0.00      0.00      4.00      0.00      0.00     96.00
		17时03分10秒     all      0.00      0.00      4.04      0.00      0.00     95.96
		平均时间:     all      0.33      0.00      4.01      0.00      0.00     95.65

____________________________________________________________

PRI和NI	(priority&nice)
	两个值加在一起标识执行的优先度，越小越优先，取值范围-20~19
	系统管理PRI，用户可以手动修改NI
	改变一个程序的nice值：
		nice -n 值 -p 程序名 &	新启动一个程序
		renice 值 pid	已有程序

____________________________________________________________

fuser
	查找使用文件/文件夹的程序pid

____________________________________________________________

lsof
	程序功能未知

____________________________________________________________

pidof
	获取当前运行这个程序的pid
	例子
		pidof op_server

____________________________________________________________

runlevel
	显示当前的运行等级

init 数字
	切换当前的运行等级

____________________________________________________________

depmod
	更新kernel，模块、驱动
		无参数	重新写入文件
		-A	追加新模块

	目录路径
	/lib/modules/`uname -r`/kernel/
	/lib/modules/`uname -r`/modules.dep

lsmod
	显示目前核心加载了多少的模块

modinfo
	查阅每个模块的信息

核心模块的加载与移除： insmod, modprobe, rmmod

____________________________________________________________

因设定错误而无法开机
硬盘挂载问题：
通常就是 /etc/fstab
利用『 mount -n -o remount,rw / 』重新挂载根目录， 之后将刚刚设定错误的地方修改一下，
就可以重新开机啦！

但万一是因为不正常关机，导致开机时进行 fsck 无法成功，而出现类似这样的几行字：
/home contains a file system with errors,check blocks.
/home:Group 81's inode table at 2654219 conflicts with some other fs blocks.
/home: UNEXPECTED INCONSISTENCY ; RUN fsck MANUSLLY
(i.e. , without –a or –p options)
*** An error occurred during the file system check.
*** Dropping you to a shrll ; the system will reboot
*** when you to leave shell....
 Give root password for maintenance(or type Control-D for normal startup):
这表示你的 filesystem 可能有扇区错乱的情况，一般来说，这样的扇区错乱应该不是实体硬盘错误， 比
较可能是由于不正成关机造成 filesystem 的不一致 (Inconsistent) 所造成的。 造成这个问题之后，我
们必须要输入 root 的密码，进入 run level 1 ， 然后以 fsck /dev/hd[a-d][1-16] 来修复磁盘。例如，
假设上面的案例中， /home 挂载在 /dev/hda6 上面，那我就『 fsck /dev/hda6 』，不要加上任何参数。
等到系统发现错误，并且出现『clear [Y/N]』时，输入『 y 』吧！

忘记 root 密码的解决之道：
大家都知道鸟哥的记忆力不佳，容易忘东忘西的，那如果连 root 的密码都忘记了，怎么办？ 其实在 FC4
上面，root 密码忘记的情况下，应该是不难解决啦！只要能够进入并且挂载 / ， 然后修改一下
/etc/shadow 内的 root 密码栏 (第二栏啊，参考账号管理) 重新开机后， root 就不需要密码即可登入
啊！因为在 FC4 上面进入 run level 1 是不需要密码的。 整个动作有点像这样：
1. 在开机的时候，到达选单时，我们以较常见的 grub 作为介绍。出现选单后， 将光棒移动到要开
机的那个项目上面，然后按下『 e 』进入细项设定，选择『 kernel 』那一项， 再按『 e 』进
入编修画面，在最后面加上一个单一的『 1 』(数字 1, 2, 3 的 1 啊！)， 按下 [Esc] 按键，
然后按下『 b 』，就能够以该 kernel 进入 run level 1 了。
2. 进入 Linux 后，不需要输入密码，直接就会是 root 的身份，立刻 vi /etc/shadow ， 将 root
所在那一行的第二个字段给他全部抹除，储存后离开，然后『 reboot 』重新开机。
3. 由于 root 没有密码了，最好在重新开机前就将网络线拔掉，然后以 root 登入，然后立即设定
root 新密码，这样 root 的密码就算是救回来了。
那如果你的 Linux distribution 算是比较严谨的，所以登入 run level 1 时，还是得要输入 root 密码，
怎么办？很简单啊！可以：
? 使用 Live CD ，例如 KNOPPIX (可以在台南县网中心，小三老师发起的，阿里巴巴兄负责维护的
这个网站： http://knoppix.tnc.edu.tw/ 下载)， 将 KNOPPIX 的映象档下载，然后烧录成为光
盘，并以此片光盘开机， 就能够进入 Linux 系统啦！之后，再挂载 / ，然后按照上面的密码修
改一下， 嘿嘿！成功！
? 在开机的选单上，将原本 kernel 项目最后方加上『 init=/bin/bash 』修改一下登入的 shell ，
不使用 init ，就能够不使用 init ，而直接丢一个 shell 给使用者。不过， 除非很严重的错
误，否则不要用这个方法！

利用 chroot 切换到另一颗硬盘工作
仔细检查一下，你的 Linux 里面应该会有一个名为 chroot 的指令才对！这是啥？ 这是『 change root
directory 』的意思啦！意思就是说，可以暂时将根目录移动到某个目录下， 然后去处理某个问题，最后
再离开该 root 而回到原本的系统当中。
举例来说，补习班中心最容易有两三个 Linux 系统在同一个主机上面，假设我的第一个 Linux 无法进入
了，那么我可以使用第二个 Linux 开机，然后在第二个 Linux 系统下将第一个 Linux 挂载起来， 最后
用 chroot 变换到第一个 Linux ，就能够进入到第一个 Linux 的环境当中去处理工作了。
你同样也可以将你的 Linux 硬盘拔到另一个 Linux 主机上面去，然后用这个 chroot 来切换， 以处理你
的硬盘问题啊！那怎么做啊？粉简单啦！
1. 用尽任何方法，进入一个完整的 Linux 系统 ( run level 3 或 5 )；
2. 假设有问题的 Linux 磁盘在 /dev/hdb1 上面，且他整个系统的排列是：
/ → /dev/hdb1
/var → /dev/hdb2
/home → /dev/hdb3
/usr → /dev/hdb5
若如此的话，那么在我目前的这个 Linux 底下，我可以建立一个目录， 然后可以这样做：
/chroot/ → /dev/hdb1
/chroot/var/ → /dev/hdb2
/chroot/home/ → /dev/hdb3
/chroot/usr/ → /dev/hdb5
全部挂载完毕后，再输入『 chroot /chroot 』嘿嘿！你就会发现，怎么根目录 (/) 变成那个
/dev/hdb1 的环境啦！这样说明，瞭了吗？ ^_^

____________________________________________________________


make 的基本语法与变量
make 的语法可是相当的多而复杂的，有兴趣的话可以到
http://www.gnu.org/software/make/manual/html_mono/make.html 去查阅相关的说明，鸟哥这里仅列出
一些基本的规则，重点在于让读者们未来在接触原始码时，不会太紧张啊！ ^_^好了，基本的 makefile 规
则是这样的：
标的(target): 目标文件 1 目标文件 2
<tab> gcc -o 欲建立的执行文件 目标文件 1 目标文件 2
那个标的(target)就是我们想要建立的信息，而目标文件就是具有相关性的 object files ，那建立执行
文件的语法就是以 <tab> 按键开头的那一行！特别给他留意喔， 『命令列必须要以 tab 按键作为开头』
才行！ 他的规则基本上是这样的：
? 在 makefile 当中的 # 代表批注；
? <tab> 需要在命令行的第一个字符；
? 标的(target)与相依档案(就是目标文件)之间需以『:』隔开。
同样的，我们以刚刚上一个小节的范例进一步说明，如果我想要有两个以上的执行动作时， 例如下达一个
指令就直接清除掉所有的目标文件与执行文件，该如何制作呢？
# 1. 先建立编译的规则
[root@linux ~]# vi makefile
main: main.o haha.o sin_value.o cos_value.o
 gcc -o main main.o haha.o sin_value.o cos_value.o -lm
clean:
 rm -f main main.o haha.o sin_value.o cos_value.o
# 2. 测试看看：
[root@linux ~]# make clean
rm -rf main main.o haha.o sin_value.o cos_value.o
如此一来，我们的 makefile 里面就具有至少两个标的，分别是 main 与 clean ，如果我们想要建立 main
的话，输入『make main』，如果想要清除有的没的，输入『make clean』即可啊！而如果想要先清除目标
文件再编译 main 这个程序的话，就可以这样输入：『make clean main』，如下所示：
[root@linux ~]# make clean main
rm -rf main main.o haha.o sin_value.o cos_value.o
cc -c -o main.o main.c
cc -c -o haha.o haha.c
cc -c -o sin_value.o sin_value.c
cc -c -o cos_value.o cos_value.c
gcc -o main main.o haha.o sin_value.o cos_value.o -lm
这样就很清楚了吧！？但是，您是否会觉得，咦！ makefile 里面怎么重复的数据这么多啊！呵呵！没错！
所以我们可以再藉由 shell script 那时学到的『变数』来更简化 makefile 喔：
[root@linux ~]# vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
main: ${OBJS}
 gcc -o main ${OBJS} ${LIBS}
clean:
 rm -f main ${OBJS}
与 bash shell script 的语法有点不太相同，变量的基本语法为：
1. 变量与变量内容以『=』隔开，同时两边可以具有空格；
2. 变量左边不可以有 <tab> ，例如上面范例的第一行 LIBS 左边不可以是 <tab>；
3. 变量与变量内容在『=』两边不能具有『:』；
4. 在习惯上，变数最好是以『大写字母』为主；
5. 运用变量时，以 ${变量} 或 $(变量) 使用；
6. 在该 shell 的环境变量是可以被套用的，例如提到的 CFLAGS 这个变数！
7. 在指令列模式也可以给予变量。
由于 gcc 在进行编译的行为时，会主动的去读取 CFLAGS 这个环境变量，所以，您可以直接在 shell 定
义出这个环境变量，也可以在 makefile 档案里面去定义，更可以在指令列当中给予这个咚咚呢！例如：
[root@linux ~]# CFLAGS="-Wall" make clean main
# 这个动作在上 make 进行编译时，会去取用 CFLAGS 的变量内容！
也可以这样：
[root@linux ~]# vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
CFLAGS = -Wall
main: ${OBJS}
 gcc -o main ${OBJS} ${LIBS}
clean:
 rm -f main ${OBJS}
咦！我可以利用指令列进行环境变量的输入，也可以在档案内直接指定环境变量，那万一这个 CFLAGS 的
内容在指令列与 makefile 里面并不相同时，以那个方式输入的为主？呵呵！ 环境变量取用的规则是这样
的：
1. make 指令列后面加上的环境变量为优先；
2. makefile 里面指定的环境变量第二；
3. shell 原本具有的环境变量第三。
此外，还有一些特殊的变量需要了解的喔：
? $@：代表目前的标的(target)
所以我也可以将 makefile 改成：
[root@linux ~]# vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
CFLAGS = -Wall
main: ${OBJS}
 gcc -o $@ ${OBJS} ${LIBS} <==那个 $@ 就是 main ！
clean:
 rm -f main ${OBJS}
这样是否稍微了解了 makefile ( 也可能是 Makefile ) 的基本语法？这对于您未来自行修改原始码的编
译规则时，是很有帮助的喔！^_^！

____________________________________________________________


我们底下约略提一下大部分的 tarball 软件之安装的指令下达方式：
1. ./configure
这个步骤就是在建立 Makefile 这的档案啰！通常程序开发者会写一支 scripts 来检查您的
Linux 系统、相关的套件属性等等，这个步骤相当的重要， 因为未来您的安装信息都是这一步骤
内完成的！另外，这个步骤的相关信息应该要参考一下该目录下的 README 或 INSTALL 相关的档
案！！基本上，这个步骤完成之后会建立( 或修改 )一个 Makefile ，这就是参数档啦！
2. make clean
make 会读取 Makefile 中关于 clean 的工作。这个步骤不一定会有，但是希望执行一下！ 为什
么呢？因为在进行编译的时候，会产生一些 *.o 的档案，例如有个 abc.c 的原始码，经过编译
后会变成 abc.o 的档案！我们称这些档案为 object file ，这些档案如果之前已经编译过并留
下来的话，那么这次再编译的时候， 就不会编译该档案，然而由于我们可能已经修改了部分的参
数，因此该档案的编译结果事实 上应该会有所不同！因此，为了避免前一次留下来的数据可能影
响到这次编译的结果， 所以通常可以进行一下这个步骤啰！
3. make
make 会依据 Makefile 当中的预设工作进行编译的行为！编译的工作主要是进行 gcc 来将原始
码编译成为可以被执行的 object files ，但是这些 object files 通常还需要一些函式库之类
的 link 后，才能产生一个完整的执行档！使用 make 就是要将原始码编译成为可以被执行的可
执行档，而这个可执行档会放置在目前所在的目录之下， 尚未被安装到预定安装的目录中；
4. make install
通常这就是最后的安装步骤了，make 会依据 Makefile 这个档案里面关于 install 的项目，将
上一个步骤所编译完成的数据给他安装到预定的目录中， 就完成安装啦！

请注意，上面的步骤是一步一步来进行的，而 其中只要一个步骤无法成功，那么后续的步骤就完全没有办
法进行的！ 因此，要确定每一的步骤都是成功的才可以！举个 例子来说，万一今天你在 ./configure 就
不成功了，那么就表示 Makefile 无法被建立起来，要知道，后面的步骤都是根据 Makefile 来进行的，
既然无法建立 Makefile ，后续的步骤当然无法成功啰！另外，如果在 make 无法成功的话，那就表示源
文件无法被编译成可执行档，那么 make install 主要是将编译完成的档案给他安装下去的，既然都没有
成功的执行档了，怎么进行安装？ 所以啰，要每一个步骤都正确无误才能往下继续做！此外，如果安装成
功， 并且是安装在独立的一个目录中，例如 /usr/local/packages 这个目录中好了，那么您就必需手动
的将这个套件的 man page 给他放到 /etc/man.config 里面去。


____________________________________________________________


一般 Tarball 套件安装的建议事项( 如何移除？升级？ )
或许您已经发现了也说不定，那就是为什么前一个小节里面， Tarball 要在 /usr/local/src 里面解压缩
呢？呵呵！基本上，在预设的情况下，原本的 Linux distribution 释出安装的套件大多是在 /usr 里面
的，而使用者自行安装的套件则建议放置在 /usr/local 里面。这是考虑到管理使用者所安装套件的便利
性。
怎么说呢？我们晓得几乎每个套件都会提供在线说明的服务，那就是 info 与 man 的功能。在预设的情况
下， man 会去搜寻 /usr/local/man 里面的说明文件， 因此，如果我们将套件安装在 /usr/local 底下
的话，那么自然安装完成之后， 该套件的说明文件就可以被找到了。此外，如果您所管理的主机其实是由
多人共同管理的， 或者是如同学校里面，一部主机是由学生管理的，但是学生总会毕业吧？ 所以需要进
行交接，如果大家都将套件安装在 /usr/local 底下，那么管理上不就显的特别的容易吗？！
所以啰，通常我们会建议大家将自己安装的套件放置在 /usr/local 下，至于原始码( Tarball )则建议放
置在 /usr/local/src( src 为 source 的缩写 )底下啊。
再来，让我们先来看一看 Linux distribution 预设的安装套件的路径会用到哪些？我们以 apache 这个
软件来说明的话( apache 是 WWW 服务器软件，详细的数据请参考服务器架设篇。 您的系统不见得有装这
个套件 )：
? /etc/httpd
? /usr/lib
? /usr/bin
? /usr/share/man
我们会发现套件的内容大致上是摆在 etc, lib, bin, man 等目录当中，分别代表『设定档、函式库、执
行档、在线说明档』。 好了，那么你是以 tarball 来安装时呢？如果是放在预设的 /usr/local 里面，
由于 /usr/local 原本就预设这几个目录了，所以你的数据就会被放在：
? /usr/local/etc
? /usr/local/bin
? /usr/local/lib
? /usr/local/man
但是如果你每个套件都选择在这个预设的路径下安装的话， 那么所有的套件的档案都将放置在这四个目录
当中，因此，如果你都安装在这个目录下的话， 那么未来再想要升级或移除的时候，就会比较难以追查档
案的来源啰！ 而如果您在安装的时候选择的是单独的目录，例如我将 apache 安装在 /usr/local/apache
当中，那么您的档案目录就会变成：
? /usr/local/apache/etc
? /usr/local/apache/bin
? /usr/local/apache/lib
? /usr/local/apache/man
呵呵呵呵！单一套件的档案都在同一个目录之下，那么要移除该套件就简单的多了！ 只要将该目录移除即
可视为该套件已经被移除啰 ！以上面为例，我想要移除 apache 只要下达『rm -rf /usr/local/apache』
就算移除这个套件啦！当然啰，实际安装的时候还是得视该软件的 Makefile 里头的 install 信息才能知
道到底他的安装情况为何的。因为例如 sendmail 的安装就很麻烦......这个方式虽然有利于套件的移除，
但不晓得您有没有发现， 我们在执行某些指令的时候，与该指令是否在 PATH 这个环境变量所记录的路径
有关，以上面为例，我的 /usr/local/apache/bin 肯定是不在 PATH 里面的，所以执行 apache 的指令就
得要利用绝对路径了，否则就得将这个 /usr/local/apache/bin 加入 PATH 里面。另外，那个
/usr/local/apache/man 也需要加入 man page 搜寻的路径当中啊！
除此之外， Tarball 在升级的时候也是挺困扰的，怎么说呢？我们还是以 apache 来说明好了。WWW 服务
器为了考虑互动性，所以通常会将 PHP+MySQL+Apache 一起安装起来( 详细的信息请参考服务器架设篇 )，
果真如此的话，那么每个套件在安装的时候『 都有一定的顺序与程序！』因为他们三者之间具有相关性，
所以安装时必需要三者同时考虑到他们的函式库与相关的编译参数。那么如果今天我只要升级 PHP 呢？有
的时候因为只有涉及动态函式库的升级，那么我只要升级 PHP 即可！其它的部分或许影响不大。但是如果
今天 PHP 需要重新编译的模块比较多，那么可能会连带的，连 Apache 这个程序也需要重新编译过才行！
真是有点给他头痛的！没办法啦！使用 tarball 确实有他的优点啦，但是在这方面，确实也有他一定的伤
脑筋程度。
由于 Tarball 在升级与安装上面具有这些特色，亦即 Tarball 在反安装上面具有比较高的难度( 如果您
没有好好规划的话～ )，所以，为了方便 Tarball 的管理，通常我们会这样建议使用者：
1. 最好将 tarball 的原始数据解压缩到 /usr/local/src 当中；
2. 安装时，最好安装到 /usr/local 这个预设路径下；
3. 考虑未来的反安装步骤，最好可以将每个套件单独的安装在 /usr/local 底下：
例如安装 rp-pppoe-2.6.tar.gz 时，则可以指定该套件需要安装于 /usr/local/rp-pppoe 当中，
如此一来，该套件会将所有的数据都写入 /usr/local/rp-pppoe 当中，因此，未来如果要移除该
套件，只要将该目录删除即可视为成功的移除了！
4. 加上 man path
不过单独安装某个套件在某一特定路径下的作法，会导致当有 man page 的时候，使用预设的
MANPATH 会找不到相关的说明档案内容。这个时候就必须要将 man page 的路径加到
/etc/man.config 档案中了！否则使用 man 也查询不到指令的使用方法的。以上面的例子为例，
如果是安装了 /usr/local/rp-pppoe 当中，通常 man page 会放在 /usr/local/rp-pppoe/man
当中，所以，您就必需要在 /etc/man.config 里面差不多 40~50 行左右的地方，加入底下这一
行：
MANPATH /usr/local/rp-pppoe/man
这样就可以使用 man 来查询资料啰！

./configure --help | more
# 上面这个动作可以察看一下可用的参数！


____________________________________________________________

ldconfig
	目前的动态链接库的配置
	参数
		无	重新加载ld.so.conf的配置文件（新增库路径后，运行一下就好了）
		-p	显示所有当前正在用的动态链接库

动态链接库配置目录文件
	/etc/ld.so.conf
	/etc/ld.so.conf.d/

ldd	查看程序使用的相关动态库
	参数
		-v	详细信息，内容比较多
		-d	额
		-r	额

____________________________________________________________

md5sum
	用于生成文件的md5值，一般用于校验是否有变化，
	对于某些文件，比如/etc/shadow;/bin/login等内容，有可能被木马文件替换，
	可以用shell检查值是否相同后在运行，保证安全
____________________________________________________________

rpm
	Red Hat Package Management
	安装包管理工具
	无需编译，直接复制文件到目录
	优点：
		RPM有数据库记录安装内容，方便升级，卸载等操作
	缺点：
		会检查前置软件需求，如果没有，则报错不能完成安装
	urpmi/apt/yum等套件工具
		读取RPM的前置条件，自动下载安装前置软件后再自动安装这个软件

srpm
	Source RPM
	有源代码的RPM，需要编译生成RPM后再安装，可以根据本地机器信息修改配置文件后再进行安装
	具体打包安装查书吧

使用：
	软件安装
		rpm -i 包名1,包名2,...	# 没有过程显示
		rpm -ivh 包名1,包名2,...	# 可视化安装过程显示
		rpm -i http://xxx.rpm	# 直接网络安装也是可以的

		-vh 是可视化进度的标识参数

	软件升级
		rpm -Uvh 包名	# 没有就安装，有就升级
		rpm -Fvh 包名	# 没有就不装，有就升级
		
	查询安装状态
		参数：
			在查询的部分，所有的参数之前都需要加上 -q 才是所谓的查询！
			查询主要分为两部分，一个是查已安装，另一个则是查某个 rpm 档案内容。
			查询已安装套件的信息：
			-q ：仅查询，后面接的套件名称是否有安装；
			-qa ：列出所有的，已经安装在本机 Linux 系统上面的所有套件名称；
			-qi ：列出该套件的详细信息 (information)，包含开发商、版本与说明等；
			-ql ：列出该套件所有的档案与目录所在完整文件名 (list)；
			-qc ：列出该套件的所有设定档 (找出在 /etc/ 底下的檔名而已)
			-qd ：列出该套件的所有说明档 (找出与 man 有关的档案而已)
			-qR ：列出与该套件有关的相依套件所含的档案 (Required 的意思)
			-qf ：由后面接的文件名称，找出该档案属于哪一个已安装的套件；
			查询某个 RPM 档案内含有的信息：
			-qp[icdlR]：注意 -qp 后面接的所有参数以上面的说明一致。但用途仅在于找出
			 某个 RPM 档案内的信息，而非已安装的套件信息！注意！

	软件卸载
		rpm -e 报名	# 卸载软件

	重建数据库
		rpm --rebuilddb	# 当安装、卸载等操作导致rpm数据库比较乱的时候，可以运行

	不常用的参数：
		可下达的参数 代表意义
		--nodeps
		使用时机： 如果您在安装某个套件时，老是发现 rpm 告诉你『有属性相依
		的套件尚未安装』， 而您又想要直接强制安装这个套件时，可以加上
		--nodeps 告知 RPM 不要去检查套件的相依性。
		危险性： 套件会有相依性的原因是因为彼此会使用到对方的机制或功能，
		如果强制安装而不考虑套件的属性相依， 则可能会造成该套件的无法正常
		使用！
		--nomd5
		使用时机： 不想检查 RPM 档案所含的 MD5 信息时。
		说明： 还记得我们在前一章有提到的 MD5 这个指纹辨识吧？！没错，这里
		指的就是不要检查 RPM 套件的 MD5 信息。但除非您很清楚这个套件的来
		源，否则不建议使用这个参数。
		--noscripts
		使用时机： 不想让该套件自行启用或者自行执行某些系统指令。
		说明： RPM 的优点除了可以将档案放置到定位之外，还可以自动执行一些
		前置作业的指令，例如数据库的初始化。 如果您不想要让 RPM 帮您自动执
		行这一类型的指令，就加上他吧！
		--replacefiles
		使用时机： 如果在安装的过程当中出现了『某个档案已经被安装在您的系
		统上面』的信息， 又或许出现版本不合的讯息( confilcting files )时，
		可以使用这个参数来直接覆盖档案。
		危险性： 覆盖的动作是无法复原的！所以，您必须要很清楚的知道被覆盖
		的档案是真的不重要喔！否则会欲哭无泪！
		--replacepkgs 使用时机： 重新安装某个已经安装过的套件！
		--force
		使用时机： 这个参数其实就是 --replacefiles 与 --replacepkgs 的综合
		体！
		--test
		使用时机： 想要测试一下该套件是否可以被安装到使用者的 Linux 环境当
		中。范例为：
		rpm -ivh pkgname.i386.rpm --test

____________________________________________________________

		查询功能

命令格式 rpm {-q|--query} [select-options] [query-options]

　　RPM的查询功能是极为强大，是极为重要的功能之一；举几个常用的例子，更为详细的具体的，请参考#man rpm

1、对系统中已安装软件的查询

1）查询系统已安装的软件

　　语法：rpm -q 软件名

　　举例：[root@localhost beinan]# rpm -q gaim

　　gaim-1.3.0-1.fc4 　　

       查看系统中所有已经安装的包，要加 -a 参数 ；

　　[root@localhost RPMS]# rpm -qa

　　如果分页查看，再加一个管道 |和more命令；

　　[root@localhost RPMS]# rpm -qa |more

　　在所有已经安装的软件包中查找某个软件，比如说 gaim ；可以用 grep 抽取出来；

　　[root@localhost RPMS]# rpm -qa |grep gaim

　　上面这条的功能和 rpm -q gaim 输出的结果是一样的；

2）查询一个已经安装的文件属于哪个软件包

　　语法 rpm -qf 文件名

　　注：文件名所在的绝对路径要指出

　　举例：

　　[root@localhost RPMS]# rpm -qf /usr/lib/libacl.la

　　libacl-devel-2.2.23-8

3）查询已安装软件包都安装到何处

　　语法：rpm -ql 软件名 或 rpm rpmquery -ql 软件名

　　举例：

　　[root@localhost RPMS]# rpm -ql lynx

　　[root@localhost RPMS]# rpmquery -ql lynx

4）查询一个已安装软件包的信息

　　语法格式： rpm -qi 软件名

　　举例：

　　[root@localhost RPMS]# rpm -qi lynx

5）查看一下已安装软件的配置文件

　　语法格式：rpm -qc 软件名

　　举例：

　　[root@localhost RPMS]# rpm -qc lynx

6）查看一个已经安装软件的文档安装位置

　　语法格式： rpm -qd 软件名

　　举例：

　　[root@localhost RPMS]# rpm -qd lynx

7）查看一下已安装软件所依赖的软件包及文件

　　语法格式： rpm -qR 软件名

　　举例：

　　[root@localhost beinan]# rpm -qR rpm-python

　　查询已安装软件的总结：对于一个软件包已经安装，我们可以把一系列的参数组合起来用；比如 rpm -qil ；比如：

　　[root@localhost RPMS]# rpm -qil lynx

2、对于未安装的软件包的查看：

　　查看的前提是您有一个.rpm 的文件，也就是说对既有软件file.rpm的查看等；

1）查看一个软件包的用途、版本等信息；

　　语法： rpm -qpi file.rpm

　　举例：

　　[root@localhost RPMS]# rpm -qpi lynx-2.8.5-23.i386.rpm

2）查看一件软件包所包含的文件；

　　语法： rpm -qpl file.rpm

　　举例：

　　[root@localhost RPMS]# rpm -qpl lynx-2.8.5-23.i386.rpm

3）查看软件包的文档所在的位置；

　　语法： rpm -qpd file.rpm

　　举例：

　　[root@localhost RPMS]# rpm -qpd lynx-2.8.5-23.i386.rpm

4）查看一个软件包的配置文件；

　　语法： rpm -qpc file.rpm

　　举例：

　　[root@localhost RPMS]# rpm -qpc lynx-2.8.5-23.i386.rpm

5）查看一个软件包的依赖关系

　　语法： rpm -qpR file.rpm

　　举例：

　　[root@localhost archives]# rpm -qpR yumex_0.42-3.0.fc4_noarch.rpm

　　/bin/bash

　　/usr/bin/python

　　config(yumex) = 0.42-3.0.fc4

　　pygtk2

　　pygtk2-libglade

　　rpmlib(CompressedFileNames) <= 3.0.4-1

　　rpmlib(PayloadFilesHavePrefix) <= 4.0-1

　　usermode

　　yum >= 2.3.2

____________________________________________________________

srpm一个打包自己套件的范例
	这个就有趣了！我们自己来编辑一下自己制作的 RPM 怎么样？会很难吗？完全不会！ 这里简单的以一个
	小例子来说明喔！请注意，这个真的只是一个小例子，所以不要觉得奇怪喔！ 其中，比较需要注意的，由
	于在上面的步骤说明中，我们知道在将 SRPM 编译成为 RPM 的时候，会以 tar 这支程序来将档案解开，因
	此，我们在进行来源档案的建立时， 就必需要将他打包成为一个 tar.gz 的 tarball 的档案才行！
	假设我们编辑了一支 script，内容是这样：
	[root@linux ~]# cd /usr/src/redhat/SOURCES
	[root@linux SOURCES]# vi showvbird.sh
	#!/bin/bash
	# This file is just used to demo the RPM packaging.
	# the only thing is showing the hostname.
	HOST=`/bin/hostname`
	/bin/echo $HOST
	# 先随便建立一个 shell script ，这个是自己的套件的意思啦！
	[root@linux SOURCES]# chmod 755 showvbird.sh
	[root@linux SOURCES]# tar -zcvf showvbird.tar.gz showvbird.sh
	# 注意喔！务必打包才行啊！
	上面的动作中，我们编辑了一个 shell script 档案，档名为 showvbird.sh，并且将他打包成为具有 gzip
	压缩的 tarball 档案，也就是 showvbird.tar.gz 这样的档案才行！请注意，这个 showvbird.tar.gz 档
	案『必需』放置在 SOURCES 目录之下！
	再来则是要编辑那个很重要的 *.spec 档案啰！你可以这样简单的编写一下：
	[root@linux SOURCE]# cd /usr/src/redhat/SPECS
	[root@linux SPECS]# vi showvbird.spec
	Summary: This is a demo RPM package.
	Name: showvbird
	Version: 1.0
	Release: 1
	License: GPL
	Group: VBird's Home
	Source: showvbird.tar.gz <==记得喔！这里写的是刚刚建立的 tarball
	Url: http://linux.vbird.org
	Packager: VBird
	%description
	This package is just a demo RPM.
	%prep
	%setup -c
	%install
	install -m 755 showvbird.sh /usr/local/bin/showvbird.sh
	%files
	/usr/local/bin/showvbird.sh
	好了！开始给他编译并打包成为 RPM 档案啦！
	[root@linux SPECS]# rpmbuild -bb showvbird.spec
	.....中间省略......
	Requires: /bin/bash
	Checking for unpackaged file(s): /usr/lib/rpm/check-files %{buildroot}
	Wrote: /usr/src/redhat/RPMS/i386/showvbird-1.0-1.i386.rpm
	最后这个被打包成功的档案就被放置在 /usr/src/redhat/RPMS/i386/showvbird-1.0-1.i386.rpm 啰！然
	后给他安装一下：
	[root@linux SPECS]# rpm -ivh ../RPMS/i386/showvbird-1.0-1.i386. rpm
	Preparing... ########################################### [100%]
	 1:showvbird ########################################### [100%]
	[root@linux SPECS]# rpm -qi showvbird
	Name : showvbird Relocations: (not relocatable)
	Version : 1.0 Vendor: (none)
	Release : 1 Build Date: Mon Oct 3 11:08:30 2005
	Install Date: Mon Oct 3 11:11:30 2005 Build Host: linux.site. tw
	Group : VBird's Home Source RPM: showvbird-1.0-1.src.rpm
	Size : 143 License: GPL
	Signature : (none)
	Packager : VBird
	URL : http://linux.vbird.org
	Summary : This is a demo RPM package.
	Description :
	This package is just a demo RPM.
	[root@linux SPECS]# which showvbird.sh
	/usr/local/bin/showvbird.sh
	[root@linux SPECS]# rpm -ql showvbird
	/usr/local/bin/showvbird.sh <==果然记录起来了！自己的软件呢！
	用很简单的方式，就可以将自己的软件或者程序给他修改与设定妥当！很不错吧！ 以后您就可以自行设定
	你的 RPM 啰！当然，也可以手动修改您的 SRPM 的来源档内容啰！


____________________________________________________________


linux开机流程
	1. BIOS
	2. MBR (boot loader)
	3. kernel loading
	4. init program
	5. initial script (/etc/rc.d/rc.sysinit)
	6. daemon start (/etc/rc.d/rc[0-6].d/*)
	7. local setting (/etc/rc.d/rc.local)

____________________________________________________________

chkconfig
	设定开机服务
	[root@linux ~]# chkconfig --list
	[root@linux ~]# chkconfig [--add|--del] [service_name]
	[root@linux ~]# chkconfig --level [0123456] [service_name] [on| off]
	参数：
	--list ：仅将目前的各项服务状态列出来
	--add ：增加一个服务名称给 chkconfig 来管理，该 service_name 必须在
	 /etc/init.d/ 内！
	--del ：删除一个给 chkconfig 管理的服务
	--level：设定某个服务在该 level 下启动 (on) 或关闭 (off)
	范例：
	范例一：列出目前系统上面所有被 chkconfig 管理的服务
	[root@linux ~]# chkconfig --list |more
	NetworkManager 0:off 1:off 2:off 3:off 4:off 5:off  6:off
	.....中间省略.....
	snmpd 0:off 1:off 2:off 3:off 4:off 5:off  6:off
	yum 0:off 1:off 2:off 3:off 4:off 5:off  6:off
	xinetd based services:
	 chargen: off
	.....中间省略.....
	 telnet: off
	# 这个 chkconfig 的输出主要分为两大部分，分别是 stand alone 的服务，
	# 他会分出 0~6 个 run level 的资料，亦即上半部的显示，至于下半部则是
	# super daemon 管理的服务的输出情况！由 super daemon 管理的服务，
	# 是没有 run level 之分的喔！
	范例二：显示出目前在 run level 3 为启动的服务
	[root@linux ~]# chkconfig --list | grep '3:on'
	范例三：让 atd 这个服务在 run level 为 3, 4, 5 时启动：
	[root@linux ~]# chkconfig --level 345 atd on

服务文件需要在/etc/init.d/中
自己写的
op_service:
	#!/bin/bash
	#chkconfig:35 65 30
	#description:op游戏服务
	#目录:/etc/init.d
	#需要可运行权限x
	#查看是否生效:chkconfig --list op_service
	#删除启动项:chkconfig --del op_service
	#新增启动项:chkconfig --add op_service
	#停止服务的话，还是应该用先关服务器程序后关机，这个脚本并不能保证数据保存完毕才关机
	# 基本上，比较重要的是第二行，他的语法是：
	# chkconfig: [runlevels] [start number] [stop number]
	# 其中， runlevels 为不同的 run level 状态， start number 与
	# stop number 则是在 /etc/rc.d/rc[35].d 内建立以 S80myvbird

	STOPTIMEOUT=60

	start(){
		cd /home/uj
		cd login
		./op_login > /dev/null &
		cd ../login_out
		./opout_login > /dev/null &
		cd ../charge_restart
		./op_restart_CHARGE > /dev/null &
		cd ../restart
		./op_restart > /dev/null &
		cd ../cache
		./op_cache > /dev/null &
	}

	stop(){
		opid=$(ps aux | grep op_server | awk '{if($11!="grep"){print $2;}}')
		killall op_server
		if [[ $opid -gt 0 ]]; then
			$TIMEOUT=$STOPTIMEOUT
			while [ $TIMEOUT -gt 0 ]; do
				/bin/kill -0 $opid >/dev/null 2>&1 || break
				sleep 1
				let TIMEOUT=${TIMEOUT}-1
			done
			if [ $TIMEOUT -eq 0 ]; then
				echo "stop op_server pid:$opid failed."
			else
				echo "stop op_server pid:$opid succeed."
			fi
		fi
	}

	# See how we were called.
	case "$1" in
	  start)
	    start
	    ;;
	  stop)
	    stop
	    ;;
	  *)
	    echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
	    exit 2
	esac

	exit $?

____________________________________________________________

ntsysv
	同chkconfig,是一个图形化的界面，
	但是只有redhat系列的发行版才有

	# 此时，你可以使用底下的按键来进行选择：
	# 上下键： 可以在中间的方框当中，在各个服务之间移动；
	# 空格键： 可以用来选择你所需要的服务，前面的 [*] 会有 * 出现；
	# tab 键： 可以在方框、OK、Cancel 之间移动；
	# [F1]键： 可以显示该服务的说明。举例来说，移动到 myvbird 按下 F1 后
____________________________________________________________

两个最常用的,因为系统发生的错误或者是警告讯息通常都会写入这些档案中
/var/log/messages
/var/log/secure


解决系统的错误：
	这个对于系统管理员来说是很重要的信息，例如：开机的过程当中侦测到的硬件讯息数据会记录
	到内存当中， 由于这些侦测的信息可以提供我们了解硬件信息，所以如果你的系统发生问题时，
	可以下达 dmesg 看看硬件的侦测有没有发生错误呢！另外，如果系统资源被耗尽、 核心活动发
	生错误等等事件发生的时候，则系统登录文件亦会将错误的讯息记录在登录文件中 (通常是
	/var/log/messages )，这些都可以藉以取得错误发生时的信息，并加以克服问题！！
解决网络服务的问题：
	在安装或设定新服务的套件时，最常使用到这个功能了！例如在安装启动 sendmail 时，如果
	sendmail 无法提供服务的时候，那么无法提供服务的问题则会被纪录到登录文件当中去， 则只
	要分析登录档就可以了解问题点，并藉以解决问题啦！( 所以我们常说『天助自助者』是真的啦！
	察看(1)屏幕上面的错误讯息与(2)登录文件的错误信息，几乎可以解决大部分的 Linux 问题！ )
记录登录信息：
	这个东西相当的重要！例如：有天您的 apache 这个 WWW 服务挂了，你怎么知道何时挂掉的？ 而
	最后登入者是谁？！这都可以藉由分析 apache 的登录文件来取得信息； 此外，万一有一天您的
	系统被入侵，并且被利用来攻击他人的主机，这个时候对方的主机查出是您的 Linux 在进行攻击
	的行为，这个时候你要如何告知对方您的主机是由于被入侵所导致的问题， 并且协助对方继续往
	来源追查呢？！呵呵！此时登录档可是相当重要的呢！

/var/log/secure：
	记录登入系统存取数据的档案，例如 pop3, ssh, telnet, ftp 等都会记录在此档案中；
/var/log/wtmp：
	记录登入者的讯息数据，由于本档案已经被编码过，所以必须使用 last 这个指令来取出档案的内容；
/var/log/messages：
	这个档案相当的重要，几乎系统发生的错误讯息（或者是重要的信息）都会记录在这个档案中；
/var/log/boot.log：
	记录开机或者是一些服务启动的时候，所显示的启动或关闭讯息；
/var/log/maillog 或 /var/log/mail/*：
	纪录邮件存取或往来( sendmail 与 pop3 )的使用者记录；
/var/log/cron：
	这个是用来记录 crontab 这个例行性服务的内容的！
/var/log/httpd, /var/log/news, /var/log/mysqld.log, /var/log/samba,/var/log/procmail.log：
	分别是几个不同的网络服务的记录文件啦！

____________________________________________________________

logrotate
	日志档案管理，配置文件/etc/logrotate.conf
	负责将日志文件分段保存，旧日志删除等

	# 基本上，在 logrotate.conf 档案当中，只有这个数据是在记载如何对登录文件进行轮替的！
	# 这个登录文件记载的就是使用 login 登入系统时的使用者状态，还记得那个 last 指令吧？
	# 就是读自 /var/log/wtmp 当中记录的数据啦！整个段落的意义是：
	# 1. 每个月进行一次 log rotate 的工作；
	# 2. 将档案的权限设定为 664 ，且拥有者为 root ，群组为 utmp；
	# 3. 仅保存前一个月的 rotate 备份！
	# 这也是为什么我们说 last 只会秀出这个月的数据而已的原因～因为一个月轮替一次嘛！
	# 这个 rotate 可以改大一点，例如 5 以保存五个月，以利追踪
____________________________________________________________

查看日志的命令：
	dmesg	开机过程日志查看
	last	登陆日志	参数：-n 显示个数 -f 手动选择日志文件，如：last -5 -f /var/log/wtmp-20150528 
	lastlog	显示每个帐号的最近登录时间
____________________________________________________________

tar的多个目录操作
	例子
		tar --exclude 文件1 --exclude 文件2 -cvjf xxx.tar.bz2
____________________________________________________________

iostat
	查看机器的io状态
	参数：
		-c ：仅显示 CPU 的状态；
		-d ：仅显示储存设备的状态，不可与 -c 一起用；
		-k ：预设显示的是 block ，这里可以改成 K bytes 的大小来显示；
		-t ：显示日期出来；

	# 瞧！上面数据总共分为上下两部分，上半部显示的是 CPU 的当下信息；
	# 下面数据则是显示储存装置 /dev/hda, /dev/hdb 的相关数据，他的数据意义：
	# tps ：平均每秒钟的传送次数！与数据传输『次数』有关，非容量！
	# kB_read/s ：开机到现在平均的读取单位；
	# kB_wrtn/s ：开机到现在平均的写入单位；
	# kB_read ：开机到现在，总共读出来的档案单位；
	# kB_wrtn ：开机到现在，总共写入的档案单位；

	每两秒钟侦测一次，并且共侦测三次储存装置
	iostat -d 2 3


____________________________________________________________

网络基本概念
	MAC
		Media Access Control
		只能在同一个局域网内传输
		查看
			ifconfig中的HWaddr

	ARP
		Address Resolution Protocol
		用于生成ip与mac的对应关系表，先广播获取对应关系后存如表中，
		用于后续查询的的优化
		查看
			arp -n

	IP
		Internet Protocol
		由NET_ID和HOST_ID两部分组成
		同一局域网内，所有主机的NET_ID相同，HOST_ID唯一
		HOST_ID
			不能全为0或全为1
		NET_ID
			分段
				网段	特征	范围				NET_MASK
				A类	0开头	0.xxx.xxx.xxx-126.xxx.xxx.xxx	255.0.0.0
				B类	10开头	128.xxx.xxx.xxx-191.xxx.xxx.xxx	255.255.0.0
				C类	110开头	192.xxx.xxx.xxx-223.xxx.xxx.xxx	255.255.255.0
				内部		127.xxx.xxx.xxx			255.0.0.0

			NET_MASK
				子网切分用
				CSMA/CD广播效能的提升用，减少子网内HOST_ID的数量来提升网络效率

			NETWORK
				HOST_ID全部为0
				子网的第一个ip

			BROADCAST
				HOST_ID全部为1
				子网的最后一个ip

			网域的表示方法
				Network/Netmask
				192.168.0.0/255.255.255.0
				192.168.0.0/24
				细分子网的例子:
					标识方法1		标识方法2			范围
					192.168.0.0/25		192.168.0.0/192.168.0.128	192.168.0.0-192.168.0.127
					192.168.0.128/25	192.168.0.128/192.168.0.128	192.168.0.128-192.168.0.255
		公有IP
			可以连接公网的IP
		私有IP
			不能连公网，局域网IP
			保留网段
				A类	10.0.0.0-10.255.255.255
				B类	172.16.0.0-172.31.255.255
				C类	192.168.0.0-192.168.255.255
		IP封包表头内容
			Version	4bits
				版本
				标识IPV4、IPV6等
			IHL	4bits
				Internet Header Length
				IP表头的长度
			Type of Service	8bits
				服务类型MTU相关的内容
			Total Length	16bits
				IP封包总长度，最大65535Bytes
			
			Identification	16bits
				IP封包重组时，判断是否是同一个IP封包的识别码
			Flags	3bits
				0DM
				D为0标识可以分段，1标识不可分段
				M为0标识最后分段，1标识非最后分段
			Fragment Offset	13bits
				分段偏移序号
				封包重组时判断位置，排序组合用
			
			Time To Live	8bits
				TTL
				IP封包的存活时间
				每通过一个路由器TTL减一，TTL为0时封包丢弃
			Protocol Number	8bits
				协议类型
				1:ICMP(Internet Control Message Protocol);4:IP;17:UDP
			Header Checksum	16bits
				IP表头错误检验用

			Source Address	32bits
				来源IP地址
			
			Destination Address	32bits
				目标IP地址
			
			Options	19bits?
				额外功能，安全处理机制、路由记录、时间戳记录、严格宽松来源路由等
			Padding	13bits?
				补齐为32bits用，因为Options长度不定
	
	网域
		NET_ID相同的网段即为同一网域
	
	Gateway/Router
		网关/路由的功能就是负责不同网域之间的封包传递(IP Forwarder)
		主机与主机的Gateway必定是同一个网域内

	封包
		TCP完整封包=MAC封包
		MAC封包=MAC包头+IP封包
		IP封包=IP包头+TCP封包
		TCP封包=TCP包头+数据

	TCP封包包头
		Source Port & Destination Port	16bits & 16bits
			来源端口 & 目标端口
			通过目标和来源的一对IP和端口才能建立连接

		Sequence Number 32bits
			包分段序号，重新组合封包用

		Acknowledge Number 32bits
			回应序号
			对方收到信息后的回应，客户端收到这个值标识目标已经收到这个包了

		Data Offset 4bits
			资料补偿
			标识封包区段的起始位置
		Reserved 6bits
			未使用，保留
		Code 6bits
			Control Flag控制标识码
			标识这个封包的状态
			URG(Urgent)	是否为紧急包
			ACK(Acknowledge)	是否为相应封包
			PSH(Push function)	是否立即发送数据，而不是等待缓冲区满后处理
			RST(Reset)	是否马上结束连接
			SYN(Synchronous)	是否主动建立连接
			FIN(Finish)	表示传送结束
		Window 16bits
			标识缓冲区的剩余尺寸，单位byte

		Checksum 16bits
			确认检查码
			判断封包是否完整，不是的话就要求对方重新发送封包
		Urgent Pointer 16bits
			紧急资料
			URG=1才生效，可以告知紧急数据所在位置

		Options 16bits
			任意资料
			标识可以接收的最大数据量，一般不用
		Padding 16bits
			补足字段
			补齐32bits用
			
	一组可以连上Internet的必要参数
		IP
		Netmask
		Network
		Broadcast
		Gateway
		DNS

____________________________________________________________

LAN
	Local Area Network
	局域网络
	同一网域内所有连接设备网络的概念

WAN
	Wide Area Network
	广域网络

Node
	节点
	每个具有网卡的设备都是一个节点，TTL存活时间与经过的节点有关



____________________________________________________________


route
	显示、设置本机的路由表
	参数
		n	不以主机名称，而直接已数字的形式显示目标和路由的内容
			numberic
	
	destination	目标地址，就是目标的network
	gateway	gateway的地址，0.0.0.0表示不需要
	genmask	就是netmask，和destination组成目标的网域
	flags	U标识该路由可用；G标识标识该路由需要经Gateway传递；H标识该路由为一个主机而不是一整个网域
	Iface	就是interface接口的意思
	
	如果要与一个地址通信，则查路由表内的dest+genmask是否和目标地址一致，一直则有gateway就通过gateway，没有的话就通过Iface来通信


____________________________________________________________

只有root才能启用1023以下的端口
____________________________________________________________

ICMP
	Internet Control Message Protocol
	是一个侦错与回报的机制
	ping,traceroute等功能的消息内容
____________________________________________________________

MTU
	Maximum Transmission Unit
	最大传输单元
	标准为1500，实际可能小一些，因为有各种表头
	部分gigabit网卡支持Jumbo Frame的可以设置为9000，
	但是因为要与外部传输，所以需要取最小值才行
____________________________________________________________

安装驱动的流程(网卡)
	1. 解压缩与编译：
		下载tarball
		解压
		[root@linux ~]# cd /usr/src
		[root@linux src]# ln -s kernels/2.6.9-34.0.1.EL-smp-i686/ linux
		[root@linux src]# cd ~

	2. 模块之测试与处理
		查看readme
		如果有install.sh
			./install.sh
		否则
			[root@linux ~]# ls -l
			drwxr-xr-x 2 root root 4096 Jul 20 11:57 sk98lin
			[root@linux ~]# ls -l sk98lin
			-rw-r--r-- 1 root root 2666344 Jul 20 11:57 sk98lin.ko
			# 上面那个目录假设是我编译出来的模块，里面还会有一个档案喔！那个档案就是
			# sk98lin.ko ，要注意，新的 2.6 版的核心模块扩展名都变成 .ko 的格式了！
			[root@linux ~]# cp -a sk98lin /lib/modules/`uname -r`/kernel/drivers/net
			# 注意啊！整个网络卡驱动模块就是放在上面的目录中，不要写错了。
			[root@linux ~]# depmod -a
			# 将所有的模块进行重新分析的工作！建立关连档案
			[root@linux ~]# lsmod | grep 'sk98lin'
			# 先确认『sk98lin』这个模块不存在，然后就可以开始测试：
			[root@linux ~]# modprobe sk98lin
			[root@linux ~]# lsmod | grep 'sk98lin'
			# 如果有相关的字样跑出来时，就表示这个模块可以顺利的被加载啦！

	3. 设定开机自动启动网络卡模块
		我们前面提到， Linux 的网络卡其实仅是一个代号，并不是类似硬盘的装置档案，所以， 我们必
		须要指定这个代号与模块的对应才行，在 CentOS (Red Hat 系统) 的对应是使用
		/etc/modprobe.conf ，至于旧版的 2.4 核心中，则使用的是 /etc/modules.conf ，注意一下您的核
		心版本。 鸟哥的 CentOS 4.3 使用的是 /etc/modprobe.conf ，所以我就得这么做：
			[root@linux ~]# vi /etc/modprobe.conf
			# 修改或增加底下这一行吧！
			alias eth0 sk98lin
			[root@linux ~]# sync; reboot
		为了测试一下刚刚的设定是否会生效，通常鸟哥都会尝试一次重新开机， 然后开机完成之后观察
		一下是否有正确的启动网络卡，并观察一下模块加载的情况， 如果一切都顺利，那就太完美了！

	4. 尝试设定 IP
		等到一切就绪之后，总得试看看这样的网络卡模块是否可以顺利的设定好 IP 吧？ 所以我们先手
		动给他一个私有 IP 看看先：
			[root@linux ~]# ifconfig eth0 192.168.1.100
			[root@linux ~]# ifconfig
			eth0 Link encap:Ethernet HWaddr 00:01:BA:77:16:52
			 inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
			.....以下省略.....
		嘿嘿！真的设定妥当哩！然后利用 ping 这个指令去 ping 一下网域内的其它计算机， 看看能不
		能有响应，就知道您的网络卡是否 OK 的啦！通常是没有问题的啦！

____________________________________________________________

网络相关设定档案

	/etc/sysconfig/network
		是否启用网络
		主机名
			NETWORKING=yes
			HOSTNAME=localhost.localdomain

	/etc/sysconfig/network-scrips/ifcfg-eth0
		网络参数设定
			静态的：
				DEVICE="eth0"
				BOOTPROTO="static"
				HWADDR="00:0C:29:B2:6F:A0"
				IPV6INIT="no"
				NM_CONTROLLED="yes"
				ONBOOT="yes"
				TYPE="Ethernet"
				UUID="78eaa9a4-31de-4d90-bbed-d99709199e8f"
				IPADDR="192.168.1.200"
				NETMASK="255.255.255.0"
				GATEWAY="192.168.1.1"
				DNS1=202.96.199.132
				DNS2=202.96.199.133
				NETWORK=192.168.1.0
			动态的：
				DEVICE=eth0
				ONBOOT=yes
				BOOTPROTO=dhcp
	
	/etc/modprobe.conf
		驱动程序设定(新版本已经是目录了)

	/etc/resolv.conf
		这个是根据/etc/sysconfig/network-scrips/ifcfg-eth0生成的，不要手动改
			# Generated by NetworkManager
			nameserver 202.96.199.132
			nameserver 202.96.199.133

	/etc/hosts
		host的配置啦！
			127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
			::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
		这个档案可以记录计算机的 IP 对应主机的名称或者主机的别名！特别留意的是， 在局域网络内
		有些服务需要反查 Client 的身份，此时就会动用到主机名称对应 IP 的数据。 但是因为局域网
		络内使用私有保留 IP ，当然无法进行 Hostname 对应 IP 的行为， 这个时候该服务就会呆呆的
		等待 30~60 秒～如果可以避过这个反查，或者是直接告诉主机 Hostname 与 IP 的对应，那么就
		可以节省这个反查的时间了！所以，如此一来省去反查的时间，就可以改善 LAN 内的联机速度
		了！这个 hosts 就是用来设定 Hostname 对应 IP 的啦！ 更多的信息请查阅后续服务器章节 DNS
		服务器的介绍。
	
	/etc/services
		这个档案则是记录架构在 TCP/IP 上面的总总协议，包括 http, ftp, ssh, telnet 等等服务所定义的
		port number ，都是这个档案所规划出来的。如果您想要自订一个新的协议与 port 的对应，就得
		要改这个档案了；

	/etc/protocols
		这个档案则是在定义出 IP 封包协议的相关数据，包括 ICMP/TCP/UDP 这方面的封包协议的定义等。

____________________________________________________________

常用的指令
	/etc/init.d/network restart
	service network restart
		重启网络，重新加载所有网络配置参数
	
	ifup eth0
	ifdown eth0
	ifconfig eth0 up
	ifconfig eth0 down
		启用、关闭eth0的网卡
____________________________________________________________

nslookup
	根据域名查询对应的ip地址
	例
		nslookup baidu.com
		Server:		202.96.199.133
		Address:	202.96.199.133#53

		Non-authoritative answer:
		Name:	baidu.com
		Address: 123.125.114.144
		Name:	baidu.com
		Address: 180.149.132.47
		Name:	baidu.com
		Address: 220.181.57.217
		Name:	baidu.com
		Address: 111.13.101.208

iwconfig
	无线网络设置信息
	类似与ifconfig

iwlist
	搜索附近的无线AP
	例
		iwlist eth1 scanning
		iwconfig eth1 essid "BLW-VBIRD" key "12345678901234567890123456"
		iwconfig eth1
			eth1 802.11b/g NIC ESSID:"BLW-VBIRD"
			 Mode:Managed Frequency=2.437GHz Access Point: 00:90:CC:D6:A4:1C
			 Bit Rate:11Mb/s
			 Retry:off RTS thr=2432 B Fragment thr:off
			 Encryption key:****-****-****-****-****-****-** Security mode:open
			 Power Management:off
		修改速度上限Bit Rate
		vi ifcfg-eth1
		DEVICE=eth1
		BOOTPROTO=dhcp
		ONBOOT=no
		TYPE=wireless
		ESSID=BLW-VBIRD
		MODE=Managed
		RATE=54M <== 可以严格指定传输的速率，要与上面 iwconfig 相同，单位 b/s
		KEY=12345678901234567890123456

____________________________________________________________

DHCP
	Dynamic Host Configuration Protocol
	动态调整主机的网络配置参数

AP
	Wireless Access Point
	无线基地

ESSID/SSID
	AP的名字
____________________________________________________________

内部网域使用某些联机服务(如 FTP, POP3)所遇到的联机延迟问题
您或许曾经听过这样的问题：『 我在我的虚拟网域内有几部计算机， 这几部计算机明明都是在同一个网域
之内，而且系统通通没有问题，为什么我使用 pop3 或者是 ftp 连上我的 Linux 主机会停顿好久才连上？
』
由于网络在联机时，两部主机之间会互相询问对方的主机名称，以确认对方的身份。 在目前的因特网上面，
我们大多使用 Domain Name System (DNS) 系统做为主机名称与 IP 对应的查询，那就是我们在上面提到
的 /etc/resolv.conf 档案内设定的 IP 由来， 如果没有指定正确的 DNS IP 的话，那么我们就无法查询到主
机名称与 IP 的对应了。
公开的因特网可以这样设定，但是如果是我们内部网域的私有 IP 主机呢？ 因为是私有 IP 的主机，所以
当然无法使用 /etc/resolv.conf 的设定来查询到这部主机的名称啊！ 那怎么办？要知道， 如果两部主机之间
无法查询到正确的主机名称与 IP 的对应， 那么将『可能』发生持续查询主机名称对应的动作，这个动作
一般需要持续 30-60 秒，因此，您的该次联机将会持续检查主机名  30 秒钟，也就会造成奇怪的 delay 的
情况。
这个问题最常发生在内部的 LAN ，例如使用 192.168.10.1 的主机联机到 192.168.10.2 的主机。 这个问
题虽然可以透过修改软件的设定来略过主机名称的检查，但是绝大多数的软件都是预设启用这个机制的，
因此，内部主机『 老是联机时期很慢，联机成功后速度就会恢复正常』 时，通常就是这个问题啦！尤其是
在 FTP 及 POP3 等网络联机软件上最常见。
那么如何避过这个情况？最简单的方法就是『 给予内部的主机每部主机一个名称与 IP 的对应』即可。举
例来说，我们知道每部主机都有一个主机名称为  localhost ，对应到 127.0.0.1 ，为什么呢？因为这个
127.0.0.1 与 localhost 的对应就被写到 /etc/hosts 内嘛！ 当我们需要主机名称与 IP 的对应时，系统就会
先到 /etc/hosts 找寻对应的设定值， 如果找不到，才会使用 /etc/resolv.conf 的设定去因特网找。这样说，
您明白了吧？ 也就是说，只要修改了 /etc/hosts，加入每部主机与 IP 的对应， 就能够避过主机名称的检
查啰！
了解了吗？所以说，您就要将您的 私有 IP 的计算机与计算机名称写入您的 /etc/hosts 当中了！好了！那
么这个咚咚的内容如何呢？ 我们来看一看原本的设定内容吧！
[root@linux ~]# cat /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1 localhost.localdomain localhost
# 主机的 IP 主机的名称 主机的别名
在上面的情况中很容易就发现了设定的方法了吧！很简单吧！没错！那就是 IP 对应主机名称啦！ 那么现
在知道为什么我们给他 ping localhost 的时候，地址会写出 127.0.0.1 了吧！ 那就是写在这个档案中的啦！
而且 localhost 那一行不能拿掉呦！ 否则系统的某些服务可能就会无法被启 动！好了！那么将我局域网络
内的所有的计算机 IP 都给他写进去！并且，每一部给他取一个您喜欢的名字， 即使与 client 的计算机名
称设定不同也没关系啦！ 以鸟哥为例，如果我还额外加设了  DHCP 的时候，那么我就干脆将所有的 C
Class 的所有网段全部给他写入 /etc/hosts 当中，有点像底下这样：
[root@linux ~]# vi /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1 localhost.localdomain localhost
192.168.1.1 linux001
192.168.1.2 linux002
192.168.1.3 linux003
.........
.........
192.168.1.255 linux255
如此一来，不论我哪一部计算机连上来，不论是在同一个网段的哪一个 IP ， 我都可以很快速的追查到！
嘿嘿！那么区内网络互连的时候，就不会多等个好几时秒钟啰!
____________________________________________________________

网址列无法解析问题
很多朋友常问的一个问题『 咦！我可以拨接上网了，也可以 ping 到奇摩雅虎的 IP ，但为何就是无法直接
以网址连上 Internet 呢！ 』嘿！被气死！ 前面不是一直强调那个 DNS 解析的问题吗？对啦！就是名称解
析不对啦！赶快改一下 /etc/resolv.conf 这个档案吧！改成上层 ISP 给您的 DNS 主机的 IP 就可以啦！例
如 Hinet 的 168.95.1.1 及 Seednet 的 139.175.10.20 啰！例如底下的范例(这个范例就可以照抄了！  ^_^)：
[root@linux ~]# vi /etc/resolv.conf
nameserver 168.95.1.1
nameserver 139.175.10.20
朋友们常常会在这个地方写错，因为很多书上都说这里要设定成为 NAT 主机的 IP ， 那根本就是不对的！
您应该要将所有管理的计算机内，关于 DNS 的设定都直接使用上面的设定值即可！ 除非您的上层环境有
使用防火墙，那才另外考虑！
____________________________________________________________

预设路由的问题
记得我们在前两章提到的网络基础当中，不是讲了很多预设路由 (default gateway) 相关的说明吗？ 预设路
由通常仅有一个，用来做为同一网域的其它主机传递非本网域的封包网关。 但我们也知道在每个网络设定
档案 (/etc/sysconfig/network-scripts/ifcfg-ethx) 内部都可以指定『  GATEWAY 』这个参数，若这个参数重复
设定的话，那可就麻烦啦！
举例来说，您的 ifcfg-eth0 用来做为内部网域的沟通，所以您在该档案内设定 GATEWAY 为您自己的 IP ，
但是该主机为使用 ADSL 拨接，所以当拨接成功后会产生一个 ppp0 的接口，这个 ppp0 接口也有自己的
default gateway ，好了，那么当你要将封包传送到 Yahoo 这个非为本网域的主机时， 这个封包是要传到
eth0 还是 ppp0 呢？因为两个都有 default gateway 啊！
没错！很多朋友就是这里搞不懂啦！常常会错乱～所以，请注意， 您的 default gateway 应该只能有一个，
如果是拨接，请不要在 ifcfg-eth0 当中指定 GATEWAY或 GATEWAYDEV 等变量，重要重要！
____________________________________________________________

RootKit Hunter 后端侦测软件之架设与执行
最近更新日期：2004/11/16
由前面几个章节的说明，我们可以晓得因为主机的某些服务是有漏洞的， 黑客们可以针对这些服务的漏洞
来撰写恶意攻击的程序，并据以取得该被攻击主机的超级管理员  root 权限。 这些恶意攻击程序后来被散
布在因特网上面，因此，很多小朋友很容易就取得这些恶意程序， 并利用这些程序来攻击不特定的众多主
机。这种入侵的程序我们可以称之 Root Kit (Root 工具)。 万一您的系统被 root kit 之类的程序所攻击，
由于这些程序通常会在您的系统留下一些后门或者是蠕虫， 因此，我们可以透过分析系统来找出这类的程
序，这样才能进一步移除恶意程序， 让您的主机保持干干净净啊！底下我们将介绍一套自由软件 RootKit
Hunter ， 这套软件可以分析您主机上的可能被恶意程序所攻击的档案，让您可以检查主机是否被入侵喔！
前言
 ： 什么是 Root Kit
 ： 如何防止 rootkit 的攻击
 ： Rootkit Hunter 能作什么
 ： rkhunter 例外的错误状态
安装 rkhunter
检测系统
系统修订
前言：
我们知道，要取得一部主机的所有权限，那就是需要取得该部主机的超级管理员 root 的权限！ 所以一般
黑客都会想尽办法去取得 root 的权限的。那么该如何取得 root 的权限呢？ 最简单的方法就是利用网络
上流传的 Root Kit 工具程序来进行入侵的动作了。
由于 Root Kit 工具的取得相当的容易，因此难保我们一般使用者的主机不会被低级的怪客所干扰， 所以
我们当然要想办法保护我们自己的主机啦！为了要侦测主机是否已经被 Root Kit 之类的程序所攻击， 由
自由软件撰写团体所开发的 Root Kit Hunter, rkhunter 这个套件，就能够帮我们侦测啰！ 所以，底下
我们就来谈一谈这个咚咚。
什么是 Root Kit
要取得一部主机的控制权，有相当多的方法！最简单的当然就是以登入程序(如 login, ssh, telnet 等等)
加上猜测密码的程序来尝试进行登入的行为。不过，由于登入程序大部分都有登入次数的限制， 因此使用
密码猜测程序就不这么流行了。
高级的黑客为了系统网络的安全，会撰写一些程序去测试自己主机的服务漏洞， 并且在发现了某些服务的
漏洞之后，会通报该服务的维护团体，或者是贡献自己的修补方式， 以补足自己系统的安全性。而服务开
发/维护团体在接到这样的通报之后，会在最短的时间内进行程序修改， 并且在因特网上面进行通报与释
出该漏洞的修补程序。
然而在这个漏洞通报出来之后，与修补程序释出之前的空窗期，某些恶意的 cracker 就会针对这样的漏洞
进行攻击， 这些 cracker 同样是撰写程序来攻击该漏洞，同时取得被攻击主机的控制权，或者是植入木
马程序在受攻击的主机上。 这些 cracker 与高级黑客不同的地方，在于他们会很骄傲的将攻击的成果贴
在一些 cracker 常上的网站， 藉以推销自己，同时，也会将他们撰写的恶意程序散播到 Internet 上面。
有些有心人士就会将这些恶意程序收集起来，做成程序包，并使这些程序包更加流行于 Internet 上面， 这
些恶意的程序包就被称为 root kit 咯。
RootKit 能作的攻击真是林林总总的说不完！最常见的就是直接以 rootkit 刺探被攻击主机的服务漏洞，
如果被攻击主机『刚好』有此漏洞，那么该主机的控制权就可能会被 Cracker 所取得。另外， 若该主机
被取得控制权之后，为方便 cracker 未来做为跳板之用，因此他可能会利用其它的 rootkit 将被攻击主
机的某些程序换掉，举例来说，我们晓得观察主机的一些信息可以用 ps, ls, top, w 等等的程序，cracker
为了保障自己的入侵不会被真正的系统管理员得知，就会将这些程序换掉， 让原本的系统管理员无法知道
目前系统正在跑的程序里面，是否有一些不明的程序存在。
如何防止 rootkit 的攻击
知道了这些 Rootkit 工具包之后，那么我们如何杜绝 cracker 使用 rootkit 程序包来攻击我们的主机
呢？ 由于 rootkit 主要是藉由主机的漏洞来攻击的，因此， 您必须要确定『不必要的服务请务必关闭』，
此外『随时更新主机上面各套件的修补程序』。 关闭不必要的服务应该很简单，这里鸟哥就不谈了。至于
更新套件的修补程序， 最好藉助于 apt 或者 yum 或者您的 Linux distribution 提供的在线更新方式来
维护， 这样对于系统管理员来说，会比较轻松。
这样还不够喔！因为 rootkit 也很可能会伪装成 Internet 上面合法的软件， 来吸引您安装他。例如前
几年，著名的 OpenSSL 网站上所提供的套件竟然被发现已经被 cracker 置换掉～ 所以，在您安装取得的
套件之前，请先以 MD5 或者其它指纹数据进行档案的比对， 以确定该档案是没有问题的。当然，最好还
是不要安装来路不明的套件较好。
而为了确认一下我们的主机是否被 rootkit 程序包所攻击， 其实我们还可以透过其它的软件工具来检查
主机的某些重要程序，例如前面提到的 ps, top 等等的。 这就是我们这篇文章要提到的 rootkit hunter
啰。
Root Kit Hunter 能作什么？
在官方的数据当中，RKHunter 可以作的事情包括：侦测 rootkit 程序、侦测后门程序、以及主机端的套
件检查问题。 rkhunter 所使用的侦测技术包括了底下几种：
? 利用 MD5 指纹分析：
记得我们在 基础学习篇 里面有提到那个 MD5 的东西吧？简单的来说，每个档案都有自己的指纹
数据，这个指纹数据是利用杂凑演算的方式来得到一组 MD5 编码，当这个档案被更动过，那怕是
只改了一个字符，而整个档案的容量大小不变， 他的 MD5 编码还是会不同的。因此，若我们在
系统安装完毕之后，立即建立重要档案的 MD5 数据库， 然后再以分析工具定期去分析该重要档
案的 MD5 编码，若有不同，则显示该档案被变动过， 此时自然就需要了解了解为何会被更动了。
利用这个特性， rkhunter 在释出的时候，就已经收集了各大知名的 Linux distributions 的重
要档案的 MD5 编码(例如 login, ls, ps, top, w 等等档案)， 并制作成数据库，然后，当我们
安装好了 rkhunter 并且执行之后， 他就会利用原本数据库的数据去与我们系统的相关档案进行
比对， 若比对的结果有问题，则会显示警示文字，提供系统管理员分析。
? 检查 rootkit 经常攻击的档案：
如同前面所说的，rootkit 为了伪装自己或者是为了取得系统控制权，他们会主动的去变更某些
重要档案。 因此，藉由分析这些档案，我们可以很轻易的就知道该档案有没有被窜改过！ 这也
是 rootkit 很重要的一个分析的方法！
? 检查是否具有错误的档案权限--针对 binary files：
在 基础学习篇 里面的 原始码与 tarball 我们有谈到系统里头真正会执行的其实是经过编译的
二进制档案(binary files)，因此， 如果木马程序想要掌握您的系统，那么窜改的那些重要档案
自然也就是 binary file 啰， 例如 ls, ps, top 等等的。而重点是，系统原本的这些档案本来
都具有比较严谨的档案权限， 例如 /bin/ls 具有的是 -rwxr-xr-x 的 755 权限。不过，很多的
木马程序窜改之后的档案权限可能都会变成 -rwxrwxrwx 的 777 权限，因此，直接分析这些重要
档案的权限，也可以判断该档案是否有问题。
? 检查隐藏档案：
有的时候我们为了要让屏幕的显示数据较为干净，可能会将一些档案隐藏起来， 在 Linux 底下
的隐藏档案，其实只是在档名最前面加上一个小数点『.』而已。 木马程序也可能透过这个一般
朋友们比较不容易注意的隐藏档来隐藏他们的主程序， 因此，rkhunter 也会分析某些不法的隐
藏档，以期找出有问题的档案。
? 检查可疑的核心模块(LKM/KLD)：
在 基础学习篇 里面提到的 核心功能 当中， 可以知道 Linux 的核心功能具有可外挂的特性，
也就是 Loadable Kernel Module, LKM 。 而我们也晓得，系统能作什么是由核心来决定的。因
此，恶意程序当然有可能藉由加载核心模块来作怪！ 所以啰，rkhunter 也会分析可疑的核心模
块。(在 Linux 上面， 我们称核心模块为 LKM，不过，在 BSD 系列的系统上面，他们称为 Dynamic
Kernel Linker, KLD。)
? 操作系统的特殊检测：
每一种操作系统(Operating System)都有他特殊的档案格式，例如 Linux 底下，我们可以使用 ps
来检查 /proc 这个内存目录底下的东西是否一致！？不过，也因为每个操作系统都不相同， 所
以这个功能并无法在所有的操作系统上面进行测试的。无论如何， Linux 是有被支援的喔！
? 检查已启动的监听埠号：
如果要产生网络联机，则在 Server 端需要启动监听的埠号(listening port)， 这样才能监听来
自 Client 端的要求啊！这也是所谓的『后门』(backdoor)程序最常用的方法。 我们知道，要启
动一个 port 来监听，就必须要执行某个程序才行( 基础篇之认识系统服务 ) 如果我们的系统被
木马程序入侵，就很有可能被执行一支程序来启动某项不知名的服务， 而该服务会启动一些
port ，藉由这些 port 就可以让 cracker 轻易的联机到我们的主机。 因此， rkhunter 也会分
析主机上面的 LISTENING Ports 来解析是否有问题啊～
? 特定分析(String scanner)：
某些特定的木马程序或后门程序，他会在系统上面建立一特殊的档案或者是目录， 这些特殊的档
案或目录的文件名是不变的。 所以，rkhunter 会藉由分析这些特定的档案或目录是否在您的系
统上面， 以用来判断您的系统是否有被入侵呢？
除了这些方法之外，在新版的 rkhunter 当中，也加入了针对某些常用套件的版本分析。 举例来说， Apache
这个套件在 2.0.49 以前的版本已经被发现很多的臭虫， 因此，一般管理者都会建议大家将系统当中的
Apache 升级到 2.0.50 以后的版本( 截至 2004/11 )。 又例如常见的 SSH/SSL 版本也都有类似的问题。
rkhunter 可以分析您系统上面的这些运作当中的套件， 然后告诉您，您的该套件版本是否可能有问题？？
但也仅只是『可能』有问题～ 咦！干嘛多了个『可能』啊？呵呵！因为 rkhunter 并不是万能的！底下我
们来谈一谈， rkhunter 可能有哪些误判的嫌疑？
rkhunter 例外的错误状态
rkhunter 虽然是很棒的一项工具，但是他的输出结果还是有一小部分的问题。举例来说， 在利用 MD5 编
码比对方面，因为 rkhunter 是利用他本身的 MD5 编码数据库与您的系统相关档案进行比对， 但是难保
您的系统刚好不在 rkhunter 支持的范围之内，如此，则 rkhunter 会判断该档案『有问题！』 此外，如
果您是利用 tarball 的方式自行安装类似 syslogd, ps 等档案，由于下达的参数不同， 所以您的这些档
案肯定与 rkhunter 的 MD5 数据库不同，此时当然也会被判定是『有问题』的状态。 在这种可预期的情
况下，您可以更新 rkhunter 的数据库，也可以与作者联络来克服此一问题。
除此之外，新版的 rkhunter 有提供套件版本的检测，如同上一小节提到的。 但是，各主要 distribution
在发现套件的臭虫后，通常并不是释出最新版的套件， 而是在原有的版本上面透过 patch 来除去该臭虫
程序，而并不变更版本。 此时，单纯的检测版本是无法知道该版本有没有经过 patch 的！因此， 如果您
的套件版本是已经经过 patch ，但版本却是旧的，此时 rkhunter 的版本检测就会出现错误判断了。
因为如此，所以 rkhunter 在使用上面还是有限制的。如果您想要针对某些服务进行更详细的检测， 那就
必须要使用更复杂的程序，例如 nessus 啰！未来我们会再谈到 nessus 的安装与使用方面。
安装 rkhunter：
安装 rkhunter 其实真的很简单！首先，您必须前往下载网页进行下载，下载点：
? rkhunter 下载点：  http://www.rootkit.nl/projects/rootkit_hunter.html
在该网页的最下方有个 downloads ，请选择最新版本来下载。鸟哥这里以 1.1.8 版进行说明， 您也可以
在 鸟哥的网站上下载 。 假设下载下来的档案放置在 /root 里面，那么整个安装步骤就成为这样(注：您
必须要有 bash shell 喔！)
[root@test root]# cd /usr/local/src
[root@test src]# tar -zxvf /root/rkhunter-1.1.8.tar.gz
# 此时会产生一个名为 rkhunter 的目录！
[root@test src]# cd rkhunter/
[root@test rkhunter]# ./installer.sh
# 此时会产生一新目录 /usr/local/rkhunter
# 该目录内含有一些本系统的重要数据，例如 md5 编码的数据等等。
# 另外，检测程序会放置在 /usr/local/bin/rkhunter 喔！
这样就安装完毕了！很简单吧！此时我们就可以开始以 /usr/local/bin/rkhunter 这支程序来检测系统了。
检测系统：
系统的检测很简单，因为只要执行 rkhunter 就够了！与 rkhunter 相关的参数有：
[root@test root]# /usr/local/bin/rkhunter --help
# 底下仅列出几个比较常用的参数，更多参数请自行参考！
--checkall (-c) :全系统检测，rkhunter 的所有检测项目
--createlogfile :建立登录档，一般预设放在 /var/log/rkhunter.log
--cronjob :可以使用 crontab 来执行，不会有颜色显示
--report-warnings-only :仅列出警告讯息，正常讯息不列出！
--skip-application-check :忽略套件版本检测(如果您已确定系统的套件已 patch)
--skip-keypress :忽略按键后继续的举动(程序会持续自动执行)
--quiet :仅显示有问题的讯息，比 --report-warnings-only 更少讯息
--versioncheck :检测试否有新的版本在服务器上
那么如何开始检测？呵呵！就直接按下 /usr/local/bin/rkhunter --checkall 即可！例如：
[root@test root]# /usr/local/bin/rkhunter --checkall
Rootkit Hunter 1.1.8 is running
Determining OS... Ready
# 第一部份，先进行 binary 的检测，包括 MD5 的检测喔！
Checking binaries
* Selftests
 Strings (command) [ OK ]
* System tools
 Performing 'known good' check...
 /sbin/ifconfig [ OK ]
....(略)....
 /sbin/runlevel [ OK ]
[Press to continue] 这里按下 Enter 才能继续！
# 在第一部份的检测当中，主要的工作就是在检验一些系统重要的 binary files，
# 这些档案就是常被 root kit 程序包攻击的范围！所以首先就得要检测他们啊！
# 接下来进行第二部分的检测！
Check rootkits
* Default files and directories
 Rootkit '55808 Trojan - Variant A'... [ OK ]
 ADM Worm... [ OK ]
....(略)....
 Rootkit 'zaRwT.KiT Rootkit'... [ OK ]
* Suspicious files and malware
 Scanning for known rootkit strings [ OK ]
....(略)....
 Sniffer logs [ OK ]
[Press to continue] 这里按下 Enter 才能继续！
# 第二部分就是在检测常见的 rootkit 程序包所造成的系统伤害！
# 这部分的检测当然就是针对各个常见的 rootkit 攻击的档案/目录来侦测啰！
# 接下来是第三部分的检测！
* Trojan specific characteristics
 shv4
 Checking /etc/rc.d/rc.sysinit
 Test 1 [ Clean ]
....(略)....
 Checking /etc/xinetd.conf [ Clean ]
* Suspicious file properties
 chmod properties
 Checking /bin/ps [ Clean ]
....(略)....
 Checking /bin/login [ Clean ]
* OS dependant tests
 Linux
 Checking loaded kernel modules... [ OK ]
 Checking files attributes [ OK ]
 Checking LKM module path [ OK ]
Networking
* Check: frequently used backdoors
 Port 2001: Scalper Rootkit [ OK ]
 Port 60922: zaRwT.KiT [ OK ]
* Interfaces
 Scanning for promiscuous interfaces [ OK ]
[Press to continue] 这里按下 Enter 才能继续！
# 第三部分在检测木马以及可疑的档案属性！反正就是针对木马程序来进行检测～
# 当然，因为木马程序可能会开后门，所以网络服务(port)也在这里检测！
# 同时还包含核心模块等等的检测喔！再来则是第四部分
System checks
* Allround tests
 Checking hostname... Found. Hostname is test.vbird.tw
 Checking for passwordless user accounts... OK
 Checking for differences in user accounts... [ NA ]
 Checking for differences in user groups... Creating file It seems
 this is your first time.
 Checking boot.local/rc.local file...
 - /etc/rc.local [ OK ]
 - /etc/rc.d/rc.local [ OK ]
 - /usr/local/etc/rc.local [ Not found ]
....(略)....
* Filesystem checks
 Checking /dev for suspicious files... [ OK ]
 Scanning for hidden files... [ OK ]
[Press to continue] 这里按下 Enter 才能继续！
# 第四部分主要在进行系统开机与相关服务的检测！所以您可以看到
# rc.local 与 password/accounts 的检测都会在这里进行检查～
# 此外，在 /dev 里面也会检查是否有被影响的档案喔！接下来是第五部分
Application advisories
* Application scan
 Checking Apache2 modules ... [ Not found ]
 Checking Apache configuration ... [ OK ]
* Application version scan
 - GnuPG 1.2.1 [ Vulnerable ]
 - Bind DNS [unknown] [ OK ]
 - OpenSSL 0.9.7a [ Vulnerable ]
 - Procmail MTA 3.22 [ OK ]
 - OpenSSH 3.7.1p2 [ Unknown ]
Security advisories
* Check: Groups and Accounts
 Searching for /etc/passwd... [ Found ]
 Checking users with UID '0' (root)... [ OK ]
* Check: SSH
 Searching for sshd_config...
 Found /etc/ssh/sshd_config
 Checking for allowed root login... [ OK (Remote root login disabled) ]
 Checking for allowed protocols... [ OK (Only SSH2 allowed) ]
* Check: Events and Logging
 Search for syslog configuration... [ OK ]
 Checking for running syslog slave... [ OK ]
 Checking for logging to remote system... [ OK (no remote logging) ]
[Press to continue] 这里按下 Enter 才能继续！
# 第五部分在检查一些常见的服务的套件版本！
# 因为仅检查版本信息而已，并没有针对可能的漏洞去攻击，
# 所以，这里的信息有可能是 误判的 不要怀疑！以上面的检测为例，
# 我的 OpenSSL 0.9.7a 是已经经过官方 patch 的版本，也就是说，
# 他已经封住漏洞了，但是这里却显示有问题！原因就是这样啦！
---------------------------- Scan results ----------------------------
MD5
MD5 compared: 51
Incorrect MD5 checksums: 0
File scan
Scanned files: 328
Possible infected files: 0
Application scan
Vulnerable applications: 2
Scanning took 114 seconds
-----------------------------------------------------------------------
# 最后这里是作一个输出的总结！我们可以在这里看到
# 最终的简单数据，透过这个数据，可以了解系统目前的状态！
在终端机使用 rkhunter 来检测最棒的地方，在于有颜色的显示，以上表来看， 在括号[]内的字样，如果
是黄色的 OK 表示没有问题，如果是红色的！哈哈！那就表示有点问题了！ (在本书上以及网页上的友善
打印中，因为打印的问题，所以可能会看不到颜色显示， 很抱歉～没办法～)所以，如果您有看到红色显
示的字眼时， 务必特别留意喔！
另外，如果您不想要每个部分都以 Enter 来继续，想要让程序自动持续执行，可以使用：
/usr/local/bin/rkhunter --checkall --skip-keypress
这样就会让程序直接执行到结束喔！另外，如果想要让程序每日自动执行一次，那就在 /etc/crontab 里
面加入这行：
10 3 * * * root /usr/local/bin/rkhunter --checkall --cronjob
以后就会在 3:10 自动执行一次！不过，因为是 crontab 执行的，所以就不会有颜色的显示了。
系统修订：
如果您的系统经过 rkhunter 的检测之后，却发现很多的『红字』时，该怎么办？很简单， 可以参考这个
网页提供的方法：
http://www.rootkit.nl/articles/rootkit_hunter_faq.html
基本上，官方网站与一般网管老手的建议都一样，如果被 rootkit 之类的程序包攻击后 ( 也就是上一节
的检测表中的第二部分所攻击时 )，那么最好最好直接重新安装系统， 不要存在说可以移除 rootkit 或
者木马程序的幻想，因为，『隐藏』本来就是 rootkit 与木马程序的拿手好戏！ 我们不知道到底这个
rootkit 或者木马程序有多剽悍，为了保险起见，还是重灌系统吧！如何重灌？简单的说：
1. 将原主机的网络线拔除；
2. 备份您的数据，最好备份成两部分，一部份是全部的系统内容，越详尽越好，包括 binary files
与 logfile 等等， 至于另一部份则可以考虑仅备份重要的数据文件即可！
3. 将上个步骤的数据备份(仅重要数据部分！)进行整体的检查，察看是否有怪异的数据存在(这部分
可能会花去不少时间！)
4. 重新安装一部完整的系统，这包括：
o 仅安装需要的套件在服务器上面；
o 先进行 简单的防火墙 设定后才进行联机；
o 以 APT/YUM 之类的工具进行在线更新；
o 执行类似 rkhunter/nessus 之类的软件，检验系统是否处在较为安全的状态
5. 将原本的重要数据移动至上个步骤安装好的系统当中，并启动原本服务器上面的各项服务；
6. 以 rkhunter/nessus 之类的软件检验系统是否处在较为安全的环境，并且加强防火墙的机制！
7. 最后，将原本完整备份的数据拿出来进行分析，尤其是 logfile 部分，试图找出 cracker 是藉
由那个服务？那个时间点？ 以那个远程 IP 联机进入本机等等的信息，并针对该信息研拟预防的
方法，并应用在已经运作的机器上。
这样一来，比较能够保证我们的主机系统可以较为安全一些。至于上头提到的 nessus 软件，我们会在未
来几个章节介绍到！
而如果 rkhunter 显示的讯息里面，错误并非是 rootkit 或者木马程序所造成的时候，那么很可能是因为
使用者设定上的问题， 或者是系统管理员变动过某些套件所致。举例来说：
? rootkit 显示有怪异的文件名称(strings file)，例如 /dev/.thefile 之类的档案/目录存在，
那么首先，您必须要先确定该档案/目录并非是由于 rootkit 所造成的(一般来说，如果 rkhunter
没有在 rootkit 检验部分列出该档案时，几乎就都是这一类的 strings file 啰)， 果真如此，
那么就移除该档案吧(确定移除没有问题喔！若不确定，就备份再移除吧～)
? 在 MD5 检验时，发现有 binary file 显示错误！最可能发生此问题的情况，其实不是被入侵，
而是系统自动更新套件所致。 鸟哥曾在 Red Hat 9 上面更新过 syslogd 这支程序，没想到
rkhunter 一直显示该档案有问题～ 后来才发现，原来是 syslogd 更新在 rkhunter 之后，而
rkhunter 又没有更新 MD5 编码的数据库， 所以才导致出错的问题。
那如何解决呢？首先，可以透过更新 rkhunter 的数据库来取得最新的信息，如何在线更新？利
用：
[root@test root]# rkhunter --update
Running updater...
Mirrorfile /usr/local/rkhunter/lib/rkhunter/db/mirrors.dat rotated
Using mirror http://www.rootkit.nl/rkhunter
[DB] Mirror file : Update available
 Action: Database updated (current version: 2004081200, new version 2004110700)
[DB] MD5 hashes system binaries : Update available
 Action: Database updated (current version: 2004091000, new version 2004110900)
[DB] Operating System information : Update available
 Action: Database updated (current version: 2004091100, new version 2004110901)
[DB] MD5 blacklisted tools/binaries : Up to date
[DB] Known good program versions : Update available
 Action: Database updated (current version: 2004091000, new version 2004110500)
[DB] Known bad program versions : Update available
 Action: Database updated (current version: 2004091000, new version 2004110500)
如上所述，我可以将 1.1.8 版本的相关信息 update 到最新的 2004/11/09 所释出的版本！然后
再去比对一次 MD5 。 如果这个方法还是无法解决您的问题，就只好请您发信询问 rkhunter 的
作者了。
其它的问题解决之道，就请参考上面提供的连结吧！ ^_^y 另外，如果您想要让您的 rkhunter 保持在最
新的版本， 利用：
rkhunter --versioncheck
就能够知道目前作者释出的最新版本的 rkhunter 啰！很简单吧！
____________________________________________________________

Linux 常用网络指令介绍

	1. 网络参数设定指令：
	 1.1 ifconfig, ifup, ifdown
	 1.2 route
	 1.3 ip
	 1.4 iwlist, iwconfig
	 1.5 dhclient
	2. 网络侦错与观察指令
	 2.1 ping： 用 ping 追踪最大 MTU 数值
	 2.2 traceroute
	 2.3 netstat
	 2.4 host
	 2.5 nslookup
	3. 远程联机指令
	 3.1 telnet
	 3.2 ftp
	 3.3 lftp
	 3.4 gaim：图形接口的实时通讯软件
	4. 文字接口网页浏览
	 4.1 lynx
	 4.2 wget
	5. 封包撷取功能
	 5.1 tcpdump
	 5.2 ethereal
	 5.3 nc, netcat

	ifconfig：查询、设定网络卡与 IP 网域等相关参数；
	ifup, ifdown：这两个档案是 script ，透过更简单的方式来启动网络接口；
	route：查询、设定路由表 (route table)
	ip：复合式的指令，可以直接修改上述提到的功能；

	ifconfig
		ifconfig 主要是可以手动的启动、观察与修改网络接口的相关参数，可以修改的参数很多啊， 包括 IP 参
		数以及 MTU 等等都可以修改，他的语法如下：
		[root@linux ~]# ifconfig {interface} {up|down} <== 观察与启动接口
		[root@linux ~]# ifconfig interface {options} <== 设定与修改接口
		参数：
		interface：网络卡接口代号，包括 eth0, eth1, ppp0 等等
		options ：可以接的参数，包括如下：
		 up, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)
		 mtu ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)
		 netmask ：就是子屏蔽网络；
		 broadcast：就是广播地址啊！
		范例：
		范例一：观察所有的网络接口(直接输入 ifconfig)
		[root@linux ~]# ifconfig
		eth0 Link encap:Ethernet HWaddr 00:0F:EA:A3:06:A2
		 inet addr:192.168.10.100 Bcast:192.168.10.255 Mask: 255.255.255.0
		 inet6 addr: fe80::20f:eaff:fe73:682/64 Scope:Link
		 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
		 RX packets:3439 errors:0 dropped:0 overruns:0 frame:0
		 TX packets:2735 errors:0 dropped:0 overruns:0 carrier:0
		 collisions:0 txqueuelen:1000
		 RX bytes:646935 (631.7 KiB) TX bytes:562313 (549.1 KiB)
		 Interrupt:209 Memory:fb000000-0
		一般来说，直接输入 ifconfig 就会列出目前已经被启动的卡， 不论这个卡是否有给予 IP ，都会被显示
		出来。而如果是输入 ifconfig eth0 ， 则会秀出这张接口的相关数据，而不管该接口是否有启动。所以
		如果您想要知道某张网络卡的 Hardware Address，直接输入『 ifconfig "网络接口代号" 』即可喔！ ^_^！
		至于上表出现的各项数据是这样的(数据排列由上而下、由左而右)：
		? eth0：就是网络卡的代号，也有 lo 这个 loopback ；
		? HWaddr：就是网络卡的硬件地址，俗称的 MAC 是也；
		? inet addr：IPv4 的 IP 地址，后续的 Bcase, Mask 分别代表的是 Broadcast 与 netmask 喔！
		? inet6 addr：是 IPv6 的版本的 IP ，我们没有使用，所以略过；
		? MTU：就是 MTU 啊！
		? RX：那一行代表的是网络由启动到目前为止的封包接收情况， packets 代表封包数、errors 代
		表封包发生错误的数量、 dropped 代表封包由于有问题而遭丢弃的数量等等
		? TX：与 RX 相反，为网络由启动到目前为止的传送情况；
		? collisions：代表封包碰撞的情况，如果发生太多次， 表示您的网络状况不太好；
		? txqueuelen：代表用来传输数据的缓冲区的储存长度；
		? RX bytes, TX bytes：总传送、接收的字节总量
		? Interrupt, Memory：网络卡硬件的数据， IRQ 岔断与内存地址；
		透过观察上述的资料，大致上可以了解到您的网络情况，尤其是那个 RX, TX 内的 error 数量， 以及是
		否发生严重的 collision 情况，都是需要注意的喔！ ^_^
		范例二：暂时修改网络接口
		[root@linux ~]# ifconfig eth0 192.168.100.100
		# 如果不加任何其它参数，则系统会依照该 IP 所在的 class 范围，
		# 自动的计算出 netmask 以及 network, broadcast 等 IP 参数；
		[root@linux ~]# ifconfig eth0 192.168.100.100 netmask 255.255.255.128 \
		> mtu 8000
		# 设定网络接口，同时设定 MTU 的数值！
		[root@linux ~]# ifconfig eth0 mtu 9000
		# 仅修改该接口的 MTU 数值，其它的保持不动！
		[root@linux ~]# ifconfig eth0:0 192.168.50.50
		# 仔细看那个界面， eth0:0 喔！那就是在该网络接口上，再仿真一个网络接口，
		# 亦即是在一张网络卡上面设定多个 IP 的意思啦！
		[root@linux ~]# ifconfig
		eth0 Link encap:Ethernet HWaddr 00:0F:EA:A3:06:A2
		 inet addr:192.168.10.100 Bcast:192.168.10.255 Mask: 255.255.255.0
		 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
		 RX packets:3669 errors:0 dropped:0 overruns:0 frame:0
		 TX packets:2892 errors:0 dropped:0 overruns:0 carrier:0
		 collisions:0 txqueuelen:1000
		 RX bytes:667547 (651.9 KiB) TX bytes:584799 (571.0 KiB)
		 Interrupt:209 Memory:fb000000-0
		eth0:0 Link encap:Ethernet HWaddr 00:0F:EA:A3:06:A2
		 inet addr:192.168.200.2 Bcast:192.168.200.255 Mask: 255.255.255.0
		 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
		 Interrupt:209 Memory:fb000000-0
		# 仔细看，是否与硬件有关的信息都相同啊！没错！因为是同一张网卡嘛！
		[root@linux ~]# ifconfig eth0:0 down
		# 关掉 eth0:0 这个界面。如果想要启动 eth1 ，并且不给予任何网络参数，
		# ifconfig eth1 up 就可以达到了！
		[root@linux ~]# /etc/init.d/network restart
		# 刚刚设定的数据全部失效，会以 ifcfg-ethx 的设定为主！
		呵呵！使用 ifconfig 可以暂时手动来设定或修改某个适配卡的相关功能， 并且也可以透过 eth0:0 这种
		虚拟的网络接口来设定好一张网络卡上面的多个 IP 喔！ 手动的方式真是简单啊！并且设定错误也不打紧，
		因为我们可以利用 /etc/init.d/network restart 来重新启动整个网络接口，那么之前手动的设定数据会
		全部都失效喔！另外， 要启动某个网络接口，但又不让他具有 IP 参数时，直接给他 ifconfig eth0 up 即
		可！ 这个动作经常在无线网卡当中会进行， 因为我们必须要启动无线网卡让他去侦测 AP 存在与否啊！

	ifup, ifdown
		实时的手动修改一些网络接口参数，可以利用 ifconfig 来达成，如果是要直接以设定档， 亦即是在
		/etc/sysconfig/network-scripts 里面的 ifcfg-ethx 等档案的设定参数来启动的话， 那就得要透过
		ifdown 或 ifup 来达成了。
		[root@linux ~]# ifup {interface}
		[root@linux ~]# ifdown {interface}
		[root@linux ~]# ifup eth0
		ifup 与 ifdown 真是太简单了！这两支程序其实是 script 而已，他会直接到
		/etc/sysconfig/network-scripts 目录下搜寻对应的设定档，例如 ifup eth0 时，他会找出 ifcfg-eth0
		这个档案的内容，然后来加以设定。 关于 ifcfg-eth0 的设定则请参考前一章连上 Internet 的说明。
		不过，由于这两支程序主要是搜寻设定文件 (ifcfg-ethx) 来进行启动与关闭的， 所以在使用前请确定
		ifcfg-ethx 是否真的存在于正确的目录内，否则会启动失败喔！ 另外，如果以 ifconfig eth0 .... 来
		设定或者是修改了网络接口后， 那就无法再以 ifdown eth0 的方式来关闭了！因为 ifdown 会分析比对
		目前的网络参数与 ifcfg-eth0 是否相符，不符的话，就会放弃该次动作。因此，使用 ifconfig 修改完
		毕后，应该要以 ifconfig eth0 down 才能够关闭该接口喔！

	route
		我们在网络基础的时候谈过关于路由的问题， 两部主机之间一定要有路由才能够互通 TCP/IP 的协议，否
		则就无法进行联机啊！ 一般来说，只要有网络接口，该接口就会产生一个路由，例如在鸟哥实验室内部的
		主机有一个 eth0 及 lo ， 所以：
		[root@linux ~]# route [-nee]
		[root@linux ~]# route add [-net|-host] [网域或主机] netmask [mask] [gw|dev]
		[root@linux ~]# route del [-net|-host] [网域或主机] netmask [mask] [gw|dev]
		观察的参数：
		 -n ：不要使用通讯协议或主机名称，直接使用 IP 或 port number；
		 -ee ：使用更详细的信息来显示
		增加 (add) 与删除 (del) 路由的相关参数：
		 -net ：表示后面接的路由为一个网域；
		 -host ：表示后面接的为连接到单部主机的路由；
		 netmask ：与网域有关，可以设定 netmask 决定网域的大小；
		 gw ：gateway 的简写，后续接的是 IP 的数值喔，与 dev 不同；
		 dev ：如果只是要指定由那一块网络卡联机出去，则使用这个设定，后面接 eth0 等
		范例一：单纯的观察路由状态
		[root@linux ~]# route -n
		Kernel IP routing table
		Destination Gateway Genmask Flags Metric Ref Use Iface
		192.168.10.0 0.0.0.0 255.255.255.0 U 0 0  0 eth0
		169.254.0.0 0.0.0.0 255.255.0.0 U 0 0  0 eth0
		0.0.0.0 192.168.10.30 0.0.0.0 UG 0 0  0 eth0
		[root@linux ~]# route
		Kernel IP routing table
		Destination Gateway Genmask Flags Metric Ref Use Iface
		192.168.10.0 * 255.255.255.0 U 0 0  0 eth0
		169.254.0.0 * 255.255.0.0 U 0 0  0 eth0
		default server.cluster 0.0.0.0 UG 0 0  0 eth0
		由上面的例子当中仔细观察 route 与 route -n 的输出结果，你可以发现有加 -n 参数的主要是显示出
		IP ，至于使用 route 而已的话，显示的则是『主机名称』喔！ 也就是说，在预设的情况下， route 会
		去找出该 IP 的主机名称，如果找不到呢？ 就会显示的钝钝的(有点小慢)，所以说，鸟哥通常都直接使用
		route -n 啦！ 由上面看起来，我们也知道 default = 0.0.0.0/0.0.0.0 ， 而上面的信息有哪些你必须
		要知道的呢？
		? Destination, Genmask：这两个玩意儿就是分别是 network 与 netmask 啦！所以这两个咚咚就
		组合成为一个完整的网域啰！
		? Gateway：该网域是通过那个 gateway 连接出去的？ 如果显示 0.0.0.0 表示该路由是直接由本
		机传送，亦即可以透过局域网络的 MAC 直接传讯； 如果有显示 IP 的话，表示该路由需要经过
		路由器 (通讯闸) 的帮忙才能够传送出去。
		? Flags：总共有多个旗标，代表的意义如下：
		o U (route is up)：该路由是启动的；
		o H (target is a host)：目标是一部主机 (IP) 而非网域；
		o G (use gateway)：需要透过外部的主机 (gateway) 来转递封包；
		o R (reinstate route for dynamic routing)：使用动态路由时，恢复路由信息的旗标；
		o D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能设定
		为动态路由
		o M (modified from routing daemon or redirect)：路由已经被修改了；
		o ! (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！)
		? Iface：这个路由传递封包的接口。
		此外，观察一下上面的路由排列顺序喔，依序是由小网域 (192.168.10.0/24 是 Class C)，逐渐到大网域
		(169.254.0.0/16 Class B) 最后则是预设路由 (0.0.0.0/0.0.0.0)。 然后当我们要判断某个网络封包应
		该如何传送的时候，该封包会经由这个路由的过程来判断喔！ 举例来说，我上头仅有三个路由，若我有一
		个传往 192.168.10.20 的封包要传递，那首先会找 192.168.10.0/24 这个网域的路由，找到了！所以直
		接由 eth0 传送出去；
		如果是传送到 Yahoo 的主机呢？ Yahoo 的主机 IP 是 202.43.195.52，我通过判断 1)不是
		192.168.10.0/24， 2)不是 169.254.0.0/16 结果到达 3)0/0 时，OK！传出去了，透过 eth0 将封包传给
		192.168.10.30 那部 gateway 主机啊！所以说，路由是有顺序的。
		因此当你重复设定多个同样的路由时， 例如在你的主机上的两张网络卡设定为相同网域的 IP 时，会出现
		什么情况？会出现如下的情况：
		Kernel IP routing table
		Destination Gateway Genmask Flags Metric Ref Use Iface
		192.168.10.0 0.0.0.0 255.255.255.0 U 0 0  0 eth0
		192.168.10.0 0.0.0.0 255.255.255.0 U 0 0  0 eth1
		也就是说，由于路由是依照顺序来排列与传送的， 所以不论封包是由那个界面 (eth0, eth1) 所接收，都
		会由上述的 eth0 传送出去， 所以，在一部主机上面设定两个相同网域的 IP 本身没有什么意义！有点多
		此一举就是了。 除非是类似虚拟主机 (Xen, VMware 等软件) 所架设的多主机时，才会有这个必要～
		范例二：路由的增加与删除
		[root@linux ~]# route del -net 169.254.0.0 netmask 255.255.0.0 dev eth0
		# 上面这个动作可以删除掉 169.254.0.0/16 这个网域！
		# 请注意，在删除的时候，需要将路由表上面出现的信息都写入
		# 包括 netmask , dev 等等参数喔！注意注意
		[root@linux ~]# route add -net 192.168.100.0 \
		> netmask 255.255.255.0 dev eth0
		# 透过 route add 来增加一个路由！请注意，这个路由必须要能够与你互通。
		# 举例来说，如果我下达底下的指令就会显示错误：
		# route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.200.254
		# 因为我的环境内仅有 192.168.10.100 这个 IP ，所以不能与 192.168.200.254
		# 这个网段直接使用 MAC 互通！这样说，可以理解喔！？
		[root@linux ~]# route add default gw 192.168.10.30
		# 增加预设路由的方法！请注意，只要有一个预设路由就够了喔！
		# 在这个地方如果您随便设定后，记得使用底下的指令重新设定你的网络
		# /etc/init.d/network restart
		如果是要进行路由的删除与增加，那就得要参考上面的例子了， 其实，使用 man route 里面的数据就很
		丰富了！仔细查阅一下啰！ 你只要记得，当出现『SIOCADDRT: Network is unreachable』 这个错误时，
		肯定是由于 gw 后面接的 IP 无法直接与您的网域沟通 (Gateway 并不在你的网域内)， 所以，赶紧检查
		一下是否输入错误啊！加油吧！

	ip
		ip 是个指令喔！并不是那个 TCP/IP 的 IP 啦！这个 ip 指令的功能可多了！ 基本上，他就是整合了
		ifconfig 与 route 这两个指令啰～不过， ip 可以达成的功能却又多更多！ 真是个相当厉害的指令。如
		果您有兴趣的话，请自行 vi /sbin/ifup ，就知道整个 ifup 就是利用 ip 这个指令来达成的。好了，如
		何使用呢？让我们来瞧一瞧先！
		[root@linux ~]# ip [option] [动作] [指令]
		参数：
		option ：设定的参数，主要有：
		 -s ：显示出该装置的统计数据(statistics)，例如总接受封包数等；
		动作：亦即是可以针对哪些网络参数进行动作，包括有：
		 link ：关于装置 (device) 的相关设定，包括 MTU, MAC 地址等等
		 addr/address ：关于额外的 IP 协议，例如多 IP 的达成等等；
		 route ：与路由有关的相关设定
		由上面的语法我们可以知道， ip 除了可以设定一些基本的网络参数之外，还能够进行额外的 IP 协议， 包
		括多 IP 的达成，真是太完美了！底下我们就分三个部分 (link, addr, route) 来介绍这个 ip 指令吧！
		• 关于装置接口 (device) 的相关设定： ip link
		ip link 可以设定与装置 (device) 有关的相关设定，包括 MTU 以及该网络接口的 MAC 等等， 当然也可
		以启动 (up) 或关闭 (down) 某个网络接口啦！整个语法是这样的：
		[root@linux ~]# ip [-s] link show <== 单纯的查阅该装置相关的信息
		[root@linux ~]# ip link set [device] [动作与参数]
		参数：
		show：仅显示出这个装置的相关内容，如果加上 -s 会显示更多统计数据；
		set ：可以开始设定项目， device 指的是 eth0, eth1 等等界面代号；
		动作与参数：包括有底下的这些动作：
		 up|down ：启动 (up) 或关闭 (down) 某个接口，其它参数使用预设的以太网络；
		 address ：如果这个装置可以更改 MAC 的话，用这个参数修改！
		 name ：给予这个装置一个特殊的名字；
		 mtu ：就是最大传输单元啊！
		范例一：显示出所有的接口信息
		[root@linux ~]# ip link show
		1: lo: <LOOPBACK,UP,10000> mtu 16436 qdisc noqueue
		 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
		2: eth0: <BROADCAST,MULTICAST,UP,10000> mtu 1500 qdisc pfifo_fast qlen 1000
		 link/ether 00:50:fc:22:9a:cb brd ff:ff:ff:ff:ff:ff
		3: sit0: <NOARP> mtu 1480 qdisc noop
		 link/sit 0.0.0.0 brd 0.0.0.0
		[root@linux ~]# ip -s link show eth0
		2: eth0: <BROADCAST,MULTICAST,UP,10000> mtu 1500 qdisc pfifo_fast qlen 1000
		 link/ether 00:50:fc:22:9a:cb brd ff:ff:ff:ff:ff:ff
		 RX: bytes packets errors dropped overrun mcast
		 484011792 2247372 0 0 0 0
		 TX: bytes packets errors dropped carrier collsns
		 2914104290 2867753 0 0 0 0
		使用 ip link show 可以显示出整个装置接口的硬件相关信息，如上所示，包括网卡地址(MAC)、MTU 等等，
		比较有趣的应该是那个 sit0 的接口了，那个 sit0 的界面是用在 IPv4 及 IPv6 的封包转换上的， 对于
		我们仅使用 IPv4 的网络是没有作用的。 lo 及 sit0 都是主机内部所自行设定的。 而如果加上 -s 的参
		数后，则这个网络卡的相关统计信息就会被列出来， 包括接收 (RX) 及传送 (TX) 的封包数量等等，详细
		的内容与 ifconfig 所输出的结果相同的。
		范例二：启动、关闭与设定装置的相关信息
		[root@linux ~]# ip link set eth0 up
		# 启动 eth0 这个装置接口；
		[root@linux ~]# ip link set eth0 down
		# 阿就关闭啊！简单的要命～
		[root@linux ~]# ip link set eth0 mtu 1000
		# 更改 MTU 的值，达到 1000 bytes，单位就是 bytes 啊！
		更新网络卡的 MTU 使用 ifconfig 也可以达成啊！没啥了不起，不过，如果是要更改『网络卡代号、 MAC
		地址的信息』的话，那可就得使用 ip 啰～不过，设定前得要先关闭该网络卡，否则会不成功。 如下所示：
		范例三：修改网络卡代号、MAC 等参数
		[root@linux ~]# ip link set eth0 name vbird
		SIOCSIFNAME: Device or resource busy
		# 因为该装置目前是启动的，所以不能这样做设定。你应该要这样做：
		[root@linux ~]# ip link set eth0 down <==关闭界面
		[root@linux ~]# ip link set eth0 name vbird <==重新设定
		[root@linux ~]# ip link show <==观察一下
		2. vbird: <BROADCAST,MILTICASE> mtu 900 qdisc pfifo_fast qlen 1000
		 link/ehter 00:40:d0:13:c3:46 brd ff:ff:ff:ff:ff:ff
		# 怕了吧！连网络卡代号都可以改变！不过，玩玩后记得改回来啊！
		# 因为我们的 ifcfg-eth0 还是使用原本的装置代号！避免有问题，要改回来
		[root@linux ~]# ip link set vbird name eth0 <==界面改回来
		[root@linux ~]# ip link set eth0 address aa:aa:aa:aa:aa:aa
		[root@linux ~]# ip link show eth0
		# 如果你的网络卡支持硬件地址 (MAC) 可以更改的话，
		# 那么上面这个动作就可以更改你的网络卡地址了！厉害吧！
		# 不过，还是那句老话，测试完之后请立刻改回来啊！
		在这个装置的硬件相关信息设定上面，包括 MTU, MAC 以及传输的模式等等，都可以在这里设定。 有趣的
		是那个 address 的项目，那个项目后面接的可是硬件地址 (MAC) 而不是 IP 喔！ 很容易搞错啊！切记切
		记！更多的硬件参数可以使用 man ip 查阅一下与 ip link 有关的设定。
		• 关于额外的 IP 相关设定： ip address
		如果说 ip link 是与 OSI 七层协定 的第二层资料连阶层有关的话，那么 ip address (ip addr) 就是与
		第三层网络层有关的参数啦！ 主要是在设定与 IP 有关的各项参数，包括 netmask, broadcast 等等。
		[root@linux ~]# ip address show <==就是查阅 IP 参数啊！
		[root@linux ~]# ip address [add|del] [IP 参数] [dev 装置名] [相关参数]
		参数：
		show ：单纯的显示出接口的 IP 信息啊；
		add|del ：进行相关参数的增加 (add) 或删除 (del) 设定，主要有：
		 IP 参数：主要就是网域的设定，例如 192.168.100.100/24 之类的设定喔；
		 dev ：这个 IP 参数所要设定的接口，例如 eth0, eth1 等等；
		 相关参数：主要有底下这些：
		 broadcast：设定广播地址，如果设定值是 + 表示『让系统自动计算』
		 label ：亦即是这个装置的别名，例如 eth0:0 就是了！
		 scope ：这个界面的领域，通常是这几个大类：
		 global ：允许来自所有来源的联机；
		 site ：仅支持 IPv6 ，仅允许本主机的联机；
		 link ：仅允许本装置自我联机；
		 host ：仅允许本主机内部的联机；
		 所以当然是使用 global 啰！预设也是 global 啦！
		范例一：显示出所有的接口之 IP 参数：
		[root@linux ~]# ip address show
		1: lo: <LOOPBACK,UP,10000> mtu 16436 qdisc noqueue
		 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
		 inet 127.0.0.1/8 scope host lo
		 inet6 ::1/128 scope host
		 valid_lft forever preferred_lft forever
		2: eth0: <BROADCAST,MULTICAST,UP,10000> mtu 1500 qdisc pfifo_fast qlen 1000
		 link/ether 00:50:fc:22:9a:cb brd ff:ff:ff:ff:ff:ff
		 inet 192.168.1.2/24 brd 192.168.1.255 scope global eth0
		 inet6 fe80::250:fcff:fe22:9acb/64 scope link
		 valid_lft forever preferred_lft forever
		3: sit0: <NOARP> mtu 1480 qdisc noop
		 link/sit 0.0.0.0 brd 0.0.0.0
		看到上面那个特殊的字体吗？没错！那就是 IP 参数啦！也是 ip address 最主要的功能。 底下我们进一
		步来新增虚拟的网络介面试看看：
		范例二：新增一个接口，名称假设为 eth0:vbird
		[root@linux ~]# ip address add 192.168.50.50/24 broadcast + \
		> dev eth0 label eth0:vbird
		[root@linux ~]# ip address show eth0
		2: eth0: mtu 1500 qdisc pfifo_fast qlen 1000
		 link/ether 00:40:d0:13:c3:46 brd ff:ff:ff:ff:ff:ff
		 inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0
		 inet 192.168.50.50/24 brd 192.168.50.255 scope global eth0: vbird
		 inet6 fe80::240:d0ff:fe13:c346/64 scope link
		 valid_lft forever preferred_lft forever
		# 看到上面的特殊字体了吧？多出了一行新的接口，且名称是 eth0:vbird
		# 至于那个 broadcast + 也可以写成 broadcast 192.168.50.255 啦！
		[root@linux ~]# ifconfig
		eth0:vbir Link encap:Ethernet HWaddr 00:40:D0:13:C3:46
		 inet addr:192.168.50.50 Bcast:192.168.50.255 Mask:255.255.255.0
		 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
		 Interrupt:5 Base address:0x3e00
		# 如果使用 ifconfig 就能够看到这个怪东西了！可爱吧！ ^_^
		范例三：将刚刚的界面删除
		[root@linux ~]# ip address del 192.168.50.50/24 dev eth0
		# 删除就比较简单啊！ ^_^
		• 关于路由的相关设定： ip route
		呵呵，这个项目当然就是路由的观察与设定啰！事实上， ip route 的功能几乎与 route 这个指令差不多，
		但是，他还可以进行额外的参数设计，例如 MTU 的规划等等，相当的强悍啊！
		[root@linux ~]# ip route show <==单纯的显示出路由的设定而已
		[root@linux ~]# ip route [add|del] [IP 或网域] [via gateway] [dev 装置]
		参数：
		show ：单纯的显示出路由表，也可以使用 list ；
		add|del ：增加 (add) 或删除 (del) 路由的意思。
		 IP 或网域：可使用 192.168.50.0/24 之类的网域或者是单纯的 IP ；
		 via ：从那个 gateway 出去，不一定需要；
		 dev ：由那个装置连出去，这就需要了！
		 mtu ：可以额外的设定 MTU 的数值喔！
		范例一：显示出目前的路由资料
		[root@linux ~]# ip route show
		192.168.1.0/24 dev eth0 proto kernel scope link src 192.168. 1.2
		169.254.0.0/16 dev eth1 scope link
		default via 192.168.1.254 dev eth1
		如上表所示，最简单的功能就是显示出目前的路由信息，其实跟 route 这个指令相同啦！ 指示必须要注
		意几个小东西：
		• proto：此路由的路由协议，主要有 redirect, kernel, boot, static, ra 等， 其中 kernel 指
		的是直接由核心判断自动设定。
		• scope：路由的范围，主要是 link ，亦即是与本装置有关的直接联机。
		再来看一下如何进行路由的增加与删除吧！
		范例二：增加路由，主要是本机直接可沟通的网域
		[root@linux ~]# ip route add 192.168.5.0/24 dev eth0
		# 针对本机直接沟通的网域设定好路由，不需要透过外部的路由器
		[root@linux ~]# ip route show
		192.168.5.0/24 dev eth0 scope link
		....以下省略....
		范例三：增加可以通往外部的路由，需透过 router 喔！
		[root@linux ~]# ip route add 192.168.10.0/24 via 192.168.5.100 dev eth0
		[root@linux ~]# ip route show
		192.168.5.0/24 dev eth0 scope link
		....其它省略....
		192.168.10.0/24 via 192.168.5.100 dev eth0
		# 仔细看喔，因为我有 192.168.5.0/24 的路由存在 (我的网卡直接联系)，
		# 所以才可以将 192.168.10.0/24 的路由丢给 192.168.5.100
		# 那部主机来帮忙传递喔！与之前提到的 route 指令是一样的限制！
		范例四：增加预设路由
		[root@linux ~]# ip route add default via 192.168.1.2 dev eth0
		# 那个 192.168.1.2 就是我的预设路由器 (gateway) 的意思啊！ ^_^
		# 真的记得，只要一个预设路由就 OK ！
		范例五：删除路由
		[root@linux ~]# ip route del 192.168.10.0/24
		[root@linux ~]# ip route del 192.168.5.0/24
		事实上，这个 ip 的指令实在是太博大精深了！刚接触 Linux 网络的朋友，可能会看到有点晕～ 不要紧
		啦！您先会使用 ifconfig, ifup , ifdown 与 route 即可， 等以后有经验了之后，再继续回来玩 ip 这
		个好玩的指令吧！ ^_^ 有兴趣的话，也可以自行参考 ethtool 这个指令喔！ (man ethtool)。

	iwlist, iwconfig
		iwlist：利用无线网卡进行无线 AP 的侦测与取得相关的数据；
		iwconfig：设定无线网卡的相关参数。

	dhclient
		如果你是使用 DHCP 协议在局域网络内取得 IP 的话，那么是否一定要去编辑 ifcfg-eth0 内的
		BOOTPROTO 呢？ 嘿嘿！有个更快速的作法，那就是利用 dhclient 这个指令～因为这个指令才是真正发送
		dhcp 要求工作的程序啊！那要如何使用呢？很简单！如果不考虑其它的参数，使用底下的方法即可：
		[root@linux ~]# dhclient eth0
		够简单吧！这样就可以立刻叫我们的网络卡以 dhcp 协议去尝试取得 IP 喔！ 不过在 SuSE distribution
		里面，他仅有 dhcpcd 这支程序，他与 dhclient 是相同的咚咚啦！ ^_^

网络侦错与观察指令：
	ping
		这个 ping 是很重要的指令，ping 主要透过 ICMP 封包 来进行整个网络的状况报告，当然啦，最重要的
		就是那个 ICMP type 0, 8 这两个类型， 分别是要求回报与主动回报网络状态是否存在的特性。要特别注
		意的是， ping 还是需要透过 IP 封包来传送 ICMP 封包的， 而 IP 封包里面有个相当重要的 TTL (Time
		To Live) 属性，这是很重要的一个路由特性， 详细的 IP 与 ICMP 表头资料请参考网络基础的详细介绍。
		[root@linux ~]# ping [-bcstnM] IP
		参数：
		-b ：后面接的是 broadcast 的 IP，用在你『需要对整个网域的主机进行 ping 』时；
		-c ：后面接的是执行 ping 的次数，例如 -c 5 ；
		-n ：不进行 IP 与主机名称的反查，直接使用 IP ；
		-s ：发送出去的 ICMP 封包大小，预设为 56(bytes)，再加 8 bytes 的 ICMP 表头资料
		-t ：TTL 的数值，预设是 255，每经过一个节点就会少一；
		-M [do|dont] ：主要在侦测网络的 MTU 数值大小，两个常见的项目是：
		 do ：代表传送一个 DF (Don't Fragment) 旗标，让封包不能重新拆包与打包；
		 dont：代表不要传送 DF 旗标，表示封包可以在其它主机上拆包与打包
		范例一：侦测一下 168.95.1.1 这部 DNS 主机是否存在？
		[root@linux ~]# ping -c 3 168.95.1.1
		PING 168.95.1.1 (168.95.1.1) 56(84) bytes of data.
		64 bytes from 168.95.1.1: icmp_seq=0 ttl=243 time=9.16 ms
		64 bytes from 168.95.1.1: icmp_seq=1 ttl=243 time=8.98 ms
		64 bytes from 168.95.1.1: icmp_seq=2 ttl=243 time=8.80 ms
		--- 168.95.1.1 ping statistics ---
		3 packets transmitted, 3 received, 0% packet loss, time 2002ms
		rtt min/avg/max/mdev = 8.807/8.986/9.163/0.164 ms, pipe 2
		ping 最简单的功能就是传送 ICMP 封包去要求对方主机响应是否存在于网络环境中， 上面的响应讯息当
		中，几个重要的项目是这样的：
		• 64 bytes：表示这次传送的 ICMP 封包大小为 64 bytes 这么大，这是默认值， 在某些特殊场合
		中，例如要搜索整个网络内最大的 MTU 时，可以使用 -s 2000 之类的数值来取代；
		• icmp_seq=0：ICMP 所侦测进行的次数，第一次编号为 0 ；
		• ttl=243：TTL 与 IP 封包内的 TTL 是相同的，每经过一个带有 MAC 的节点 (node) 时，例如
		router, bridge 时， TTL 就会减少一，预设的 TTL 为 255 ， 你可以透过 -t 150 之类的方法
		来重新设定预设 TTL 数值；
		• time=9.16 ms：响应时间，单位有 ms(0.001 秒)及 us(0.000001 秒)， 一般来说，越小的响应时
		间，表示两部主机之间的网络联机越良好！
		如果你忘记加上 -c 3 这样的规定侦测次数，那就得要使用 [ctrl]-c 将他结束掉了！
		范例二：针对整个网域进行 ping 的追查
		[root@linux ~]# ping -c 3 -b 192.168.10.255
		WARNING: pinging broadcast address <==会告知危险喔！
		PING 192.168.10.255 (192.168.10.255) 56(84) bytes of data.
		64 bytes from 192.168.10.100: icmp_seq=1 ttl=64 time=0.177 ms
		64 bytes from 192.168.10.20: icmp_seq=1 ttl=64 time=0.179 ms (DUP!)
		64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.302 ms (DUP!)
		64 bytes from 192.168.10.40: icmp_seq=1 ttl=64 time=0.304 ms (DUP!)
		# 当要针对整部主机作 ping 的侦测时，可以利用 -b 这个参数。
		# 请特别注意，当使用 ping -b 时，会对整个网域进行侦测喔！没事别乱用。
		# 例如上面的范例中，区网内的 192.168.10.20... 等主机会被侦测到。
		如果想要了解区网内有多少部主机存活着，那么使用 ping -b broadcast 就能够知道了！ 而不必一部一
		部主机来侦测啊！方便～另外也特别注意一下， 如果您的主机与待侦测主机并不在同一个网域内， 那么
		TTL 预设使用 255 ，如果是同一个网域内，那么 TTL 预设则使用 64 喔！ 看看上面的输出即可了解。
		用 ping 追踪最大 MTU 数值
		我们由前几章的网络基础里面谈到加大讯框 (frame) 时， 对于网络效能是有帮助的，因为封包打包的次
		数会减少，加上如果整个传输的媒体都能够接受这个 frame 而不需要重新进行封包的拆解与重组的话，那
		么效能当然会更好，那个修改 frame 大小的参数就是 MTU 啦！好了，现在我们知道网络卡的 MTU 可以透
		过 ifconfig 或者是 ip 等来达成， 那么追踪整个网络传输的最大 MTU 时，又该如何查询？呵呵！最简
		单的方法当然是透过 ping 传送一个大封包， 并且不许中继的路由器或 switch 将该封包重组，那就能够
		处理啦！没错！可以这样的：
		范例三：找出最大的 MTU 数值
		[root@linux ~]# ping -c 2 -s 1000 -M do 192.168.10.10
		PING 192.168.10.10 (192.168.10.10) 1000(1028) bytes of data.
		1008 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.424 ms
		# 如果有响应，那就是可以接受这个封包，如果无响应，那就表示这个 MTU 太大了。
		[root@linux ~]# ping -c 2 -s 8000 -M do 192.168.10.10
		PING 192.168.10.10 (192.168.10.10) 8000(8028) bytes of data.
		ping: local error: Message too long, mtu=1500
		# 这个错误讯息是说，本地端的 MTU 才到 1500 而已，你要侦测 8000 的 MTU
		# 根本就是无法达成的！那要如何是好？用前一小节介绍的 ip link 来进行 MTU 设定吧！
		不过，你需要知道的是，由于 IP 封包表头 (不含 options) 就已经占用了 20 bytes ，再加上 ICMP 的
		表头有 8 bytes ，所以当然你在使用 -s size 的时候，那个封包的大小就得要先扣除 (20+8=28) 的大小
		了。 因此如果要使用 MTU 为 1500 时，就得要下达『 ping -s 1472 -M do xx.yy.zz.ip 』才行啊！ 另
		外，由于本地端的网络卡 MTU 也会影响到侦测，所以如果想要侦测整个传输媒体的 MTU 数值， 那么每个
		可以调整的主机就得要先使用 ifcofig 或 ip 先将 MTU 调大，然后再去进行侦测， 否则就会出现像上面
		提供的案例一样，可能会出现『Message too long, mtu=1500』之类的字样喔！ 至于如果侦测完毕后，想
		要调整最佳化的 MTU ，那么请参考前一章节的内容来调整啰！ ^_^
		不过这个 MTU 不要随便调整啊！除非真的有问题。通常调整 MTU 的时间是在这个时候：
		• 因为全部的主机群都是在内部的区网，例如丛集架构 (cluster) 的环境下， 由于内部的网络节
		点都是我们可以控制的，因此可以透过修改 MTU 来增进网络效能；
		• 因为操作系统预设的 MTU 与您的网域不符，导致某些网站可以顺利联机，某些网站则无法联机。
		以 Windows 操作系统作为联机分享的主机时，在 Client 端挺容易发生这个问题；
		如果是要连上 Internet 的主机，注意不要随便调整 MTU ，因为我们无法知道 Internet 上面的每部机器
		能够支持的 MTU 到多大，因为......不是我们能够管的到的嘛！ ^_^
		另外，其实每种联机方式都有不同的 MTU 值，常见的各种接口的 MTU 值分别为︰
		网络接口 MTU
		Ethernet 1500
		PPPoE 1492
		Dial-up(Modem) 576

	traceroute
		我们前面谈到的指令大多数都是针对主机的网络参数设定所需要的，而 ping 是两部主机之间的回声与否
		判断， 那么有没有指令可以追踪两部主机之间通过的各个节点 (node) 通讯状况的好坏呢？ 举例来说，
		如果我们联机到 yahoo 的速度比平常慢，你觉得是 (1)自己的网络环境有问题？ (2)还是外部的
		Internet 有问题？如果是 (1) 的话，我们当然需要检查自己的网络环境啊， 看看是否又有谁中毒了？但
		如果是 Internet 的问题呢？那只有『等等等』啊！ 判断是 (1) 还是 (2) 就得要使用 traceroute 这个
		指令啦！
		[root@linux ~]# traceroute [-nwig] IP
		参数：
		-n ：可以不必进行主机的名称解析，单纯用 IP ，速度较快！
		-w ：若对方主机在几秒钟内没有回声就宣告不治...预设是 5 秒
		-i ：用在比较复杂的环境，如果你的网络接口很多很复杂时，才会用到这个参数；
		 举例来说，你有两条 ADSL 可以连接到外部，那你的主机会有两个 ppp，
		 你可以使用 -i 来选择是 ppp0 还是 ppp1 啦！
		-g ：与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了。
		范例一：
		[root@linux ~]# traceroute -n tw.yahoo.com
		traceroute to tw.yahoo-ap1.akadns.net (203.84.202.164), 30 hops max, 38 byte packets
		 1 61.59.121.1 42.174 ms 41.690 ms 41.058 ms
		 2 139.175.172.2 40.962 ms 41.978 ms 40.973 ms
		 3 192.72.122.130 40.983 ms 41.930 ms 41.003 ms
		 4 139.175.58.210 42.956 ms 41.997 ms 42.337 ms
		 5 139.175.58.153 47.591 ms 47.972 ms 48.748 ms
		 6 139.175.56.30 48.193 ms 47.970 ms 47.986 ms
		 7 139.175.57.94 47.959 ms 47.951 ms 47.985 ms
		 8 139.175.56.138 48.363 ms 47.586 ms 47.995 ms
		 9 139.175.58.42 49.256 ms 50.668 ms 47.490 ms
		10 61.58.33.133 201.882 ms 201.565 ms 200.973 ms
		11 61.58.33.50 199.910 ms 199.019 ms 198.961 ms
		12 203.84.200.226 202.391 ms 202.567 ms 209.283 ms
		这个 traceroute 挺有意思的，这个指令会针对欲连接的目的地之所有 router 进行 ICMP 的逾时等待，
		例如上面的例子当中，由鸟哥的主机连接到 Yahoo 时，他会经过 12 个节点，traceroute 会主动的对这 12
		个节点做 ICMP 的回声等待，并侦测回复的时间，每个节点会侦测三次。 所以像上头显示的结果，发现每
		个节点其实回复的时间大约在 200 ms 以内，算是还可以的 Internet 环境了。 而且由上面的信息来看，
		可以看出在 61.58.33.133 这个节点后的传输延迟较久，至于之前的 9 个节点则有不错的表现。透过这种
		解析，可以让您了解到这条联机是那个环节出了问题喔。
		另外，如果在预设的 5 秒钟之内 traceroute 听不到节点的回声，那么屏幕上就会跑出一个『 * 』的符
		号， 告知该节点无法有顺利的响应。由于我们的 traceroute 用的是 ICMP 封包，有些防火墙或者主机可
		能会将 ICMP 可通过的权力拿掉，因此就会造成等不到回声的状态！另外，有些 gateway 本来就不支持
		traceroute 的功能，因此也会产生那个『 * 』的状况。所以分析时得要注意一下吶！
	
	netstat
		如果你觉得你的某个网络服务明明就启动了，但是就是无法造成联机的话，那么应该怎么办？ 首先你应该
		要查询一下自己的网络接口所监听的端口口 (port) 来看看是否真的有启动， 因为有时候屏幕上面显示的
		[OK] 并不一定是 OK 啊！ ^_^
		[root@linux ~]# netstat -[rn] <==与路由有关的参数
		[root@linux ~]# netstat -[antulpc] <==与网络接口有关的参数
		参数：
		与路由 (route) 有关的参数说明：
		-r ：列出路由表(route table)，功能如同 route 这个指令；
		-n ：不使用主机名称与服务名称，使用 IP 与 port number ，如同 route -n
		与网络接口有关的参数：
		-a ：列出所有的联机状态，包括 tcp/udp/unix socket 等；
		-t ：仅列出 TCP 封包的联机；
		-u ：仅列出 UDP 封包的联机；
		-l ：仅列出有在 Listen (监听) 的服务之网络状态；
		-p ：列出 PID 与 Program 的檔名；
		-c ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；
		范例一：列出目前的路由表状态，且以 IP 及 port number 显示：
		[root@linux ~]# netstat -rn
		Kernel IP routing table
		Destination Gateway Genmask Flags MSS Window irtt Iface
		192.168.10.0 0.0.0.0 255.255.255.0 U 0 0  0 eth0
		169.254.0.0 0.0.0.0 255.255.0.0 U 0 0  0 eth0
		0.0.0.0 192.168.10.30 0.0.0.0 UG 0 0  0 eth0
		# 其实这个参数就跟 route -n 一模一样，对吧！这不是 netstat 的主要功能啦！
		范例二：列出目前的所有网络联机状态，使用 IP 与 port number
		[root@linux ~]# netstat -an
		Active Internet connections (servers and established)
		Proto Recv-Q Send-Q Local Address Foreign Address State
		tcp 0 0 0.0.0.0:25 0.0.0.0:*  LISTEN
		tcp 0 0 :::22 :::*  LISTEN
		tcp 0 0 ::ffff:192.168.10.100:25 ::ffff:192.168. 10.200:57509 TIME_WAIT
		tcp 0 52 ::ffff:192.168.10.100:22 ::ffff:192.168. 10.210:1504 ESTABLISHED
		udp 0 0 127.0.0.1:53 0.0.0.0:*
		Active UNIX domain sockets (servers and established)
		Proto RefCnt Flags Type State I-Node Path
		unix 2 [ ACC ] STREAM LISTENING 4792 public/cleanup
		unix 2 [ ACC ] STREAM LISTENING 4799 private/rewrite
		......(底下省略)......
		netstat 的输出主要分为两大部分，分别是 TCP/IP 的网络接口部分，以及传统的 Unix socket 部分。 还
		记得我们在基础篇里面曾经谈到档案的类型吗？那个 socket 与 FIFO 档案还记得吧？ 那就是在 Unix
		接口用来做为程序数据交流的接口了，也就是上头表格内看到的 Active Unix domain sockets 的内容啰～
		通常鸟哥都是建议加上『 -n 』这个参数的，因为可以避过主机名称与服务名称的反查，直接以 IP 及端
		口口号码 (port number) 来显示，显示的速度上会快很多！至于在输出的讯息当中， 我们先来谈一谈关
		于网络联机状态的输出部分，他主要是分为底下几个大项：
		• Proto：该联机的封包协议，主要为 TCP/UDP 等封包；
		• Recv-Q：非由使用者程序连接所复制而来的总 bytes 数；
		• Send-Q：由远程主机所传送而来，但不具有 ACK 标志的总 bytes 数， 意指主动联机 SYN 或其
		它标志的封包所占的 bytes 数；
		• Local Address：本地端的地址，可以是 IP (-n 参数存在时)， 也可以是完整的主机名称。如上
		表我们看到的 IP 格式有两种，一种是 IPv4 的标准， 亦即是四组十进制的数字后面加上冒号『:』
		后，接着 port number 。一种是 IPv6 ， 前面的 IP 加上很多冒号『:』的格式。我们可以由这
		个显示的数据看出这个服务是开放在哪一个接口， 例如上表当中， port 22 是开放在 0.0.0.0 ，
		亦即是所有接口都可以连到 port 22 ， 至于 port 53 则仅开放在本机的 127.0.0.1 这个接口
		而已，所以是不对外部接口开放的意思。
		• Foreign Address：远程的主机 IP 与 port number
		• stat：状态列，主要的状态含有：
		o ESTABLISED：已建立联机的状态；
		o SYN_SENT：发出主动联机 (SYN 标志) 的联机封包；
		o SYN_RECV：接收到一个要求联机的主动联机封包；
		o FIN_WAIT1：该插槽服务(socket)已中断，该联机正在断线当中；
		o FIN_WAIT2：该联机已挂断，但正在等待对方主机响应断线确认的封包；
		o TIME_WAIT：该联机已挂断，但 socket 还在网络上等待结束；
		o LISTEN：通常用在服务的监听 port ！可使用『 -l 』参数查阅。
		基本上，我们常常谈到的 netstat 的功能，就是在观察网络的联机状态了，而网络联机状态中， 又以观
		察『我目前开了多少的 port 在等待客户端的联机』以及 『目前我的网络联机状态中，有多少联机已建立
		或产生问题』最常见。 那你如何了解与观察呢？通常鸟哥是这样处理的：
		范例三：秀出目前已经启动的网络服务
		[root@linux ~]# netstat -tulnp
		Active Internet connections (only servers)
		Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
		tcp 0 0 0.0.0.0:25 0.0.0.0:* LISTEN 2141/master
		tcp 0 0 :::22 :::* LISTEN 1924/sshd
		tcp 0 0 :::25 :::* LISTEN 2141/master
		udp 0 0 127.0.0.1:53 0.0.0.0:* 1911/named
		# 上面最重要的其实是那个 -l 的参数，因为可以仅列出有在 Listen 的 port
		你可以在上面的范例当中发现，我的网络联机仅有对外开放 port 25 以及 port 22 而已 (因为针对
		0.0.0.0 开放)， 至于 port 53 则仅针对内部的 127.0.0.1 来开放，所以是不对 Internet 开放这个服
		务的喔！ 而其中 port 22,25 都是使用 TCP 封包，至于 port 53 则是开放在 UDP 封包的状态！ 再仔细
		的看，每一行输出的最右边，你可以发现鸟哥的主机 port 22 是由 sshd 这支程序所启动的， 并且他的
		PID 是 1924 ，看到这边，聪明的您应该知道，『那我如何关闭这个 port 』吧？使用 kill 或 killall 即
		可啊！ ^_^
		范例四：观察本机上头所有的网络联机状态
		[root@linux ~]# netstat -atunp
		Active Internet connections (servers and established)
		Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
		tcp 0 0 0.0.0.0:25 0.0.0.0:* LISTEN 2141/master
		tcp 0 0 :::22 :::* LISTEN 1924/sshd
		tcp 0 0 :::25 :::* LISTEN 2141/master
		tcp 0 68 192.168.1.100:22 192.168.1.210:1504 ESTABLISHED 30417/sshd:
		udp 0 0 127.0.0.1:53 0.0.0.0:*  1911/named
		看到上头的特殊字体吧？那代表目前已经建立联机的一条网络联机，他是由远程主机 192.168.1.210 启动
		一个大于 1024 的埠口向本地端主机 192.168.1.100 的 port 22 进行联机的一条联机， 你必须要想起来
		的是：『Client 端是随机取一个大于 1024 以上的 port 进行联机』， 此外『只有 root 可以启动小于 1023
		以下的 port 』，那就看的懂上头那条联机啰！如果这条联机你想要砍掉他的话， 看到最右边的 30417/sshd
		了没？ kill 会用吧！ ^_^
		至于传统的 Unix socket 的数据，记得使用 man netstat 查阅一下吧！ 这个 Unix socket 通常是用在
		一些仅在本机上运作的程序所开启的插槽接口文件， 例如 X Window 不都是在本机上运作而已吗？那何必
		启动网络的 port 呢？当然可以使用 Unix socket 啰，另外，例如 Postfix 这一类的网络服务器，由于
		很多动作都是在本机上头来完成的， 所以以会占用很多的 Unix socket 喔！

	host
		这个指令可以用来查出某个主机名称的 IP 喔！举例来说，我们想要知道 tw.yahoo.com 的 IP 时， 可以
		这样做：
		[root@linux ~]# host [-a] hostname [server]
		参数：
		-a ：列出该主机详细的各项主机名称设定数据
		[server] ：可以使用非为 /etc/resolv.conf 的 DNS 主机来查询。
		范例一：列出 tw.yahoo.com 的 IP
		[root@linux ~]# host tw.yahoo.com
		tw.yahoo.com is an alias for tw.yahoo-ap1.akadns.net.
		tw.yahoo-ap1.akadns.net has address 202.43.195.52
		瞧！IP 是 202.43.195.52 啊！很简单就可以查询到 IP 了！ 那么这个 IP 是向谁查询的呢？其实就是写
		在 /etc/resolv.conf 那个档案内的 DNS 主机啦！如果不想要使用该档案内的主机来查询，也可以这样做：
		[root@linux ~]# host tw.yahoo.com 168.95.1.1
		Using domain server:
		Name: 168.95.1.1
		Address: 168.95.1.1#53
		Aliases:
		tw.yahoo.com is an alias for tw.yahoo-ap1.akadns.net.
		tw.yahoo-ap1.akadns.net has address 202.43.195.52
		会告诉我们所使用来查询的主机是哪一部吶！这样就够清楚了吧？至于更详细的 host 用法，我们会在 DNS
		主机 那个章节再来好好聊一聊吧！

	nslookup
		这玩意儿的用途与 host 基本上是一样的，就是用来作为 IP 与主机名称对应的检查， 同样是使用
		/etc/resolv.conf 这个档案来作为 DNS 服务器的来源选择。
		[root@linux ~]# nslookup [-query=[type]] [hostname|IP]
		参数：
		-query=type：查询的类型，除了传统的 IP 与主机名称对应外，DNS 还有很多信息，
		 所以我们可以查询很多不同的信息，包括 mx, cname 等等，
		 例如： -query=mx 的查询方法！
		范例一：找出 www.google.com.tw 的 IP
		[root@linux ~]# nslookup www.google.com.tw
		Server: 168.95.1.1
		Address: 168.95.1.1#53
		Non-authoritative answer:
		www.google.com.tw canonical name = www.google.com.
		www.google.com canonical name = www.l.google.com.
		Name: www.l.google.com
		Address: 64.233.189.104
		范例二：找出 168.95.1.1 的主机名称
		[root@linux ~]# nslookup 168.95.1.1
		Server: 168.95.1.1
		Address: 168.95.1.1#53
		1.1.95.168.in-addr.arpa name = dns.hinet.net.
		如何，看起来与 host 差不多吧！不过，这个 nslookup 还可以由 IP 找出主机名称喔！ 例如那个范例二，
		他的主机名称是： dns.hinet.net 哩！目前大家都建议使用 dig 这个指令来取代 nslookup ，我们会在
		DNS 服务器 那时再来好好谈一谈吧！

远程联机指令：
	telnet
		telnet 是早期我们在个人计算机上面要连结到服务器主机上工作时，最重要的一个软件了！ 他不但可以
		直接连接到服务器上头，还可以用来连结 BBS 呢！非常棒！ 不过， telnet 本身的数据在传送的时候是
		使用明码 (原始的数据，没有加密) ， 所以数据在 Internet 上面跑的时候，会比较危险一点 (就怕被别
		人监听啊)。 更详细的资料我们会在『 远程联机服务器』章节内做介绍的。
		如上所示，我们可以透过 telnet 轻易的连结到 BBS 上面， 而如果您的主机有开启 telnet 服务的话， 同
		样的利用『 telnet IP 』并且输入账号与密码之后，就能够登入主机了。 另外，在 Linux 上的 telnet 软
		件还提供了 Kerberos 的认证方式，有兴趣的话请自行参阅 man telnet 的说明。
		除了连结到服务器以及连结到 BBS 站之外， telnet 还可以用来连结到某个 port (服务) 上头吶！ 举例
		来说，我们可以用 telnet 连接到 port 110 ，看看这个 port 是否有正确的启动呢？
		范例二：侦测本机端的 110 这个 port 是否正确启动？
		[root@linux ~]# telnet localhost 110
		Trying 127.0.0.1...
		telnet: connect to address 127.0.0.1: Connection refused
		# 如果出现这样的讯息，代表这个 port 没有启动或者是这个联机有问题，
		# 因为您看到那个 refused 嘛！
		[root@linux ~]# telnet localhost 25
		Trying 127.0.0.1...
		Connected to localhost.
		Escape character is '^]'.
		220 vbird.vbird.idv.tw ESMTP Postfix
		ehlo localhost
		250-linux.dm.tsai
		250-PIPELINING
		250-SIZE 10240000
		250-VRFY
		250-ETRN
		250 8BITMIME
		quit
		221 Bye
		Connection closed by foreign host.
		瞧！根据输出的结果，我们就能够知道这个通讯协议 (port number 提供的通讯协议功能) 是否有成功的
		启动吶！ 而在每个 port 所监听的服务都有其特殊的指令，例如上述的 port 25 就是在本机接口所提供
		的电子邮件服务， 那个服务所支持的指令就如同上面使用的数据一样，但是其它的 port 就不见得支持这
		个『 ehlo 』的命令， 因为不同的 port 有不同的程序嘛！所以当然支持的命令就不同啰！ 与 mail server
		有关的 telnet 用法，我们将在邮件服务器内提到喔！

	ftp
		常常会听到『FTP』这个咚咚吧！举例来说，如果你想要下载 Linux 的光盘烧录映象文件时，要去哪里下
		载啊？ 不是说要去义守大学吗？也可以到成大或昆山科大等等的 FTP 网站，嘿嘿！没错～那就是 FTP 提
		供者啦！ 那我们要如何去下载呢？当然就是透过 ftp 的客户端软件了。在 Linux 底下，我们可以透过 ftp
		这个软件， 也可以透过下一小节会提到的 lftp 说～
		[root@linux ~]# ftp [-p] [host|IP] [port]
		参数：
		-p ：启动被动式模式 (passive, PASV)；
		范例一：联机到义守大学去看看
		[root@linux ~]# ftp ftp.isu.edu.tw
		Connected to ftp.isu.edu.tw (140.127.177.17).
		220-欢迎光临义守大学档案服务器
		220-
		220-本站提供以下软件可供下载：
		220-*******************************************************************************
		220-/pub/BeOS/ BeOS 操作系统
		220-/pub/Linux/ Linux 操作系统
		....(其它省略)....
		220-*******************************************************************************
		Name (ftp.isu.edu.tw:dmtsai): anonymous
		230 Login successful.
		Remote system type is UNIX.
		Using binary mode to transfer files.
		ftp>
		ftp> help <==提供更多的可用指令，可以常参考！
		ftp> cd /pub <==变换目录到 /pub 当中
		ftp> dir <==显示远程主机的目录内容
		ftp> get file <==下载 file 这个档案
		ftp> mget file <==下载 file 这个目录或档案
		ftp> put file <==上传 file 这个档案到服务器上
		ftp> delete file <==删除主机上的 file 这个档案
		ftp> mkdir dir <==建立 dir 这个目录
		ftp> lcd /home <==切换『本地端主机』的工作目录
		ftp> passive <==启动或关闭 passive 模式
		ftp> binary <==数据传输模式设定为 binary 格式
		FTP 其实算是一个很麻烦的协议，因为他使用两个 port 分别进行命令与数据的交流， 详细的数据我们会
		在后续的 FTP 服务器内详谈，这里我们先单纯的介绍一下如何使用 ftp 这个软件。 首先我们当然是需要
		登入啰，所以在上头的表格当中我们当然需要填入账号与密码了。 不过由于义守大学提供匿名登入，而匿
		名登入者的账号就是『 anonymous 』所以直接填写那个账号即可。 如果是私人的 FTP 时，才需要提供一
		组完整的账号与密码啦！
		登入 FTP 主机后，就能够使用 ftp 软件的功能进行上传与下载的动作， 几个常用的 ftp 内指令如上表，
		不过，鸟哥建议您可以连到大学的 FTP 网站后， 使用 help (或问号 ?) 来参考可用的指令，然后尝试下
		载以测试使用一下这个指令吧！ 这样以后没有浏览器的时候，你也可以到 ftp 下载了呢！不错吧！ ^_^
		另外，如果由于某些理由，让你的 FTP 主机的 port 开在非正规的埠口时， 那你就可以利用底下的方式
		来连接到该部主机喔！
		[root@linux ~]# ftp hostname 318
		# 假设对方主机的 ftp 服务开启在 318 这个 port 啊！
	
	lftp
		早期当我们要登入提供匿名登入的主机时，很多时候都是使用 ncftp 这个软件， 不过，现在有更棒的选
		择，那就是 lftp 啦！这个软件甚至可以在 ftp 里面使用类似 bash 的指令功能， 实在是非常的完美！
		而整个使用的方法与上面提到的 ftp 又非常类似吶！
		[root@linux ~]# lftp [-p port] [-u user[,pass]] [host|IP]
		参数：
		-p ：后面可以直接接上远程 FTP 主机提供的 port
		-u ：后面则是接上 账号与密码 ，就能够连接上远程主机了
		 如果没有加账号密码， lftp 预设会使用 anonymous 尝试匿名登入
		范例一：利用 lftp 登入义守大学
		[root@linux ~]# lftp ftp.isu.edu.tw
		lftp ftp.isu.edu.tw:~>
		# 瞧！一下子就登入了！很快乐吧！ ^_^
		至于登入 FTP 主机后，一样可以使用『help』来显示出可以执行的指令， 与 ftp 很类似啦！不过多了书
		签的功能，而且也非常的类似 bash 那！很不错呦！ 除了这个好用的文字接口的 FTP 软件之外，事实上
		还有很多图形接口的好用软件呢！ 最常见的就是 gftp 了～不但是图形接口，而且与 cute ftp 简直就是
		像到不行！非常的容易上手喔！ CentOS 本身就有提供 gftp 了，你可以拿出原版的光盘来安装，然后进
		入 X Window 后， 启动一个 shell ，输入『 gftp 』就能够发现他的好用啦！底下我们在来介绍一下实
		时通讯吧！

文字接口网页浏览
	lynx
		这个指令可以让我们来浏览网页，但鸟哥认为，这个档案最大的功能是在『 查阅 Linux 本机上面以 HTML
		语法写成的文件数据 (document)』 怎么说呢？如果你曾经到 Linux 本机底下的 /usr/share/doc 这个目
		录看过文件数据的话， 就会常常发现一些网页档案，使用 vi 去查阅时，老是看到一堆 HTML 的语法！有
		碍阅读啊～ 这时候使用 lynx 就是个好方法啦！可以看的清清楚楚啊！ ^_^
		[root@linux ~]# lynx [options] [website]
		参数：
		options 指的是一些惯用的参数，可以使用 man lynx 查阅，常见的有：
		-anonymous ：预设使用匿名登入；
		-assume_charset=big5 ：设定预设的语系数据为 big5 ，用在中文网页很方便
		范例一：浏览 Linux kernel 网站
		[root@linux ~]# LANG=zh_TW.big5
		[root@linux ~]# lynx http://www.kernel.org

	wget
		如果说 lynx 是在进行网页的『浏览』，那么 wget 就是在进行『网页数据的取得』。 举例来说，我们的
		Linux 核心是放置在 www.kernel.ort 内，主要同时提供 ftp 与 http 来下载。 我们知道可以使用 lftp
		来下载资料，但如果想要用浏览器来下载呢？ 那就利用 wget 吧！
		[root@linux ~]# wget [option] [网址]
		参数：
		若想要联机的网站有提供账号与密码的保护时，可以利用这两个参数来输入喔！
		--http-user=usrname
		--http-password=password
		--quiet ：不要显示 wget 在抓取数据时候的显示讯息
		更多的参数请自行参考 man wget 吧！ ^_^
		范例一：请下载 2.6.17 版的核心
		[root@linux ~]# wget \
		> http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.17.tar. gz
		--16:06:10-- http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.17.tar.gz
		 => `linux-2.6.17.tar.gz'
		Resolving www.kernel.org... 204.152.191.37, 204.152.191.5
		Connecting to www.kernel.org|204.152.191.37|:80... connected.
		HTTP request sent, awaiting response... 200 OK
		Length: 51,700,445 (49M) [application/x-gzip]
		 3% [==> ] 1,890,568 220.69K/s ETA 04:12
		您瞧瞧～很可爱吧！不必透过浏览器，只要知道网址后，立即可以进行档案的下载， 又快速又方便，还可
		以透过 proxy 的帮助来下载呢！透过修改 /etc/wgetrc 来设定你的代理服务器：
		[root@linux ~]# vi /etc/wgetrc
		#http_proxy = http://proxy.yoyodyne.com:18023/ <==找到底下这几行，大约在 78 行后；
		#ftp_proxy = http://proxy.yoyodyne.com:18023/
		#use_proxy = on
		# 将他改成类似底下的模样，记得，你必须要有可接受的 proxy 主机才行！
		http_proxy = http://proxy.ncku.edu.tw:3128/
		use_proxy = no

封包撷取功能
	tcpdump
		说实在的，对于 tcpdump 这个软件来说，你甚至可以说这个软件其实就是个黑客软件， 因为他不但可以
		分析封包的流向，连封包的内容也可以进行『监听』， 如果你使用的传输数据是明码的话，不得了，在 router
		上面就可能被人家监听走了！ 很可怕吶！所以，我们也要来了解一下这个软件啊！(注：这个 tcpdump 必
		须使用 root 的身份执行)
		[root@linux ~]# tcpdump [-nn] [-i 接口] [-w 储存档名] [-c 次数] [-Ae]
		 [-qX] [-r 档案] [所欲撷取的数据内容]
		参数：
		-nn：直接以 IP 及 port number 显示，而非主机名与服务名称
		-i ：后面接要『监听』的网络接口，例如 eth0, lo, ppp0 等等的界面；
		-w ：如果你要将监听所得的封包数据储存下来，用这个参数就对了！后面接档名
		-c ：监听的封包数，如果没有这个参数， tcpdump 会持续不断的监听，
		 直到使用者输入 [ctrl]-c 为止。
		-A ：封包的内容以 ASCII 显示，通常用来捉取 WWW 的网页封包资料。
		-e ：使用资料连接层 (OSI 第二层) 的 MAC 封包数据来显示；
		-q ：仅列出较为简短的封包信息，每一行的内容比较精简
		-X ：可以列出十六进制 (hex) 以及 ASCII 的封包内容，对于监听封包内容很有用
		-r ：从后面接的档案将封包数据读出来。那个『档案』是已经存在的档案，
		 并且这个『档案』是由 -w 所制作出来的。
		所欲撷取的数据内容：我们可以专门针对某些通讯协议或者是 IP 来源进行封包撷取，
		 那就可以简化输出的结果，并取得最有用的信息。常见的表示方法有：
		 'host foo', 'host 127.0.0.1' ：针对单部主机来进行封包撷取
		 'net 192.168' ：针对某个网域来进行封包的撷取；
		 'src host 127.0.0.1' 'dst net 192.168'：同时加上来源(src)或目标(dst) 限制
		 'tcp port 21'：还可以针对通讯协议侦测，如 tcp, udp, arp, ether 等
		 还可以利用 and 与 or 来进行封包数据的整合显示呢！
		范例一：以 IP 与 port number 捉下 eth0 这个网络卡上的封包，持续 3 秒
		[root@linux ~]# tcpdump -i eth0 -nn
		tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
		listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
		01:33:40.41 IP 192.168.1.100.22 > 192.168.1.11.1190: P 116:232(116) ack 1 win 9648
		01:33:40.41 IP 192.168.1.100.22 > 192.168.1.11.1190: P 232:364(132) ack 1 win 9648
		<==按下 [ctrl]-c 之后结束
		6680 packets captured <==捉下来的封包数量
		14250 packets received by filter <==由过滤所得的总封包数量
		7512 packets dropped by kernel <==被核心所丢弃的封包
		如果你是第一次看 tcpdump 的 man page 时，肯定一个头两个大，因为 tcpdump 几乎都是分析封包的表
		头数据，使用者如果没有简易的网络封包基础，要看懂粉难吶！ 所以，至少您得要回到网络基础里面去将
		TCP 封包的表头资料理解理解才好啊！ ^_^！至于那个范例一所产生的输出范例中，我们可以约略区分为
		数个字段， 我们以范例一当中那个特殊字体行来说明一下：
		• 01:33:40.41：这个是此封包被撷取的时间，『时:分:秒』的单位；
		• IP：透过的通讯协议是 IP ；
		• 192.168.1.100.22 > ：传送端是 192.168.1.100 这个 IP，而传送的 port number 为 22，您必
		须要了解的是，那个大于 (>) 的符号指的是封包的传输方向喔！
		• 192.168.1.11.1190：接收端的 IP 是 192.168.1.11， 且该主机开启 port 1190 来接收； 
		• P 116:232(116)：这个封包带有 PUSH 的数据传输标志， 且传输的数据为整体数据的 116~232
		byte，所以这个封包带有 116 bytes 的数据量；
		• ack 1 win 9648：ACK 与 Window size 的相关资料。
		最简单的说法，就是该封包是由 192.168.1.100 传到 192.168.1.11，透过的 port 是由 22 到 1190 ， 且
		带有 116 bytes 的数据量，使用的是 PUSH 的旗标，而不是 SYN 之类的主动联机标志。 呵呵！不容易看
		的懂吧！所以说，上头才讲请务必到 TCP 表头资料的部分去瞧一瞧的啊！
		再来，一个网络状态很忙的主机上面，你想要取得某部主机对你联机的封包数据而已时， 使用 tcpdump 配
		合管线命令与正规表示法也可以，不过，毕竟不好捉取！ 我们可以透过 tcpdump 的表示法功能，就能够
		轻易的将所需要的数据独立的取出来。 在上面的范例一当中，我们仅针对 eth0 做监听，所以整个 eth0 接
		口上面的数据都会被显示到屏幕上， 不好分析啊！那么我们可以简化吗？例如只取出 port 21 的联机封
		包，可以这样做：
		[root@linux ~]# tcpdump -i eth0 -nn port 21
		tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
		listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
		01:54:37.96 IP 192.168.1.11.1240 > 192.168.1.100.21: . ack 1 win 65535
		01:54:37.96 IP 192.168.1.100.21 > 192.168.1.11.1240: P 1:21(20)  ack 1 win 5840
		01:54:38.12 IP 192.168.1.11.1240 > 192.168.1.100.21: . ack 21 win 65515
		01:54:42.79 IP 192.168.1.11.1240 > 192.168.1.100.21: P 1:17(16)  ack 21 win 65515
		01:54:42.79 IP 192.168.1.100.21 > 192.168.1.11.1240: . ack 17 win 5840
		01:54:42.79 IP 192.168.1.100.21 > 192.168.1.11.1240: P 21:55(34) ack 17 win 5840
		瞧！这样就仅提出 port 21 的信息而已，且仔细看的话，你会发现封包的传递都是双向的， client 端发
		出『要求』而 server 端则予以『响应』，所以，当然是有去有回啊！ 而我们也就可以经过这个封包的流
		向来了解到封包运作的过程。 举例来说：
		1. 我们先在一个终端机窗口输入『 tcpdump -i lo -nn 』 的监听，
		2. 再另开一个终端机窗口来对本机 (127.0.0.1) 登入『ssh localhost』
		那么输出的结果会是如何？
		[root@linux ~]# tcpdump -i lo -nn
		 1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
		 2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes
		 3 11:02:54.253777 IP 127.0.0.1.32936 > 127.0.0.1.22: S 933696132:933696132(0)
		 win 32767 <mss 16396,sackOK,timestamp 236681316 0,nop,wscale 2>
		 4 11:02:54.253831 IP 127.0.0.1.22 > 127.0.0.1.32936: S 920046702:920046702(0)
		 ack 933696133 win 32767 <mss 16396,sackOK,timestamp 236681316 236681316,nop,
		 wscale 2>
		 5 11:02:54.253871 IP 127.0.0.1.32936 > 127.0.0.1.22: . ack 1 win 8192 <nop,
		 nop,timestamp 236681316 236681316>
		 6 11:02:54.272124 IP 127.0.0.1.22 > 127.0.0.1.32936: P 1:23(22) ack 1 win 8192
		 <nop,nop,timestamp 236681334 236681316>
		 7 11:02:54.272375 IP 127.0.0.1.32936 > 127.0.0.1.22: . ack 23 win 8192 <nop,
		 nop,timestamp 236681334 236681334>
		上表显示的头两行是 tcpdump 的基本说明，然后：
		• 第 3 行显示的是『来自 client 端，带有 SYN 主动联机的封包』，
		• 第 4 行显示的是『来自 server 端，除了响应 client 端之外(ACK)，还带有 SYN 主动联机的标
		志；
		• 第 5 行则显示 client 端响应 server 确定联机建立 (ACK)
		• 第 6 行以后则开始进入数据传输的步骤。
		从第 3-5 行的流程来看，熟不熟悉啊？没错！那就是 三向交握 的基础流程啦！够有趣吧！ 不过 tcpdump
		之所以被称为黑客软件之一可不止上头介绍的功能吶！ 上面介绍的功能可以用来作为我们主机的封包联机
		与传输的流程分析， 这将有助于我们了解到封包的运作，同时了解到主机的防火墙设定规则是否有需要修
		订的地方。
		更神奇的使用要来啦！如果我们使用 tcpdump 在 router 上面监听『明码』的传输数据时， 例如 FTP 传
		输协议，你觉得会发生什么问题呢？ 我们先在主机端下达『 tcpdump -i lo port 21 -nn -X 』然后再以
		ftp 登入本机，并输入账号与密码， 结果你就可以发现如下的状况：
		[root@linux ~]# tcpdump -i lo -nn -X 'port 21'
		 0x0000: 4500 0048 2a28 4000 4006 1286 7f00 0001 E..H*(@.@.......
		 0x0010: 7f00 0001 0015 80ab 8355 2149 835c d825 ......... U!I.\.%
		 0x0020: 8018 2000 fe3c 0000 0101 080a 0e2e 0b67 .....<... ......g
		 0x0030: 0e2e 0b61 3232 3020 2876 7346 5450 6420 ...a220.(vsFTPd.
		 0x0040: 322e 302e 3129 0d0a 2.0.1)..
		 0x0000: 4510 0041 d34b 4000 4006 6959 7f00 0001 E..A.K@.@.iY....
		 0x0010: 7f00 0001 80ab 0015 835c d825 8355 215d ......... \.%.U!]
		 0x0020: 8018 2000 fe35 0000 0101 080a 0e2e 1b37 .....5... ......7
		 0x0030: 0e2e 0b67 5553 4552 2064 6d74 7361 690d ...gUSER. dmtsai.
		 0x0040: 0a .
		 0x0000: 4510 004a d34f 4000 4006 694c 7f00 0001 E..J.O@.@.iL....
		 0x0010: 7f00 0001 80ab 0015 835c d832 8355 217f ......... \.2.U!.
		 0x0020: 8018 2000 fe3e 0000 0101 080a 0e2e 3227 .....>... .....2'
		 0x0030: 0e2e 1b38 5041 5353 206d 7970 6173 7377 ...8PASS. mypassw
		 0x0040: 6f72 6469 7379 6f75 0d0a ordisyou. .
		上面的输出结果已经被简化过了，你必须要自行在你的输出结果当中搜寻相关的字符串才行。 从上面输出
		结果的特殊字体中，我们可以发现『该 FTP 软件使用的是 vsftpd ，并且使用者输入 dmtsai 这个账号名
		称，且密码是 mypasswordisyou』 嘿嘿！你说可不可怕啊！如果使用的是明码的方式来传输你的网络数据？
		所以我们才常常在讲啊，网络是很不安全低！
		另外你得了解，为了让网络接口可以让 tcpdump 监听，所以执行 tcpdump 时网络接口会启动在 『错乱模
		式 (promiscuous)』，所以你会在 /var/log/messages 里面看到很多的警告讯息， 通知你说你的网络卡
		被设定成为错乱模式！别担心，那是正常的。 至于更多的应用，请参考 man tcpdump 啰！
		例题：如何使用 tcpdump 监听 (1)来自 eth0 适配卡且 (2)通讯协议为 port 22 ，(3)目标来
		源为 192.168.1.100 的封包资料？
		答：
		tcpdump -i eth0 -nn 'port 22 and src host 192.168.1.100'

	ethereal
		除了 tcpdump 这个软件之外，其实你还可以使用 ethereal 这个好用的网络流量分析软件吶！ ethereal
		分为文字接口与图形接口，文字接口的用法与 tcpdump 相当的类似，不过他的指令名称为 tethereal 就
		是了。因为用法差不多，所以建议您直接使用 man tethereal 查阅吧！ 在 CentOS 上原本就有 ethereal
		了，所以请拿出光盘来安装即可喔！ 需要安装 ethereal 与 ethereal-gnome 才行吶！

	nc, netcat
		这个 nc 可以用来作为某些服务的检测，因为他可以连接到某个 port 来进行沟通， 此外，还可以自行启
		动一个 port 来倾听其它用户的联机吶！非常的不错用！ 如果在编译的时候给予『GAPING_SECURITY_HOLE』
		参数的话，嘿嘿！ 这个软件还可以用来取得客户端的 bash 哩！可怕吧！我们的 CentOS 比较人性化，并
		没有给予上面的参数，所以我们不能够用来作为黑客软件～ 但是用来取代 telnet 也是个很棒的功能了！
		(有的系统将执行文件改名为 netcat 啦！)
		[root@linux ~]# nc [IP|host] [port]
		[root@linux ~]# nc -l -p [port]
		参数：
		-l ：作为监听之用，亦即开启一个 port 来监听用户的联机；
		-p ：开启的这个 port number
		范例一：连接本地端的 port 25 查阅相关讯息
		[root@linux ~]# nc localhost 25
		localhost.localdomain [127.0.0.1] 25 (smtp) open
		220 pc.dm.tsai ESMTP Postfix
		ehlo localhost
		250-pc.dm.tsai
		250-PIPELINING
		250-SIZE 40000000
		250-ETRN
		quit
		221 Bye
		这个最简单的功能与 telnet 几乎一样吧！可以去检查某个服务啦！不过，更神奇的在后面， 我们可以建
		立两个联机来传讯喔！举个例子来说，我们先在 client 端的地方启动一个 port 来进行倾听：
		范例二：激活一个 port 来监听使用者的联机要求
		[root@linux ~]# nc -l -p 20000
		# 启动一个 port 20000 在主机上，如果此时使用 netstat -tlnp
		# 就可以看到系统上多出来一个 port 20000 在倾听使用者的联机喔！
		然后在主机端的地方，也利用 nc 来联机到客户端，并且输入一些指令看看喔！
		[root@linux ~]# nc localhost 20000
		 <==这里可以开始输入字符串了！
		此时，在主机端我们可以打入一些字，你会发现在 client 端会同时出现你输入的字眼吶！ 如果你同时给
		予一些额外的参数，例如利用标准输入与输出 (stdout, stdin) 的话， 那么就可以透过这个联机来作很
		多事情了！ 当然 nc 的功能不只如此，你还可以发现很多的用途喔！ 请自行到您主机内的
		/usr/share/doc/nc-1.10/scripts 目录下看看这些 script ，有帮助的吶！ 不过，如果你需要额外的编
		译出含有 GAPING_SECURITY_HOLE 功能， 以使两端联机可以进行额外指令的执行时，就得要自行下载原始
		码来编译了！

____________________________________________________________

Linux的内核版本有两种：1稳固版2开发版。

Linux内核版本号是由3个数字构成：a.b.c

a：目前发布的内核主版本。
b：偶数表示稳固版本；奇数表示开发中版本。
c：错误修补的次数。

其中第一个数字是主版本号，第二个数字是次版本号，第三个数字是修订版本号。
____________________________________________________________

网络不通的处理流程
	实际上，如果网络不通时，你可以依序这样处理：
	1. 了解问题：这个问题是刚刚发生？还是因为之前我做了什么动作而导致无法联机？
	2. 确认 IP：先看看自己的网卡有无驱动？能否取得正确的 IP 来联机？
	3. 确认区网联机：利用 ping 来沟通两部主机，确定网络线与中继的 hub/switch 工作正常；
	4. 确认对外联机：看主机或 IP 分享器能否依据 连上 Internet 那一章的方法顺利取得 IP 参数，
	并以 ping 的方法确定对外联机是可以成功的；
	5. 确认 DNS 查询：利用 nslookup 或 host 或 dig 检查 www.google.com 看看；
	6. 确认 Internet 节点：可以利用 traceroute 检查各节点是否没问题？
	7. 确认对方服务器正常服务：是否对方服务器忙线中？或他的机器挂了？
	8. 确认我方服务器：是否某些服务没有正确启动？可利用 netstat 检查， 是否某些安全机制的套
	件没有开放，例如 SELinux 这项机制；
	9. 防火墙或权限的问题：是否由于权限设定错误所致？ 是否由于您的机器有防火墙忘记启用可联机
	的埠口所致？这个可以透过 tcpdump 来处理！

	步骤一：网络卡工作确认
	其实，网络一出问题的时候，您应该从自己可以检查的地方检查起，因此， 最重要的地方就是检查您的网
	络卡是否有工作的问题啦！检查网络卡是否正常工作的方法如下：
	1. 确定网络卡已经驱动成功：
	如果网络卡没有驱动成功，其它的，免谈！！所以你当然需要驱动你的网络卡才行！ 确认网络卡
	是否被驱动，可以利用 lspci 先看看有没有捉到 Ethernet 字样的显示信息，再以 dmesg 来检
	查是否被核心侦测到，最后使用 lsmod 看看有没有相对应的模块已被加载。 整个步骤可以参考
	『 连上 Internet - Linux 网络卡』那一个小节， 这里鸟哥不再说明了！ ^_^！不过你要注意的
	是，如果上述的检测方式都无法发现你的网络卡模块， 那肯定就是核心与核心模块不支持你的网
	络卡啊！那该怎办？参考 『 连上 Internet之网卡编译』就对了！
	2. 确定可以手动直接建立 IP 参数：
	在顺利的加载网络卡的模块，并且『取得网络卡的代号』之后，我们可以利用 ifconfig 或 ip 来
	直接给予该网络卡一个网络地址试看看！ 看能否给予 IP 设定呢？例如：
	[root@linux ~]# ifconfig eth0 192.168.1.100
	来直接建立该网络卡的 IP ，然后直接输入 ifconfig 看能否查阅到刚刚设定好的参数即可。 如
	果可以建立起该 IP ，就以 ping 来检测看看：
	[root@linux ~]# ping 192.168.1.100
	如果有响应的话，那表示这个网卡的设定应该是没有问题了！ 再来则是开始检测一下局域网络内
	的各个连接硬件啦！
	Tips:
	事实上要再次的重申，如果您的主机捉不到您主机上的网络卡 (通
	常是内建的网络芯片)， 那么最好买一张便宜的螃蟹卡先来凑合着
	用，『先求有！再求完美』， 不要一开始就挑战自己的耐心啊！
	拜托拜托！
	步骤二：局域网络内各项连接设备检测
	在确认完了最重要的网络卡设定之后，并且确定网络卡是正常的之后， 再接着下来则是局域网络内的网络
	连接情况了！假设您是按照 图一所设定的星形联机局域网络架构，那么你必须要知道整个『网域』的概念！
	1. 关于网域的概念：
	你得清楚的知道图一中各主机与服务器可以互相沟通是因为他们在『同一个网域里面』， 所以，
	你要知道所谓的 192.168.1.0/24 这种网域的表达方式所代表的意义， 且子屏蔽网络 (Netmask)
	的意义也得了解。如果忘记了，请回去网络基础再翻一翻。
	2. 关于 Gateway 与 DNS 的设定：
	Gateway 与 DNS (在 /etc/sysconfig/network-scripts/ifcfg-eth0, /etc/resolv.conf 的设定)
	最容易被搞混～ 这两个并非是填写你的 Linux 主机的 IP 喔！应该是要填写 IP 分享器 (或
	NAT 主机) 的 IP 在 Gateway 中， 填写 168.95.1.1 在 DNS 的 IP 设定当中！不能够搞错啊！
	如果还是不清楚？回去网络基础看看吧！
	3. 关于 Windows 端的工作群组与计算机名称：
	假如您还需要资源共享，那么您就必须在 windows 系统中开放档案分享， 并且建议所有的计算
	机将『工作群组』设定相同，但『计算机名称』则不能相同！
	假设你的区网内所有的主机 IP 都设定正确了，那么接下来你就可以使用 ping 来测试两部区网内主机的
	联机， 这个联机的动作可以让你测试两部主机间的各项设备，包括网络线、Hub/Switch 等等的咚咚！ 如
	果无法测试成功，那就请了解一下：
	1. IP 参数是否设定正确：
	再次强调，先决定 IP 是对的！鸟哥在上课的时候常常发现同学无法连到我的主机上， 一经使用
	ifconfig 才发现他们与我的 IP 不在同一个网段内，就是会有这样的情况发生啊！唉～
	2. 联机的线材问题：
	包括我们前面提到的网络线本身折损、过度缠绕造成的讯号衰减问题等等， 另外，有些比较旧的
	Hub/Switch 或者是 ATU-R (ADSL 调制解调器，俗称的小乌龟是也) 由于没有 Auto MDI/MDIX 的
	功能，所以无法自动的分辨跳线与否， 那么当你插错网络线的时候，也就无法接通啦！这样了解
	乎？另外，早期我们常常会说， 最简单判断每部主机是否顺利连接到 Hub/Switch 可以透过连接
	到 Switch 上的灯号来判断， 不过，由于有时候网络线本身讯号不良，虽然灯号还是会亮，不过
	就是无法连接到 Switch 的情况 (鸟哥自己就曾发生过啊！)，此时，跟朋友借一条 OK 的网络线
	来测试看看吧！
	3. 网卡或 Hub/Switch 本身出问题：
	有一次鸟哥无法在外部连接到鸟哥的主机，怀疑是挂点了，结果冲到主机所在办公室察看，咦！ 主
	机是好好的嘛！那怎么会无法联机呢？原因是.......室内环境通风不良，加上 Switch 所在处温
	度过高， 加上那部旧的 switch 『刚好』风扇坏了，哈！就这样『 switch 当机 』 在重新启动
	switch (拔掉再插上电源线) 后就正常了。所以啰，很多情况都是会发生的， 而局域网络内的环
	境也很容易影响到联机质量啊！
	确定自己主机的 IP 与网卡没有问题，加上内部区网透过 ping 也测试过没有问题， 接下来就是要『取得
	可以对外联机的 IP 参数』啦！这个重要！
	步骤三：取得正确的 IP 参数
	什么叫『取得正确的 IP 参数』啊？还记得我们谈过如果要顺利的连接上 Internet 的话， 必须要可以跟
	public IP 进行沟通才行，而与 public IP 取得沟通的方法，在台湾比较常见的有 ADSL, Cable modem, 学
	术网络, 电话拨接等等，在 CentOS 当中，我们可以透过修改
	/etc/sysconfig/network-scripts/ifcfg-eth0，或者是利用 rp-pppoe 来进行拨接，  无论如何，你就是
	得要连接到某个 ISP 去就是了～在你确认所有的区网没有问题之后， 参考一下连上 Internet 那一章的
	介绍， 连上之后，立即以 ifconfig 看看有没有捉到正确的 IP 啊？ 在台湾如果使用 ADSL 联机的话，
	你应该可以顺利的取得一组正确的 Public IP 参数的！
	Tips:
	曾有国外的华人朋友来信说到，他们使用 ADSL 拨接之后竟然取得
	一组 Private IP ， 害他们没有办法架站！他们想请问这样的情
	况是否合理。如果您熟悉路由相关的概念之后， 当然会知道：『这
	当然合理！』，因为你取得的 IP 只是为了要连接到 ISP 去而已，
	而 ISP 与你的主机当然可以透过 Private IP 来联机啊！如果是
	这样的话，那么您就肯定无法架站了！ ^_^
	另外，最常发现无法顺利取得 IP 的错误就是『BOOTPROTO』这个设定值设定错了！ 因为 static 与 hdcp
	协议所产生的 IP 要求是不一样的啊！还记得吧！ 要特别留在 ifcfg-eth0 里面的设定参数喔！另外，如
	果你是使用 ADSL 拨接的， 但是老是无法拨接成功，那么建议你可以这样试看看：
	• 将 ADSL 的调制解调器 (ATU-R) 整个关机，将 Switch/Hub 也关掉电源；
	• 静待十分钟，等这些设备比较『凉快』一点后，再重新插上电源；
	• 将 Linux 连接到 ADSL 的那块网卡 (假设为 eth0) 在 ifcfg-eth0 内，『ONBOOT』设定为 no，
	重新启动网络 (/etc/init.d/network restart)，然后再执行 adsl-start
	• 如果还是无法拨接成功，并且你已经确认内部网域没有问题，那请中华电信的工程人员来帮忙您
	处理吧！
	因为很多时候都是由于网络媒体过热，也有可能主机内部的一些网络参数有点问题， 所以，干脆就不要启
	动网卡，让 adsl-start 自动去启动网卡即可！ 如果顺利取得 IP 后，却还是无法顺利连到 Internet 上
	面时，你觉得还有哪些地方需要处理的呢？
	步骤四：确认路由表的规则
	如果你已经顺利取得正确的 IP 参数的话，那么接下来就是测试一下是否可以连上 Internet 啊！ 鸟哥建
	议你可以尝试使用 ping 来连连看 Hinet 的 DNS 主机，也就是 168.95.1.1 那部机器啦！
	[root@linux ~]# ping -c 3 168.95.1.1
	如果有响应，那就表示你的网络『基本上已经没有问题，可以连到 Internet 了！』， 那如果没有响应呢？
	明明取得了正确的 IP 却无法连接到外部的主机，肯定有鬼！呵呵！没错！ 还记得我们在网域内资料的传
	输可以直接透过 MAC 来传送， 但如果不在区网内的数据，则需要透过路由，尤其是那个预设路由 (default
	route) 来帮忙转递封包吧！ 所以说，如果你的 public IP 无法连接到外部 (例如 168.95.1.1) ，可能
	的问题就出在路由与防火墙上面了。 假设你没有启动防火墙，那问题就缩小到剩下路由啰～
	那路由的问题如何检查？就用 route -n 来检查啊！
	例题：假设有个使用 ADSL 拨接的 Linux 主机，他的路由表如下，你觉得出了什么问题？
	Destination Gateway Genmask Flags Metric Ref  Use Iface
	59.104.200.1 0.0.0.0 255.255.255.255 UH 0 0  0 ppp0
	192.168.1.0 0.0.0.0 255.255.255.0 U 0 0  0 eth0
	169.254.0.0 0.0.0.0 255.255.0.0 U 0 0  0 eth0
	127.0.0.0 0.0.0.0 255.0.0.0 U 0 0  0 lo
	0.0.0.0 192.168.1.2 0.0.0.0 UG 0 0  0 eth0
	答：
	仔细看到上面的路由输出，第一条是 ppp0 产生的 public IP 接口，第二条是 eth0 的
	内部网域接口，在看到最后一条的 0.0.0.0/0.0.0.0 这个预设路由，竟然是内部网域
	的 eth0 为 gateway ？这不合理，最大的问题应该是出在 ifcfg-eth0 里面不小心设
	定了『GATEWAY=192.168.1.2』所致，解决的方法为：
	1. 取消 ifcfg-eth0 内 GATEWAY=192.168.1.2 那一行，(该行亦可能出现在
	/etc/sysconfig/network 内)
	2. 重新启动网络 /etc/init.d/network restart
	3. 重新进行拨接： adsl-stop; adsl-start
	另外一个可能发生的情况，就是：『忘记设定预设路由』啦！ 例如使用 ifconfig 手动重新设定过网络卡
	的 IP 之后，其实路由规则是会被更新的， 所以预设路由可能就会不见了！那个时候你就得要利用 route
	add 来增加预设路由啰！
	步骤五：主机名称与 IP 查询的 DNS 错误
	如果你发现可以 ping 到 168.95.1.1 这个 Internet 上面的主机，却无法使用浏览器在网址列浏览
	http://www.google.com 的话，那肯定 99% 以上问题是来自于 DNS 解析的困扰！ 解决的方法就是直接到
	/etc/resolv.conf 去看看设定值对不对啊！ 一般常见的内容是这样的：
	[root@linux ~]# vi /etc/resolv.conf
	nameserver 168.95.1.1
	nameserver 139.175.10.20
	最常见的错误是『那个 nameserver 的拼字写错了！』真是最常见的问题～～另外，如果 client 端是
	Windows 系统呢？常常初学者会搞错的地方就是在 windows 的设定了！要注意： Windows 端的 DNS 设定
	与主机端 /etc/resolv.conf 的内容相同即可！ 很多初学者都以为 TCP/IP 内的 DNS 主机是填上自己的
	Linux 主机，这是不对的 (除非您自己的 Linux 上面有 DNS 服务) ！您只要填上您的 ISP 给您的 DNS 主
	机 IP 位置就可以了
	步骤六：Linux 的 NAT 服务器或 IP 分享器出问题
	NAT 服务器最简单的功能就是 IP 分享器啦！NAT 主机一定是部路由器，所以你必须要在 Linux 上面观察
	好正确的路由信息。否则肯定有问题。另外， NAT 主机上面的防火墙设定是否合理？ IP 分享器上面是否
	有设定抵挡的机制等等，都会影响到对外联机是否能够成功的问题点。 关于 NAT 与防火墙我们会在后续
	的章节继续介绍的啦！
	步骤七：Internet 的问题
	Internet 也会出问题喔！当然啦～没有任何东西是不会出问题的！ 举例来说，好几年前台湾西岸因为施
	工的关系，导致南北网络骨干缆线被挖断， 结果导致整个 Internet 流量的大塞车！这就是 Internet 的
	问题～还有，数年前 Study Area 网站放置的地点由于路由器设定出了点差错， 结果导致联机速度的缓慢。
	这都不是主机本身出问题，而是 Internet 上面某个节点出了状况。 想要确认是否问题来自 Internet 的
	话，就使用 traceroute 吧！ 查察看问题是来自那个地方再说！
	步骤八：主机的问题
	如果上述的处理都 OK ，却无法登入某部主机时，我想，最大的问题就是出现在主机的设定啦！ 这包括有：
	• 主机并没有开放该项服务：例如主机关闭了 telnet ，那你使用 telnet 去联机，是无法连接上
	的啦！
	• 主机的权限设定错误：例如你将某个目录设定为 drwx------ ，该目录拥有者为 root ， 你却将
	该目录开放给 WWW 来浏览，由于 WWW 无法进入该目录，所以当然无法正确的给客户端浏览啊！ 这
	是最典型的权限设定错误的情况啊！
	• 安全机制设定错误：例如 SELinux 是用来更细微控管主机存取的一种核心机制， 如果你没有设
	定好就启用的话，那么主机的服务很多都『无法顺利的启用』， 关闭 SELinux 就好了。而其它
	例如 /etc/hosts.deny, PAM 模块等等， 都可能造成使用者无法登入的问题！这就不是网络问题，
	而是主机造成联机无法成功！
	• 防火墙问题：防火墙设定错误也是一个很常见的问题，你可以使用 tcpdump 来追踪封包的流向，
	以顺利的了解防火墙是否设定错误。
	基本上，一个网络环境的检测工作可不是三言两语就讲的完的～而且常常牵涉到很多经验的问题～ 请您常
	常到一些讲座的场合去听听看大家的经验，去 google 看看人家的解决方法， 都有助于让你更轻易的解决
	网络问题的喔！ ^_^
____________________________________________________________

开机启动、关闭服务设置
如何查阅 portmap 这个程序一开机就执行？ (2)如果开机就执行，如何将他改为开
机时不要启动？ (3)如何立即关闭这个 portmap 服务？
答：
1. 可以透过『 chkconfig --list | grep portmap 』与『 runlevel 』确认一下你的环
境与 portmap 是否启动？
2. 如果有启动，可透过『 chkconfig --level 35 portmap off 』来设定开机时不要启
动；
3. 可以透过『 /etc/init.d/portmap stop 』来立即关闭他！
____________________________________________________________

常用的可以需要开机启动的服务
acpid 新版的电源管理模块，通常建议开启，不过，某些笔记型计算机可能不支持此项
服务，那就得关闭
atd 在管理单一预约命令执行的服务，应该要启动的
crond 在管理工作排程的重要服务，请务必要启动啊！
iptables Linux 内建的防火墙软件，这个也可以启动啦！
keytables 如果你的键盘非正规的格式时，这个服务的启动或许可以帮助你喔！
network 这个重要了吧？要网络就要有他啊！
sshd 这是系统预设会启动的，可以让你在远程以文字型态的终端机登入喔！
syslog 系统的登录文件记录，很重要的，务必启动啊！
xinetd 就是那个 super daemon 嘛！所以也要启动啦！
xfs 用来管理 X Window 字形数据的服务，如果你会需要 X Window 时，这个服务要
启动。
____________________________________________________________

• 如何观察您 Linux 主机上面已经有多少 port 被打开了？
1. 如果是 Linux 这个操作系统上面的话，可以利用『 netstat -tunlp 』观察已经在监听的 port
与服务的对应；
2. 如果是想要查阅所有的 port (包含已建立的联机)，可以使用『 netstat -tunp 』来查阅；
3. 如果不在 Linux 本机上，可以用『 nmap IP 』来处理啊！
• 如何观察程序？
利用『 ps -aux 』或『 top 』都可以，另外，『 pstree -p 』则可以了解所有的程序相依性，
而『 lsof 』 则可以察看所有程序所开的档案喔！
• 请问 LISTEN 的 port 与 daemon 的关系为何？
正在 LISTEN 当中的埠口均是由某些服务(daemons)所启动的，所以要启动埠口就得启用某个服
务， 要了解某个埠口是由那个 daemon 所启动的，就利用 netstat -tulp 来查阅。
• 请问 stand alone 与 super daemon 各是什么？
Linux 系统的服务有独立启动(stand alone)及超级服务员(super daemon)两种启动的方式。挂在
super daemon 底下的服务可以经由 super daemon 的控管，以加强一些安全功能，不过由于还要
经过 super daemon 的管理，所以服务的连接速度上会比 stand alone 慢一点。
• 请问您的 Linux 主机 (不论是那个 distributions ) 有关 daemon 启动与关闭的 scripts 与
档案放置在那个目录下？
各个 daemons 的启动与关闭的 scripts 是放置在 /etc/init.d/ 内， Red Hat 系统则是放到
/etc/rc.d/init.d 里面，至于 super daemon 的控管参数档案则在 /etc/xinetd.d 里面！ 
• 为什么阻断式服务 (DDoS) 会造成系统的当机与网络瘫痪？试由三向交握的角度来探讨。
所谓的阻断式服务是利用三向交握程序的漏洞，多个 cient 端持续发送 tcp 封包的联机要求，
但却不理会 server 端的 SYN/ACK 的封包，导致 server 端会持续启动很多的 port 在等待
client 端的回应， 那我们知道一般 port 有 65536 个，万一用完了，那系统网络就瘫痪了！所
以 DDoS 会造成系统网络瘫痪的问题。 另外，由于多个 client 同时要求，所以网络频宽也会被
用光！

____________________________________________________________

nmap
如果你要侦测的设备并没有自己的操作系统，举例来说，你想要了解一下公司的网络打印机是否有开放某
些协议时， 那该如何处理啊？现在你知道 netstat 可以用来查阅本机上面的许多监听中的通讯协议， 那
例如网络打印机这样的非本机的设备，要如何查询啊？呵呵！用 nmap 就对了！
nmap 的套件说明之名称为：『Network exploration tool and security scanner』，顾名思义， 这个东
西是被系统管理员用来管理系统安全性查核的工具！他的具体描述当中也提到了， nmap 可以经由程序内
部自行定义的几个 port 对应的指纹数据，来查出该 port 的服务为何，所以我们也可以藉此了解我们主
机的 port 到底是干嘛用的！如果您是安装 Linux 是 Red Hat 系统的话，那么这个 nmap 套件应该已经
安装妥当了，万一没有这个套件的话，也可以来到底下的网站下载：
• http://insecure.org/nmap/
[root@linux ~]# nmap [扫瞄类型] [扫瞄参数] [hosts 地址与范围]
参数：
[扫瞄类型]：主要的扫瞄类型有底下几种：
 -sT：扫瞄 TCP 封包已建立的联机 connect() ！
 -sS：扫瞄 TCP 封包带有 SYN 卷标的数据
 -sP：以 ping 的方式进行扫瞄
 -sU：以 UDP 的封包格式进行扫瞄
 -sO：以 IP 的协议 ( protocol ) 进行主机的扫瞄
[扫瞄参数]：主要的扫瞄参数有几种：
 -PT：使用 TCP 里头的 ping 的方式来进行扫瞄，可以获知目前有几部计算机存活(较常用)
 -PI：使用实际的 ping (带有 ICMP 封包的) 来进行扫瞄
 -p ：这个是 port range ，例如 1024-, 80-1023, 30000-60000 等等的使用方式
[Hosts 地址与范围]：这个有趣多了，有几种类似的类型
 192.168.0.100 ：直接写入 HOST IP 而已，仅检查一部；
 192.168.0.0/24 ：为 C Class 的型态，
 192.168.*.* ：嘿嘿！则变为 B Class 的型态了！扫瞄的范围变广了！
 192.168.0.0-50,60-100,103,200 ：这种是变形的主机范围啦！很好用吧！
范例一：使用预设参数扫瞄本机所启用的 port
[root@linux ~]# nmap localhost
PORT STATE SERVICE
22/tcp open ssh
25/tcp open smtp
80/tcp open http
139/tcp open netbios-ssn
# 在预设的情况下， nmap 仅会扫瞄 TCP 的协议喔！
nmap 的用法很简单吶！就直接在指令后面接上 IP 或者是主机名称即可。不过，在预设的情况下 nmap 仅
会帮你分析 TCP 这个通讯协议而已，像上面这个例子，他只会帮我列出 4 个已经开启的 TCP 的端口口号
码， 但优点是顺道也将开启该埠口的服务也列出来了，真是好！ ^_^！那如果想要同时分析 TCP/UDP 这
两个常见的通讯协议呢？可以这样做：
[root@linux ~]# nmap -sTU localhost
PORT STATE SERVICE
22/tcp open ssh
25/tcp open smtp
80/tcp open http
137/udp open|filtered netbios-ns
138/udp open|filtered netbios-dgm
139/tcp open netbios-ssn
嘿嘿！与前面的范例比较一下，你会发现这次多了两个 UDP 的埠口，分别是 137 与 138 ， 这样分析好
多了吧！然后，如果你想要了解一下到底有几部主机活在你的网络当中时， 则可以这样做：
[root@linux ~]# nmap -sP 192.168.10.0/24
Host 192.168.10.171 appears to be up.
MAC Address: 00:01:E6:B3:AA:CC (Hewlett-Packard Company)
Host 192.168.10.174 appears to be up.
MAC Address: 00:04:75:FF:CC:DD (3 Com)
Host 192.168.10.175 appears to be up.
MAC Address: 00:0C:6E:BA:11:22 (Asustek Computer)
看到否？你的环境当中有三部主机活着吶！并且该 IP 所对应的 MAC 也会被记录下来， 很不错吧！如果
你还想要将各个主机的启动的 port 作一翻侦测的话，那就得要使用：
[root@linux ~]# nmap 192.168.10.0/24
之后你就会看到一堆 port number 被输出到屏幕上啰～如果想要随时记录整个网段的主机是否不小心开
放了某些服务， 嘿嘿！利用 nmap 配合数据流重导向 (>, >> 等) 来输出成为档案， 那随时可以掌握住
您局域网络内每部主机的服务启动状况啊！ ^_^
请特别留意，这个 nmap 的功能相当的强大，也是因为如此， 所以很多刚在练习的黑客会使用这个软件来
侦测别人的计算机，这个时候请您特别留意， 目前很多的人已经都有『特别的方式』来进行登录的工作！
例如以 TCP_Wrappers (/etc/hosts.allow, /etc/hosts.deny) 的功能来记录曾经侦测过该 port 的 IP！
这个软件用来『侦测自己机器的安全性』是很不错的一个工具，但是如果用来侦测别人的主机， 可是会『吃
上官司』的！特别留意！！
____________________________________________________________

软件安装工具

	• yum：
	CentOS 与 Fedora 所常用的自动升级机制，透过 FTP 或 WWW 来进行在线升级以及在线直接安装
	套件；
	• up2date：
	这是 Red Hat 所使用的自动升级机制，需要注册才能使用，并且依据付费与否而管制其流量；
	• apt：
	最早由 debian 这个 distribution 所发展，现在 B2D 也是使用 apt ，同时由于 apt 的可移植
	性， 所以只要你的 RPM 可以使用 apt 来管理的话，就可以自行建立 apt 服务器来提供其它使
	用者进行在线安装与升级。
	• you：
	所谓的 Yast Online Update (YOU) 是由 SuSE 所自行开发出来的在线安装升级方式， 经过注册
	取得一组账号密码后，就能够使用 you 的机制来进行在线升级。不过如果是免费的版本， 则仅
	有 60 天的试用期！
	• urpmi：
	这个则是 Mandriva 所提供的在线升级机制！


____________________________________________________________

yum

	CentOS 的 yum 自动升级
	我们知道 CentOS 主要是以 RPM 来作为套件的管理机制，那么 RPM 本身就有一些表头数据记录了这个套
	件本身的信息， 包括了相依属性之类的讯息等等， yum 这个咚咚就是藉由分析这些 RPM 套件的表头数据，
	并且将这些表头数据事先记录下来， 当使用者要求升级或者是安装的时候， yum 就会透过分析这些表头
	数据来决定下载的档案， 这些下载的档案当然包括了相依属性的套件了，所以说，yum 已经主动克服了套
	件之间的属性相依问题啰！很棒吧！
	那么 yum 是如何动作的呢？基本上是这样的：
	• 先由设定档判断 yum server 所在处；
	• 连接到 yum server 后，先下载新的 RPM 档案的表头数据；
	• 分析比较使用者所欲安装/升级的档案，并提供使用者确认；
	• 下载使用者选择的档案到系统中的 /var/cache/yum ，并进行实际安装；
	所以说，找到合适的 yum server 是挺重要的一件事啊！
	yum 的设定档
	基本上，在你一安装完 CentOS 之后，系统就主动的帮你建立好 CentOS 的 yum server 设定了， 他的设
	定档在：
	• /etc/yum.conf
	• /etc/yum.repos.d/CentOS-Base.repo
	其中，那个 yum.conf 是主要设定档，可以设定一些环境参数之类的，至于 CentOS-Base.repo 则是主要
	的 yum server 选择的数据，你可以直接修改 CentOS-Base.repo 这个档案即可。 另外，台湾地区的
	CentOS 镜像站台 (mirror) 可以选择义守大学的 FTP 网站， 例如底下的连结：
	• http://ftp.isu.edu.tw/pub/Linux/CentOS/
	截至目前为止 (2006/09/xx)，最新的 CentOS 是 4.4 版，所以上头这个连结你可以进入 4.4 那个目录，
	就能够看到很多 CentOS 提供的各项套件数据了。其中比较重要的两个目录是：『 o s』以及『 update 』 ，
	分别是基础套件以及修补过后的套件啦！既然知道了台湾地区的 FTP 网站后，自然就不需要连接到美国去
	下载档案， 那么联机下载的速度当然就会比较快啦！不过，你就得要自行修改修改设定档了！
	不过 CentOS 官方网站则是建议使用国码来作为镜相网站的选择依据， 如此一来在大版本相同的环境下
	(4.3 -> 4.4) 咱们的 CentOS 是可以自动升级到不同版本中的！ 所以，鸟哥的设定档是改成这个样子的：
	[root@linux ~]# vi /etc/yum.repos.d/CentOS-Base.repo
	[base]
	name=CentOS-$releasever - Base
	mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch
	&repo=os&cc=tw
	# 注意！上面两行是同一行！
	gpgcheck=1
	gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos4
	#released updates
	[update]
	name=CentOS-$releasever - Updates
	mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch
	&repo=updates&cc=tw
	# 注意！上面两行是同一行！
	gpgcheck=1
	gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos4
	......(底下省略).....
	主要是将 mirrorlist 那个变量的最后面加上国码『&cc=tw』就可以了！如果未来有较新的版本时， 那么
	你的 yum 就能够自动升级啰！另外，除了 [base] 与 [update] 之外，其实 CentOS 还提供很多的额外套
	件， 这包括了： addons, extras, centosplus, contrib 等等，这些数据你也可以加入到设定档当中， 来
	帮助你容易安装某些非正规支持的套件数据啊！ ^_^
	另外最要注意的是，在设定档当中所指定的镜像站台 (mirror) 离你越近越好，而且频宽越大越好， 这样
	你就可以比较方便快速的下载啊！而且，你必须已经成功的连结到该镜像站台才行， 否则在执行 yum 时
	会发生某些问题喔！另外，你必须是 root 的身份才能使用 yum 啊！ 也就是说：
	• 你必须使用 root 的身份来执行 yum ；
	• 设定档内指定的镜像站台必须能与你进行网络连接；
	• 镜像站台频宽越大越好，所以选择离你越近的镜像站越好！
	yum 的安装、升级、移除、查询等功能
	yum 可不止能够在线自动升级而已，他还可以作查询、套件群组的安装、整体版本的升级等等，好用的哩！
	先来谈论一下 yum 这个 client 端的指令用法吧：
	[root@linux ~]# yum [option] [工作项目] [套件]
	参数：
	option：主要的参数，包括有：
	 -y ：当 yum 询问使用者的意见时，主动回答 yes 而不需要由键盘输入；
	 --installroot=/some/path ：安装在其它的路径，而不在目前目录树的架构中；
	 对于建立虚拟机器相当有帮助！不过，一般使用者应该用不到。
	[工作项目]：由于不同的使用条件，而有一些选择的项目，包括：
	 install ：指定安装的套件名称，所以后面需接『 套件名称 』
	 update ：进行整体升级的行为；当然也可以接某个套件，仅升级一个套件；
	 remove ：移除某个套件，后面需接套件名称；
	 search ：搜寻某个套件或者是重要关键字；
	 list ：列出目前 yum 所管理的所有的套件名称与版本，有点类似 rpm -qa；
	 info ：同上，不过有点类似 rpm -qai 的执行结果；
	 clean ：下载的档案被放到 /var/cache/yum ，可使用 clean 将他移除，
	 可清除的项目：packages | headers | metadata | cache 等；
	另外，在[工作项目]部分还可以具有整个群组套件的安装方式，如下所示：
	 grouplist ：列出所有可使用的『套件组』，例如 Development Tools 之类的；
	 groupinfo ：后面接 group_name，则可了解该 group 内含的所有套件名；
	 groupinstall：这个好用！可以安装一整组的套件群组，相当的不错用！
	 更常与 --installroot=/some/path 共享来安装新系统
	 groupupdate ：升级整个套件群组；
	 groupremove ：移除某个套件群组；
	范例一：搜寻 CentOS 的更新主机上是否有 RAID 磁盘阵列相关套件？
	[root@linux ~]# yum search raid
	.....前面省略.....
	mdadm.i386 1.6.0-3  base
	Matched from:
	mdadm controls Linux md devices (software RAID arrays)
	mdadm is used to create, manage, and monitor Linux MD (software RAID)
	.....后面省略.....
	# 看到否？输出数据的特殊字体那一行就显示了你可以安装的套件名称然后你可以这样：
	[root@linux ~]# yum info mdadm
	Name : mdadm
	Arch : i386
	Version: 1.6.0
	Release: 3
	Size : 84 k
	Repo : base
	Summary: mdadm controls Linux md devices (software RAID arrays)
	Description:
	.....后面省略.....
	# 瞧一瞧啊！套件的版本名称、数据大小、还有该套件出处 (base)！
	# 需要注意看的是 Summary 与 Description 这两个注意事项内容！
	yum 真是个很好用的东西，他可以直接查询是否有某些特殊的套件， 你可以利用『 yum search "一些关
	键词" 』或者是『 yum list 』列出所有的套件名称， 然后再以正规表示法取得关键词，或者是『 yum list
	"套件名称" 』 就能够知道该套件的用途， 最后再决定要不要安装啊！上面的范例一就是在找出磁盘阵列
	的管理软件， 如果确定要安装时，那就可以这样处理：
	范例二：安装某个套件吧！以 mdadm 为例：
	[root@linux ~]# rpm -q mdadm
	package mdadm is not installed
	# 鸟哥的主机并没有安装这个玩意儿～所以底下开始安装先！
	[root@linux ~]# yum install mdadm
	Setting up Install Process
	Setting up repositories
	update 100% |=========================| 951 B 00:00
	base 100% |=========================| 1.1 kB 00:00
	addons 100% |=========================| 951 B 00:00
	extras 100% |=========================| 1.1 kB 00:00
	# 上面这个阶段在读取 RPM 档案的文件头数据；
	--> Populating transaction set with selected packages. Please wait.
	---> Downloading header for mdadm to pack into transaction set.
	mdadm-1.6.0-3.i386.rpm 100% |=========================| 8.2 kB 00:00
	---> Package mdadm.i386 0:1.6.0-3 set to be updated
	--> Running transaction check
	# 上面这个阶段则是在下载档案以及准备更新的阶段
	Dependencies Resolved
	=============================================================================
	 Package Arch Version Repository Size
	=============================================================================
	Installing:
	 mdadm i386 1.6.0-3 base  84 k
	Transaction Summary
	=============================================================================
	Install 1 Package(s)
	Update 0 Package(s)
	Remove 0 Package(s)
	Total download size: 84 k
	Is this ok [y/N]: y
	# 至于这个阶段则在分析相依属性，并且让使用者确认下载开始
	wnloading Packages:
	(1/1): mdadm-1.6.0-3.i386 100% |=========================| 84 kB 00:00
	Running Transaction Test
	Finished Transaction Test
	Transaction Test Succeeded
	Running Transaction
	 Installing: mdadm ######################### [1/1]
	Installed: mdadm.i386 0:1.6.0-3
	Complete!
	# 最终则下载与安装的结果！
	瞧！经过 yum 我们可以很轻松的就安装好一个软件，并且这个软件已经主动的帮我们做好相依属性的克服
	了， 真是方便到爆！另外，你必须要知道，刚刚那个被下载安装的 mdadm 档案被放置到 /var/cache/yum
	里面去了， 如果你要节省硬盘空间的话那么可以在安装完毕后将该档案移除，就用：
	[root@linux ~]# yum clean packages
	Cleaning up Packages
	2 packages removed
	这样就能够清除掉已下载的档案啰～节省一下硬盘空间啊！OK～那如何进行整体的更新呢？ 比如说鸟哥刚
	刚装完了 CentOS 4.3 ，但这个版本已经推出若干时间，所以也已经作了很多更新了， 那鸟哥如何整体更
	新啊？很简单，就用如下的指令：
	[root@linux ~]# yum -y update
	加一个『 -y 』的参数可以让系统自动帮你回答『 yes 』，在背景处理时会比较方便一点。 如果你是第
	一次执行，那就会发现：哇！怎么下载的数据量到达数百 MB 之谱！没错啊！ 所以记得 /var/ 这个目录
	的容量要给大一点才行！ 否则就会出现无法完整下载所有更新档案的问题啊！ @_@
	• 安装套件群组的功能
	什么是『套件群组』呢？还记得在安装的时候有出现套件选择的地方吧？ 在那个时候你选择的数据可不是
	『套件名称』喔，而是一堆『套件群组』，举例来说， 你会看到『KDE 桌面环境』之类的，而不是每个 KDE
	桌面的各项套件名称，对吧！那个咚咚就是『套件群组』啦！ 由于各大 distributions 预设都没有选择
	发展工具 (Development Tools)， 这些工具包含了 gcc, kernel-devel 等等，那么你如何使用 yum 一口
	气安装呢？ 看看底下的范例：
	范例三：查询与安装『套件群组』
	[root@linux ~]# yum grouplist
	Installed Groups:
	 Administration Tools
	 Authoring and Publishing
	 Compatibility Arch Support
	.....中间省略.....
	Available Groups:
	 Development Tools
	 XFCE-4.2
	.....中间省略.....
	Done
	# 看到没！上面就列出来你已经安装的套件群组，还有尚可安装的其它套件群组，
	# 真是非常的方便！那么如何知道 Development Tools 里面有啥咚咚？
	[root@linux ~]# yum groupinfo "Development Tools"
	Group: Development Tools
	 Required Groups: <==所需要的相依属性数据
	 Development Libraries
	 Default Metapkgs: <==预设内部所需要的中继套件
	 Emacs
	 Optional Metapkgs: <==最好还含有这些套件较佳
	 Ruby
	 XEmacs
	.....中间省略.....
	 Mandatory Packages: <==一些所需要的套件数据
	 pkgconfig
	 gcc-ppc32
	 make
	 gcc
	 autoconf
	.....中间省略.....
	 Default Packages:
	 gcc-g77
	 cscope
	.....中间省略.....
	 Optional Packages
	 dejagnu
	 ElectricFence
	 gcc-gnat
	.....中间省略.....
	# 总共会列出来这个『套件群组』内含有的各项资料，如果你需要安装的话，就可以：
	[root@linux ~]# yum groupinstall "Development Tools"
	利用这个『 yum groupinstall "套件群组名" 』可以让你一口气安装很多的套件， 而不必担心某个套件
	忘记装了！实在是很不错啦～而且利用 groupinfo 的功能你也可以发现一些不错的套件数据， 如此一来，
	你就可以更方便的管理你的 Linux 系统了，很不错吧！
	例题：请设定一下工作排程，让你的 centOS 可以每天自动更新系统
	答：
	可以使用『 crontab -e 』来动作，也可以编辑『 vi /etc/crontab 』来动作，由于
	这个更新是系统方面的，所以鸟哥习惯使用 vi /etc/crontab 来进行指令的说明。其
	实内容很简单：
	40 5 * * * root yum -y update && yum clean packages
	这样就可以自动更新了，时间订在每天的凌晨 5:40 ，并且更新完成后会主动的将下
	载的套件数据移除喔！
	不同版本间的升级
	什么！不同的版本之间可以直接『网络』升级了喔？没错！而且整个流程还挺简单的， 升级完成之后，绝
	大部分的服务都还不会有困扰！真是很不错啊！那什么是『不同版本？』举例来说， CentOS 4.2 升级到
	CentOS 4.3 算是一种，而 Fedora Core 1 升级到 CentOS 4.3 则又是另外一种， 同样是 CentOS 的升级
	比较容易，尤其 4.3 本来就是架构在 4.2 上面持续发展的结果； 不过如果是 Fedora Core 的话，可能
	就比较麻烦一点点。底下我们分别谈一谈这两种方式的升级吧！
	• CentOS 4.2 升级到 CentOS 4.3
	在 CentOS 的发展理念当中，如果推出了 4.3 ，那么 4.2 以前的 4.x 版本就不会继续发展， 所以使用
	者必须要将原本的 4.2 直接提升到 4.3 才行。那么需要作些什么动作呢？ 不需要啊！只要修改一下 yum
	的设定档就好了。首先，同样需要找到最近的镜像站台， 我们依旧以义守大学的 FTP 网站来提供所需要
	的套件数据，修改成这样：
	1. 先修改 /etc/yum.conf
	[root@linux ~]# vi /etc/yum.conf
	.....前面省略.....
	# 直接在档案的最底下加入这一行来增加一些额外的功能：
	plugins=1
	2. 再修改 /etc/yum.repos.d/CentOS-Base.repo
	[root@linux ~]# vi /etc/yum.repos.d/CentOS-Base.repo
	# 内容与『 yum 的设定档』说明相同，请回到本小节的最前面查阅该设定
	因为 /etc/yum.repos.d/CentOS-Base.repo 的内容与前面相同， 所以鸟哥在这里不再浪费篇幅，请往前
	翻阅吧！设定好了之后，接下来给他进行：
	[root@linux ~]# yum upgrade
	记得是『 upgrade 』而不是『 update 』喔！两者用法不同啊！ 然后接下来就是一段时间的等待啊！没
	办法，因为从网络上面捉数据下来是需要时间的！ 还好鸟哥的环境是在学术网络内，所以连结同样是学术
	网络的义守大学还挺快的就是了！ ^_^！ 整个升级的时间大约花费 20 分钟以内，升级完毕之后，重新开
	机瞧一瞧登入画面！哇！变成 CentOS 4.3 了， 真是快速又方便！而且原本有启动的服务几乎没有任何问
	题，同样可以正常的启动吶！^_^
	上面的动作你可以参考底下这一篇官方说明文件：
	• http://www.centos.org/modules/news/article.php?storyid=118
	• Fedora Core Release 1 升级到 CentOS 4.3
	如果你使用的是旧版的 Linux distributions ，例如 Fedora core release 1, Red Hat 9 等等的系统，
	这些系统已经旧到没有什么更新的软件出来，所以如果套件有臭虫而需要更新时， 你可能就得要使用
	Tarball 的方式手动的给他『 configure, make, make install 』等等的， 好累啊～那如果我安装 CentOS
	呢？如果需要主动重新安装的话，那旧的数据不是会不见吗？ 又得要备份，重新处理等等的，还是很累啊！
	没关系！有 yum 就搞定了！你可以将你的 FC1 升级到 CentOS 4.3 了，而且是『在线更新』喔！ 厉害吧！
	不过，因为 FC1 使用的核心是 2.4 版，但 CentOS 4.3 使用的是新的 2.6.x ， 这两种核心可不能互相
	更新啊！所以啰，我们还需要一些额外的动作来进行升级，而不像前面 CentOS 4.2 升级到 4.3 那么简单！
	鸟哥底下的动作是参考这几篇：
	• twu2 兄提供的不同版本间升级： http://phorum.study-area.org/viewtopic.php?t=28648
	• CentOS 官方网站提供的一些升级建议：
	http://www.centos.org/modules/newbb/viewtopic.php?topic_id=428&forum=6
	http://www.centos.org/modules/newbb/viewtopic.php?topic_id=382
	鸟哥底下以 FC1 为例来进行整个升级的动作，不过你得要了解的是，每个人的 Linux 都不相同， 因此虽
	然鸟哥实作是成功的，不过不代表你的环境一定会成功， 所以，重点是....『请做好备份！』 以免升级
	不成功时，导致整个数据的损毁，那就得不偿失了！
	0. 前处理：先准备好你的数据，以及删除不需要的数据
	[root@linux ~]# yum clean packages headers
	# 先删除原本的 yum 数据，因为 FC1 使用的也是 yum ，
	# 所以最好先将之前 FC1 的 yum 数据删除，比较不会有问题；
	在这个步骤当中，你最好先将一些重要数据备份起来，包括 /etc 与 /home 整个目录， 还有其它你有开
	启的服务的数据，包括 MySQL 或者是 WWW 的网页数据等，请自行备份喔。 另外，我们的 yum 预设是将
	下载的套件通通放置到 /var/cache/yum 当中，所以你的 /var 目录所在 partition 的容量也需要至少
	1GB 以上的容量，而且安装软件所在目录 /usr 所在的 partition 最好也能够有 2GB 以上的空间，否则
	容易出现空间不足的错误讯息而无法继续。
	那如果真的空间不足怎么办？你可以将一些不需要的套件先移除啊！举例来说， 你可以利用『 yum
	groupremove "Development Tools" 』之类的指令先将这些不是必备的套件群组移除， 以及其它 X 相关
	的套件也可以先移除，等到升级完毕后再以 yum 来重新安装即可， 这样可以节省很多升级时分析相依属
	性所花费掉的时间喔！
	同时你得要确认你的镜像站台，以及 CentOS 的数字签章档案已经安装到 RPM 数据库当中才行， 同样的，
	鸟哥还是以义守大学的 FTP 站为主要的来源镜像站，但是你必须要先取得一些 RPM 相关的档案， 这些档
	案由于会与 FC1 原本的套件产生不相符合的特性，所以需要先捉下来并且强制安装才行！ 请你自行连上：
	• http://ftp.isu.edu.tw/pub/Linux/CentOS/
	然后选择最新的版本，例如鸟哥使用 4.3 (2006/08/10 以前) 这个版本，所以直接点选他， 然后依序选
	择『os』->『i386』->『CentOS』->『RPMS』，然后下载底下这些档案 (注：套件的版本号码可能会有些
	不同喔！)：
	• centos-release-4-3.2.i386.rpm
	• centos-yumconf-4-4.5.noarch.rpm
	• kernel-2.6.9-34.EL.i686.rpm
	• udev-039-10.12.EL4.i386.rpm
	假设我的这些档案捉下来后放到 /root 下，那接下来的动作是：
	1. 安装升级所需要的 RPM 档案：
	[root@linux ~]# rpm --import \
	> http://ftp.isu.edu.tw/pub/Linux/CentOS/4.3/os/i386/RPM-GPG-KEY-centos4
	[root@linux ~]# rpm -Uvh centos-release-4-3.2.i386.rpm
	[root@linux ~]# rpm -Uvh centos-yumconf-4-4.5.noarch.rpm
	[root@linux ~]# rpm -ivh --force --nodeps kernel-2.6.9-34.EL.i686.rpm
	# 在这个动作时，由于我们的核心并非是 CentOS ，所以这个动作会发生一些错误，
	# 先不要理他，待会儿的动作再重新处理即可。
	[root@linux ~]# rpm -ivh --force --nodeps udev-039-10.12.EL4.i386.rpm
	由于 kernel 2.6 使用的装置管理是以 udev 这个套件来处理的，与原本的 kernel 2.4 并不相同， 为了
	避免使用者进行错误的安装，所以 yum 会主动的分析核心与装置管理套件的差异， 如果两者无法配合就
	产生错误讯息且强制中断 yum ，那结果就是导致无法以 yum 进行升级啦！ 要躲过这个困扰，你就得要先
	手动的安装上头那几个 RPM 档案。同时安装 kernel 的过程当中会发生错误讯息， 先不要理他，等到后
	续步骤再来重新处理即可！ 既然 kernel 2.6 会与 2.4 版冲突，而鸟哥的原本的 FC1 本来就有 2.4 版
	的核心嘛！ 那即使安装了新的 kernel-2.6.9-34.EL.i686.rpm 核心，但核心版本冲突的问题还是没有解
	决的， 所以啊，你就得要这样做了：
	2. 移除会有冲突的 2.4 版核心，连同其原始码
	[root@linux ~]# rpm -qa | grep kernel
	kernel-2.4.22-1.2197.nptl
	kernel-2.4.22-1.2115.nptl
	kernel-2.4.22-1.2199.nptl
	kernel-source-2.4.22-1.2197.nptl
	kernel-source-2.4.22-1.2199.nptl
	.....其它省略.....
	[root@linux ~]# rpm -e kernel-source-2.4.22-1.2199.nptl
	[root@linux ~]# rpm -e kernel-source-2.4.22-1.2197.nptl
	[root@linux ~]# rpm -e kernel-2.4.22-1.2115.nptl
	[root@linux ~]# rpm -e kernel-2.4.22-1.2197.nptl
	[root@linux ~]# rpm -e kernel-2.4.22-1.2199.nptl
	# 反正就是找到核心与核心原始码的套件后，就将他移除！记得套件名为：
	# kernel 与 kernel-source ，其它的不用动！
	[root@linux ~]# rpm --rebuilddb
	将一些旧版本的核心给他移除后，你的系统就只有剩下刚刚安装的那个 CentOS 的新核心， 所以核心版本
	的冲突当然就不存在了。要注意的是，你现在绝不可重新开机，否则你的系统就挂了！ 因为没有核心了喔！
	切记切记！然后开始要设定好升级时要使用的 yum 设定档了！
	3. 规范设定档
	[root@linux ~]# vi /etc/yum.upgrade
	[main]
	cachedir=/var/cache/yum
	debuglevel=2
	logfile=/var/log/yum.log
	pkgpolicy=newest
	distroverpkg=fedora-release
	installonlypkgs=kernel kernel-smp kernel-hugemem kernel-unsupported
	tolerant=1
	exactarch=1
	plugins=1
	[upgrade]
	name=CentOS-4.3 - upgrade
	baseurl=http://ftp.isu.edu.tw/pub/Linux/CentOS/4.3/os/i386/
	[update]
	name=CentOS-4.3 - Updates
	baseurl=http://ftp.isu.edu.tw/pub/Linux/CentOS/4.3/updates/i386/
	设定文件里面先只要有这两个项目即可，因为我们仅注视在整体版本的升级， 所以其它的额外功能部分先
	不要理他！以后再来处理即可啊！接下来就准备要升级了！这样做吧：
	4. 开始升级的动作：
	[root@linux ~]# yum -y -t -c /etc/yum.upgrade upgrade
	理论上，如果你的 FC1 没有安装什么奇怪的软件，而且『硬盘空间也足够』 ，那么 yum 应该会开始帮你
	一个一个的下载软件并且分析属性相依问题后，就开始进行安装的步骤。 不过，如果发现一些软件冲突的
	问题时，那么你就得要先以 rpm -e 将旧的软件先移除， 等到升级完毕后再安装回来即可。只不过这个动
	作将依你的环境而有所不同。 鸟哥的 FC1 实在是旧的可以，所以很多软件都有冲突，因此事先移除了很
	多的套件， 忙了快要半小时后，系统才顺利的开始进行安装。由于鸟哥主机所在环境的网络下载的速度尚
	可而已， 所以由开始下载到升级完毕，大概花了一个半小时左右！ @_@
	5. 重新安装核心，并处理 RPM 数据库与更新其它套件
	[root@linux ~]# rpm -ivh --force --nodeps kernel-2.6.9-34.EL.i686.rpm
	[root@linux ~]# rpm --rebuilddb
	[root@linux ~]# yum update
	透过这三个指令我们可以再将刚刚没有完成的核心安装一遍，同时再以新的 yum 来进行升级， 这个时候
	我们的系统应该是很 OK 的啦！不过，有的小问题，那就是『开机的设定档还没有更新』喔！ 所以你还得
	要这样做：
	6. 设定开机设定档
	[root@linux ~]# vi /boot/grub/menu.lst
	default=0
	timeout=10
	splashimage=(hd0,0)/boot/grub/splash.xpm.gz
	title CentOS (2.6.9-34.0.2)
	 root (hd0,0)
	 kernel /boot/vmlinuz-2.6.9-34.0.2.EL ro root=/dev/hda1 hdd=ide-scsi rhgb
	 initrd /boot/initrd-2.6.9-34.0.2.EL.img
	title CentOS (2.6.9-34.EL)
	 root (hd0,0)
	 kernel /boot/vmlinuz-2.6.9-34.EL ro root=/dev/hda1 hdd=ide-scsi rhgb
	 initrd /boot/initrd-2.6.9-34.EL.img
	在今日 (2006/08/10) 能够安装的最新核心版本是 2.6.9-34.0.2.EL ，所以上面的第一个 title 才会是
	这样的设定数据，要记得与你的环境符合啊(如果你不是使用 4.3 来升级)！如果忘记上面各项数据的意义，
	请参考『 鸟哥的 Linux 私房菜 基础篇 boot loader 』的介绍啊！ 如果设定好了这个开机信息，嘿嘿！
	请重新开机试看看吧！ ^_^
	基本上这样已经处理完毕了！也就是说，你的系统应该是由 FC1 顺利的转成 CentOS 4.3 才对！ 不过，
	有些小细节你依旧需要注意喔：
	• 观察您的系统是否有启动原有的服务，亦可利用 chkconfig --list；
	• 如果你的旧系统曾有使用 tarball 的方式来安装软件，则升级完毕后你必须要重新安装一次该软
	件；
	• 系统可能会产生很多的 .rpmnew 的档案，请使用 locate 搜寻，并且重新处理设定档。
	毕竟之前的版本太旧了，所以 RPM 升级时会将新套件的设定档存成 *.rpmnew ， 你最好不要使用旧的设
	定档，而是以新的设定档来重新修改比较好！这样服务的运作应该会比较顺畅一些啊！ 到此为止，恭喜您
	啊！ ^_^
____________________________________________________________

apt

	Debian 的 apt 自动升级：以 B2D 为例
	APT 最早是 debian 这个社群的 Linux distribution 用来作为套件管理的一项机制， 后来实在很方便又
	好用，所以就被利用来做为其它 distributions 的在线升级管理机制了！ 所以你会在很多地方看到有 FC
	系列的 APT 服务器、或者是自订的 APT 服务器等等的。 这个 APT 的使用与 yum 很类似吶！同样也是透
	过套件的表头分析后，然后与系统本身数据比对， 因此同样也克服了属性相依的困扰了，非常方便！底下
	我们就分别来谈一谈吧！
	APT 的设定档
	如同前面提到的 yum 一样，既然是在线升级，那么我们自然得要找到相对应的服务器啰！ 而一般有提供
	apt 服务的 distributions 事实上他们都已经做好设定档内相关的服务器选择了， 例如 B2D 就是一个例
	子。不过， 如果你是使用类似 Red Hat 9, Fedora Core Release 等版本的话， 可能由于种种原因让你
	不能将该主机升级到类似 CentOS 等较新的版本时，那你就可以尝试到底下的网站找找看 APT 主机了：
	• http://apt.freshrpms.net/
	找到属于你的 Linux 版本后，安装 apt 就可以使用 apt 服务器所提供的套件升级机制啰！ 底下赶紧谈
	一谈，那么如何处理 APT 的设定档呢？ APT 的设定文件都放在 /etc/apt 目录下，而在该目录下，规范
	APT 主机的设定则放到 /etc/apt/sources.list 当中。 以 B2D 为例，他的 sources.list 是这样的：
	1. 先处理 APT 服务器来源的设定数据：
	[root@linux ~]# vi /etc/apt/sources.list
	deb ftp://debian.tnc.edu.tw/pub/debian/ stable main non-free contrib
	deb http://security.debian.org/ sarge/updates main contrib non-free
	deb ftp://debian.tnc.edu.tw/pub1 b2d/
	deb http://ftp2.de.debian.org/debian-volatile sarge/volatile main
	# 上面的格式是这样的：
	# <deb 的标头格式> <APT 服务器网址> <相对网址路径> <目录一> <目录二> ...
	其实设定档的内容很简单，第一个字段指的是『用哪一种套件管理员』的意思，主要有 deb 以及 rpm 还
	有 rpm-src 等，deb 是 debian 专属的套件管理方式啦！ ^_^！第二栏以后就得要一起看才行！ 以上表
	的第一行为例，其实他是说，提供 deb 的网址有三个，分别是：
	• ftp://debian.tnc.edu.tw/pub/debian/stable/main
	• ftp://debian.tnc.edu.tw/pub/debian/stable/non-free
	• ftp://debian.tnc.edu.tw/pub/debian/stable/contrib
	这样看懂了吗？第二栏与第三栏要加在一起，那就是个完整的服务器网址！ 后面接的几个数据则是在该网
	址底下的数个目录，那就很容易看懂了吧！ ^_^ 应该是不难啦～如果您是使用 b2d 的话，那恭喜你！不
	用修改就能用 apt 啰！ ^_^
	Tips:
	事实上， /etc/apt/apt.conf 还可以提供其它额外的设定喔，例
	如使用 Proxy 以及规范下载后的套件在安装完毕后应该进行的处
	理步骤，举例来说，是否需要将该套件移除！ 你应该要使用 man
	apt.conf 查询一下该档案的用法喔！
	实际使用 APT
	APT 的使用也实在是很简单！只要利用 apt-get 即可！不过，不同于 yum 每次都会进行 RPM 档案表头的
	分析， APT 则是将套件表头的下载与实际的安装分成两个动作分别执行，先来谈一谈 apt-get 这个指令
	的用法吧！
	[root@linux ~]# apt-get [-qy] [-c config_file] [更新项目] [套件名称]
	参数：
	-q ：不要在屏幕上输出讯息，常用在背景环境的执行当中喔！
	-y ：自动在进行 apt-get 时回答 y 的响应；
	-c ：后面接的是设定文件，一般系统会主动的以 /etc/apt 内的设定档为依据。
	[更新项目]：要 apt-get 进行的工作，主要有这几项：
	 update ：就是更新服务器与客户端的套件表头清单，这个动作务必要进行！
	 install ：后面需要加上要安装的套件名称才行！
	 upgrade ：进行『已安装套件』的完整升级，不过未安装套件则不予安装；
	 dist-upgrade：以 upgrade 相似，但是当新版本的套件有其它相依属性的套件加入时，
	 单纯的 upgrade 将无法进行安装，此时就得要使用 dist-upgrade 了！
	 clean ：清除已经下载到 /var/cache/apt/archives/ 的套件档案。
	 remove ：移除某个套件啊！
	范例一：进行套件标头更新后，进行整体套件的更新动作
	[root@linux ~]# apt-get update
	下载:1 ftp://debian.tnc.edu.tw stable/main Packages [3349kB]
	下载:2 http://ftp2.de.debian.org sarge/volatile/main Packages [3893B]
	.....中间省略.....
	读取 3868kB 用了 24s (159kB/s)
	读取套件清单中... 完成
	[root@linux ~]# apt-get dist-upgrade
	读取套件清单中... 完成
	了解套件依存关系中... 完成
	筹划升级套件中...完成
	下列的套件都将被【删除】：
	 blt-common ettercap-plugins libgdbmg1-dev
	下列的【新】套件都将被安装：
	 dictionaries-common ettercap-common .....后面省略.....
	下列的套件都将维持旧版本:
	 fontconfig libxft-dev libxft2 libxft2-dbg .....后面省略.....
	下列的套件都将更新:
	 apache apache-common apache-utils apache2 .....后面省略.....
	更新 105 个套件，新安装 32 个套件，删除 3 个套件，另不更新 7 个套件。
	需要下载 122MB 的档案。
	解压缩后将消耗 39.6MB 的空间。
	继续执行吗？ 是按 [Y] 键，否按 [n] 键 y
	下载:1 ftp://debian.tnc.edu.tw stable/main libc6-dev 2.3.2.ds1-22sarge3 [2535kB]
	下载:2 http://security.debian.org sarge/updates/main login 1:4.0. 3-31sarge8 [576kB]
	.....中间省略.....
	读取 122MB 用了 11m47s (172kB/s)
	正在预先设定套件 ...
	(正在读取数据库 ... 系统目前总共安装有 112550 个档案和目录。)
	正预备替换 libc6-dev 2.3.2.ds1-22 (使用 .../libc6-dev_2.3.2.ds1-22sarge3_i386.deb)
	正在解压缩替换的套件档 libc6-dev ...
	.....中间省略.....
	Please *restart* your Apache2 !
	Y/N ?
	y
	.....中间省略.....
	[root@linux ~]# apt-get clean
	# 这个动作会将刚刚下载的几个 deb 的套件给他移除！节省硬盘空间！
	请记得，那个 update 的参数并不是在进行更新， 而是在进行服务器与客户端的套件表头清单更新而已，
	但这个动作相当重要，如果你没有作这个动作的话，你的套件就不会更新了！ 在 apt-get update 后，再
	使用 apt-get dist-upgrade 这样就能够将整个系统给他升级了！很快乐吧！不过，由于我们没有加上『-y』
	这个参数， 所以在上表当中，我们会老是需要输入一些有的没有的指令， 这样的话，就不适合作为背景
	的自动升级了！所以，如果你想要在背景以 crontab 的方法自动的帮你升级的话，在 B2D 的环境下使用：
	[root@linux ~]# vi /etc/crontab
	40 5 * * * root /usr/bin/apt-get update && /usr/bin/apt-get -y dist-upgrade
	这样每天的凌晨 5:40 就会自动的进行整体升级，而且会主动的克服相依属性的问题喔！ 另外，除了完整
	的将套件给他全部升级之外，我们还可以利用 apt 服务器的功能来进行查询的动作喔！ 这个时候就得要
	apt-cache 来帮忙了！
	[root@linux ~]# apt-cache [搜寻项目]
	参数：
	[搜寻项目]：apt-cache 可以搜寻 apt 所列出的套件标头数据喔！可用项目有：
	pkgnames：列出本系统上面的所有套件名称！！有点类似 (rpm -qa)；
	dump ：列出所有的套件标头以及其相关的相依属性套件！
	search ：后面可接要搜寻的字符串，例如 apt-cache search postfix
	show ：后面接套件名称，可以显示出该套件的主要内容的描述！
	showpkg ：列出后面所接套件的相依属性以该其套件提供的相关功能！
	depends ：可以列出与后面所接套件有相依属性或者是冲突的相关数据！
	范例一：找出与 grep 有关的套件
	[root@linux ~]# apt-cache search grep
	.....前面省略.....
	grep - GNU grep, egrep and fgrep
	grep-dctrl - Grep Debian package information
	.....后面省略.....
	[root@linux ~]# apt-cache show grep
	Package: grep
	Essential: yes
	Priority: required
	Section: base
	Installed-Size: 660
	Maintainer: Ryan M. Golbeck <rmgolbeck@debian.org>
	Architecture: i386
	Version: 2.5.1.ds1-4
	Provides: rgrep
	Pre-Depends: libc6 (>= 2.3.2.ds1-4)
	Conflicts: rgrep
	Filename: pool/main/g/grep/grep_2.5.1.ds1-4_i386.deb
	Size: 170290
	MD5sum: 68196ad14b098b0eb4b91f4a7cfa8ff2
	Description: GNU grep, egrep and fgrep
	 'grep' is a utility to search for text in files; it can be used from the
	 command line or in scripts. Even if you don't want to use it,  other packages
	 on your system probably will.
	[root@linux ~]# apt-cache depends grep
	grep
	 特别依存关系: libc6
	 冲突: <rgrep>
	瞧！利用 apt-cache 就能够找到很多有用的信息！包括利用 show 这个参数也能够将该套件重要的项目给
	他列出来！ 以上面的 grep 这个套件为例， apt-cache 就列出很多例如版本信息、冲突信息 (conflicts)
	等等， 尤其是描述 (Description) 的部分，就更可以让使用者了解该套件的用途了！ ^_^！另外， 那个
	depends 则可以特别列出与该套件有冲突或者是相依属性的文件名称！也是个很有帮助的参数喔！ 至于如
	果你想要安装一个套件的话，例如 zlibc 这个套件时，就可以这样做：
	[root@linux ~]# apt-get install zlibc
	如同前面提到的，如果你原本的系统并不是使用 apt 来进行在线升级的机制，而你想要使用 apt 的话， 目
	前很多服务器都有提供相对应版本的升级，其中以 RPM 套件管理的 Red Hat 与 Fedora 最常见！ 台湾杨
	锦昌老师也提供了完整的 APT 教学，您可以看看：
	• http://163.19.59.1/~linux/student_samba/apt/apt_server.html
	当然，还是那句老话，除非您的主机上面有专属的软件需要该版本的 distribution 才能执行， 当转成其
	它版本可能会发生无法执行的困扰时，那你只好使用旧版的 distribution， 并且找到对应的 APT 或 yum
	服务器，或者是『你自己建立一个 APT/yum 服务器』来提供自己升级！ 比较能够免除一些程序臭虫的困
	扰。如果没有以上的困扰，那就直接升级到比较新的版本吧！ 『比较新的版本不一定比较好，不过，在大
	部分的情况下， 较新版本对硬件的支持以及安全性方面，都会比较好一些。』但是，如果你的主机明明运
	作的很好， 短期你也不需要什么新硬件的增加，而且你自己有在注意各个套件的安全性时，那不需要升级
	也是没有问题的啦！
____________________________________________________________

重点回顾

• 由于程序是由人所撰写的，因此程序在执行的过程中难免可能会出现一些安全性的问题或者是程
序臭虫的问题。 所以，绝大部分的情况下，将套件保持在最新的版本较能够避免被 cracker 所
入侵的问题
• 绝大部分的自由软件之维护的人员比专属软件还要多，所以程序发生臭虫后的除错与更新时间较
快速！！
• 你不一定要将你的 distribution 更新到最新，不过，更新到最新可以保有较佳的硬件支持与网
络安全。
• 由于 distribution 发展的不同，基本的套件安装可以分为 rpm, dpkg 及 tarball 三种常见模
式；
• 各个 distribution 均有推出自家的在线升级机制，如 CentOS 的 yum, Debian 的 apt, Red Hat
的 up2date 以及 SuSE 的 YOU 等等。各种版本均不可混用。
• yum 这个升级方案在使用时，会主动的 (1)下载表头数据与 (2)进行使用者所需要的更新动作；
• apt-get 必须要使用 apt-get update 更新表头数据后，才能够进行使用者所要求的动作！
• 在线升级机制常常需要使用到 crontab 的工作排程支持；
____________________________________________________________

路由器 Router 设定
最近更新日期：2006/08/30
我们在 网络基础 里面提到 路由 (route) 是一个重要的概念，他可以控制我们的资料封包的走向！ 此外，
如果同一个网域里面有太多的计算机数量需要来广播的话，效能一定不会太好，所以才会有 Netmask 对吧！
今天我们换个角度来想一想，如果说我的网域内真的有太多的计算机数量了， 那么将整个网域切割成较小
的数个子网域 (Subnet) 会是一个比较好的作法，不过， 因为网域与网域之间的封包不可以直接互通数据，
所以这个时候我们就需要使用 Router (路由器) 来帮忙封包的传送了！ 
1. 路由
 1.1 路由表
 1.2 IP Alias 的测试功能
 1.3 重复路由的问题
2. 路由器架设
 2.1 什么是路由器
 2.2 何时需要路由器？
 2.3 静态路由之路由器
 2.4 动态路由之路由器设定：zebra
3. ARP Proxy 让路由器两端在同一网域
4. 重点回顾
5. 课后练习
6. 参考数据
7. 针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=26428
路由
我们在网络基础里面谈到过路由的相关概念， 他最大的功能就是在帮我们规划网络封包的传递方式与方
向。 至于路由的观察则可以使用 route 或者是 netstat 来查阅与设定。 好了，那么路由的形式有哪些？
您又该如何确认路由是否正确呢？
路由表
如同前面网络基础谈到的，每一部主机都有自己的路由表， 也就是说，您必须要透过你自己的路由表来传
递你主机的封包到下一个路由器上头。 若传送出去后，该封包就得要透过下一个路由器的路由表来传送了，
此时与你自己主机的路由表就没有关系啦！ 所以说，如果网络上面的某一部路由器设定错误，那.....封
包的流向就会发生很大的问题。 我们就得要透过 traceroute 来尝试了解一下每个 router 的封包流向
啰。
OK！那你自己主机的路由表到底有哪些部分呢？我们以底下这个路由表来说明：
[root@linux ~]# route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 <== 1
127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo <== 2
0.0.0.0 192.168.1.2 0.0.0.0 UG 0 0 0 eth1 <== 3
首先，我们得知道在 Linux 系统下的路由表是由小网域排列到大网域， 例如上面的路由表当中，路由是
由『 192.168.1.0/24 --> 127.0.0.0/8 --> 0.0.0.0/0 (预设路由) 』来排列的。 而当主机的网络封包
需要传送时，就会查阅上述的三个路由规则来了解如何将该封包传送出去。
你会不会觉得奇怪，为什么会有这几个路由呢？其实路由表主要有这几种情况来设计的：
• 依据界面而存在的路由：
例如 192.168.1.0/24 这个路由的存在是由于鸟哥的这部主机上面拥有 192.168.1.11 这个 IP
的关系！ 也就是说，你主机上面有几个网络接口的存在时，该网络接口就会存在一个路由才对。
所以说，万一你的主机有两个网络接口时，例如 192.168.1.11, 192.168.2.11 时，那路由至少
就会有：
[root@linux ~]# route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
192.168.2.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1
.....以下省略.....
• 手动或预设路由(default route)：
你可以使用 route 这个指令手动的给予额外的路由设定，例如那个预设路由 (0.0.0.0/0) 就是
额外的路由。 使用 route 这个指令时，最重要的一个概念是：『你所规划的路由必须要是你的
装置 (如 eth0) 或 IP 可以直接沟通 (broadcast) 的情况』才行。举例来说，以上述的环境来
看， 我的环境里面仅有 192.168.1.11 及 192.168.2.11 ，那我如果想要连接到
192.168.100.254 这个路由器时， 下达：
[root@linux ~]# route add -net 192.168.100.0 \
> netmask 255.255.255.0 gw 192.168.100.254
SIOCADDRT: Network is unreachable
看吧！系统就会响应没有办法连接到该网域，因为我们的网络接口与 192.168.100.0/24 根本就
没有关系嘛！ 那如果 192.168.100.254 真的是在我们的实体网络连接上，那其实你应该是这样
做：
[root@linux ~]# route add -net 192.168.100.0 \
> netmask 255.255.255.0 dev eth0
[root@linux ~]# route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
192.168.100.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
0.0.0.0 192.168.1.2 0.0.0.0 UG 0 0 0 eth1
这样你的主机就会直接用 eth0 这个装置去尝试连接 192.168.100.254 了！ 另外，上面路由输
出的重点其实是那个『Flags 的 G 』了！因为那个 G 代表使用外部的装置作为 Gateway 的意思！
而那个 Gateway (192.168.1.2) 必须要在我们的已存在的路由环境中。 这可是很重要的概念喔！
^_^
• 动态路由：
除了上面这两种可以直接使用指令的方法来增加路由规则之外， 还有一种透过路由器与路由器之
间的协商以达成动态路由的环境， 不过，那就需要额外的软件支持了，例如： zebra
(http://www.zebra.org/)  或 CentOS 上面的 Quagga (http://www.quagga.net/)  这几个软件
了！
事实上，在 Linux 的路由规则都是透过核心来达成的， 所以这些路由表的规则都是在核心功能内啊！也
就是在内存当中喔！ ^_^
IP Alias 的测试用途
我们在 Linux 常用指令里面谈过 eth0:0 这个装置吧？ 这个装置可以在原本的 eth0 上面模拟出一个虚
拟接口出来，以让我们原本的网络卡具有多个 IP ， 具有多个 IP 的功能就被称为 IP Alias 了。而这个
eth0:0 的装置可以透过 ifconfig 或 ip 这两个指令来达成， 关于这两个指令的用途请翻回去之前的章
节阅读，这里不再浪费篇幅啊！
那你或许会问啊：『这个 IP Alias 有啥用途啊？』好问题！这个 IP Alias 最大的用途就是可以让你用
来『应急』！ 怎么说呢？我们就来聊一聊他的几个常见的用途好了：
• 测试用：
怎么说用来测试呢？举例来说，现在使用 IP 分享器的朋友很多吧， 那 IP 分享器通常使用 WWW
接口来提供设定。那这个 IP 分享器通常会给予一个私有 IP 亦即是 192.168.0.1 来让使用者开
启 WWW 接口的浏览。问题来了，那你要如何连接上这部 IP 分享器呢？ 嘿嘿！在不更动既有的
网络环境下，你可以直接利用：
[root@linux ~]# ifconfig [device] [ IP ] netmask [netmask ip] [up|down]
[root@linux ~]# ifconfig eth0:0 192.168.0.100 netmask 255.255.255.0 up
来建立一个虚拟的网络接口，这样就可以立刻连接上 IP 分享器了。
• 在一个实体网域中含有多个 IP 网域：
另外，如果像是在补习班或者是学校单位的话， 由于原本的主机网络设定最好不要随便修改，那
如果要让同学们大家互通所有的计算机信息时， 就可以让每个同学都透过 IP Alias 来设定同一
网域的 IP ， 如此大家就可以在同一个网段内进行各项网络服务的测试了，很不错吧！
• 既有设备无法提供更多实体网卡时：
如果你的这部主机需要连接多个网域，但该设备却无法提供安装更多的网卡时， 你只好勉为其难
的使用 IP Alias 来提供不同网段的联机服务了！
不过，你需要知道的是：所有的 IP Alias 都是由实体网卡仿真来的， 所以当要启动 eth0:0 时，eth0 必
须要先被启动才行。而当 eth0 被关闭后， 所以 eth0:n 的模拟网卡将同时也被关闭。这得先要了解才行，
否则常常会搞错启动的装置啊！ 在路由规则的设定当中，常常需要进行一些测试，那这个 IP Alias 就派
的上用场了。 尤其是学校单位的练习环境当中！ ^_^！
基本上，除非有特殊需求，否则建议你要有多个 IP 时，最好在不同的网卡上面达成， 如果你真的要使用
IP Alias 时，那么如何在开机的时候就启动 IP alias 呢？有两个简单的方法可以使用：
• 透过 /etc/rc.d/rc.local：
将『ifconfig eth0:n ....』的指令写入 /etc/rc.d/rc.local 当中，这样开机的时候就能够启
动这个虚拟接口， 不过这方法有个弱点，就是当使用类似『 /etc/init.d/network restart 』
的指令时，该接口可能就会被取消。
• 透过 /etc/sysconfig/network-scripts/ifcfg-eth0:0：
举例来说，你可以透过底下这个方法来建立一个虚拟装置的设定档案：
[root@linux ~]# cd /etc/sysconfig/network-scripts
[root@linux network-scripts]# vi ifcfg-eth0:0
DEVICE=eth0:0 <==相当重要！一定要与文件名相同的装置代号！
ONBOOT=yes
BOOTPROTO=static
IPADDR=192.168.0.100
NETMASK=255.255.255.0
NETWORK=192.168.0.0
BROADCAST=192.168.0.255
[root@linux network-scripts]# ifup eth0:0
[root@linux network-scripts]# ifdown eth0:0
关于装置的设定档案内的更多参数说明，请参考连上 Internet 一文的相关说明，在此不再叙述！
使用这个方法有个好处，就是当你使用『 /etc/init.d/network restart 』时， 系统依旧会使
用你的 ifcfg-eth0:0 档案内的设定值来启动你的虚拟网卡喔！另外， 不论 ifcfg-eth0:0 内的
ONBOOT 设定值为何，只要 ifcfg-eth0 这个实体网卡的设定文件中， ONBOOT 为 yes 时，开机
就会将全部的 eth0:n 都启动。
透过这两个简单的方法，你就可以在开机的时候启动你的虚拟接口而取得多个 IP 在同一张网卡上了。 不
过依旧要注意的是，如果你的 eth0 是使用 DHCP 来取得 IP 参数的话，那么由于 ifup 及
/etc/init.d/network 这两个 script 内程序代码撰写的方式，将会导致 ifcfg-eth0:0 这个设定档不会
被使用到喔！ 所以当你使用 DHCP 来取得 eth0 的 IP 时，你只好使用手动方式 (用 ifconfig) 来设定
你的 IP Alias 了。
重复路由的问题
很多朋友可能都有一个可爱的想法，那就是：『我可不可以利用两张网卡， 利用两个相同网域的 IP 来增
加我这部主机的网络流量』？事实上这是一个可行的方案， 不过必须要透过许多的设定来达成，若您有需
求的话，可以参考网中人大哥写的这一篇：
• 频宽负载平衡 (http://www.study-area.org/tips/multipath.htm)
如果只是单纯的以为设定好两张网卡的 IP 在同一个网域而已，那您可就大错特错了～ 为什么呢？还记得
我们在路由表规则里面提过网络封包的传递主要是依据主机内的路由表规则吧！ 那如果你有两张网络卡
时，假设：
• eth0 : 192.168.0.100
• eth1 : 192.168.0.200
那你的路由规则会是如何呢？理论上会变成这样：
[root@linux ~]# route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1
192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
也就是说，当要传送到 192.168.0.0/24 的网域时，都只会透过第一条规则 ，也就是透过 eth1 来传出去，
而不管是由 eth0 还是由 eth1 进来的网络封包都会透过 eth1 来回传，这可能会造成一些问题， 尤其是
一些防火墙的规则方面，很可能会发生一些严重的错误， 如此一来，根本没有办法达成负载平衡，也不会
有增加网络流量的效果！ 更惨的是，还可能发生封包传递错误的情况吶！所以说，同一部主机上面设定相
同网域的 IP 时， 得要特别留意你的路由规则，一般来说， 不应该设定同一的网段的不同 IP 在同一部
主机上面。 例如上面的案例就是一个不好的示范啊！
路由器架设
在同一的局域网络里面可以透过广播 (broadcast) 了解到 MAC 与 IP 的解析，然后透过 MAC 对 MAC 来
传送数据封包， 在不同的网域里头就得要透过路由器的帮忙。那么什么是路由器？他的主要功能是什么？
底下我们就来聊一聊！
什么是路由器
既然主机想要将数据传送到不同的网域时得透过路由器的帮忙，所以啦，路由器的主要功能就是： 『转递
网络封包』啰！ 也就是说，路由器会分析来源端封包的 IP 表头，找出目标的 IP 后，透过路由器本身的
路由表 (routing table) 将这个封包向下一个目标 (next hop) 传送。这就是路由器的功能。
那么路由器的功能可以如何达成呢？目前有两种方法可以达成：
• 硬件功能：例如 Cisco, IBM, 3Com 等公司都有生产硬件路由器，这些路由器内有嵌入式的操作
系统， 可以负责不同网域间的封包转译与转递等功能；
• 软件功能：例如 Linux 这个操作系统的核心就有提供封包转递的能力。
高阶的路由器可以连结不同的硬设备，并且可以转译很多不同的封包格式，通常....价格也不便宜啊！ 在
这个章节里面，我们并没有要探讨这么高阶的咚咚，仅讨论在以太网络里头最简单的路由器功能： 连接两
个不同的网域。嘿嘿！这个功能 Linux 就可以达成了！ 就如同路由表是由 Linux 的核心功能所提供的，
这个转递封包的能力也是 Linux 核心所提供， 那如何启动这个封包转递呢？很简单啊，只要这样做即可：
[root@linux ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
上面这个动作就在打开 Linux 核心的封包转递能力。你可以将上述的指令写入 /etc/rc.d/rc.local 当
中， 以使 Linux 可以在开机的时候就启动封包转递的功能， 也可以透过修改 /etc/sysctl.conf 来达成
开机启动封包转递：
[root@linux ~]# vi /etc/sysctl.conf
# 将底下这个设定值修改正确即可！
net.ipv4.ip_forward = 1
[root@linux ~]# sysctl -p <==立刻让该设定生效
sysctl 这个指令是在核心工作时用来直接修改核心参数的一个指令，更多的功能可以参考 man sysctl 查
询。 不要怀疑！只要这个动作，你的 Linux 就具有最简单的路由器功能了。 而由于 Linux 路由器的路
由表设定方法的不同，通常路由器规划其路由的方式就有两种：
• 静态路由：直接以类似 route 这个指令来直接设定路由表到核心功能当中，设定值只要与网域环
境相符即可。 不过，当你的网域有变化时，路由器就得要重新设定；
• 动态路由：透过类似 zebra 软件的功能，这些软件可以安装在 Linux 路由器上， 而这些软件可
以动态的侦测网域的变化，而直接修改 Linux 核心的路由表信息， 你无须手动以 route 来修改
你的路由表信息喔！
了解了路由器之后，接下来你可能需要了解到什么是 NAT (Network Address Translation, 网络地址转译)
主机， NAT 是啥？其实 IP 分享器就是最简单的 NAT 主机啦！嘿嘿，了解了吗？没错， NAT 可以达成 IP
分享的功能， 而 NAT 本身就是一个路由器，但 NAT 比路由器多了一个『 IP 转换』的功能。怎么说呢？
• 一般来说，路由器会有两个网络接口，透过路由器本身的 IP 转递功能让两个网域可以互相沟通
网络封包。 那如果两个接口一边是公共 IP (public IP) 但一边是私有 IP (private IP) 呢？ 由
于私有 IP 不能直接与公共 IP 沟通其路由信息，此时就得要额外的『 IP 转译』功能了；
• Linux 的 NAT 主机可以透过修改封包的 IP 表头数据之来源或目标 IP ，让来自私有 IP 的封包
可以转成 NAT 主机的公共 IP ，就可以连上 Internet ！
所以说， 当路由器两端的网域分别是 Public 与 Private IP 时，才需要 NAT 的功能！ NAT 功能我们会
在防火墙时谈及，这个章节仅谈论一下路由器而已啊！ ^_^
何时需要路由器？
一般来说，计算机数量小于数十部的小型企业是无须路由器的，只需要利用 hub/switch 串接各部计算机，
然后透过单一线路连接到 Internet 上即可。不过，如果是超过数百部计算机的大型企业环境， 由于他们
的环境通常需要考虑如下的状况，因此才需要路由器的架设：
• 实体线路之布线及效能的考虑：
在一栋大楼的不同楼层要串接所有的计算机可能有点难度，那可以透过每个楼层架设一部路由器，
并将每个楼层路由器相连接，就能够简单的管理各楼层的网络； 此外，如果各楼层不想架设路由
器，而是直接以网络线串接各楼层的 hub/switch 时， 那由于同一网域的数据是透过广播来传递
的，那当整个大楼的某一部计算机在广播时， 所有的计算机将会予以响应，哇！会造成大楼内网
络效能的问题；所以架设路由器将实体线路分隔， 就有助于这方面的网络效能；
• 部门独立与保护数据的考虑：
在阅读过网络基础章节后，您就会晓得， 只要实体线路是连接在一起的，那么当数据透过广播时，
你就可以透过类似 tcpdump 的指令来监听封包数据， 并且予以窃取～所以，如果你的部门之间
的数据可能需要独立， 或者是某些重要的数据必须要在公司内部也予以保护时，可以将那些重要
的计算机放到一个独立的实体网域， 并额外加设防火墙、路由器等连接上公司内部的网域。
路由器就只是一个设备，要如何使用端看您的网络环境的规划！上面仅是举出一些应用案例。 底下我们先
就架设一个静态路由的路由器来玩一玩吧！
静态路由之路由器
假设在贵公司的网络环境当中，除了一般职员的工作用计算机是直接连接到对外的路由器来连结
Internet， 在内部其实还有一个部门需要较安全的独立环境，因此这部份的网络规划可能是这样的情况：
图一、静态路由之路由器架构示意图
以上图的架构来说，这家公司主要有两个 C class 的网域，分别是 192.168.0.0/24 及
192.168.10.0/24 ， 其中 192.168.0.0/24 是用来做为一般员工连接因特网用的，至于 192.168.10.0/24
则是给特殊的部门用的。PC1 代表的是一般员工的计算机， PC2 及 PC3, PC4 则是特殊部门的工作用计算
机， Linux Router 则是这个特殊部门用来连接到公司内部网域的路由器。在这样的架构下， 该特殊部门
的封包就能够具有基础的保护了。
由图一你也不难发现，只要是具有路由器功能的设备 (Router A, Linux Router) 都会具有两个以上的接
口， 分别用来沟通不同的网域，同时该路由器也都会具有一个预设路由啊！ ^_^！ 另外，你还可以加上
一些防火墙的软件在 Linux Router 上， 以保护 PC2~PC4 的内部计算机呢！
在 Router A 的部分，由于他具有 Public 与 Private IP ，所以这部 Router 必须要具有 NAT 的功能，
这个未来我们再介绍。今日的重点就在于 Linux Router 那个玩意儿！在该主机下， 最好配备两张网卡，
一张给 192.168.0.100，另一张给 192.168.10.254 这个 IP。 这部 Linux Router 的设定简单的要命喔！
你可以这样做的：
• Linux Router
在这部主机内需要有两张网卡，鸟哥在这里将他定义为：
• eth0: 192.168.10.254
• eth1: 192.168.0.100
那如何设定呢？这样做就对了：
1. 先处理 eth0
[root@linux ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=static
BROADCAST=192.168.10.255
IPADDR=192.168.10.254
NETMASK=255.255.255.0
NETWORK=192.168.10.0
ONBOOT=yes
2. 再先处理 eth1
[root@linux ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth1
DEVICE=eth1
BOOTPROTO=static
BROADCAST=192.168.0.255
IPADDR=192.168.0.100
NETMASK=255.255.255.0
NETWORK=192.168.0.0
GATEWAY=192.168.0.254 <==这个设定值很重要喔！
ONBOOT=yes
3. 启动 IP 转递
[root@linux ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
# 上述指令如果没有问题，将他加入 /etc/rc.d/rc.local 当中去！
4. 重新启动网络，并且观察路由
[root@linux ~]# /etc/init.d/network restart
[root@linux ~]# route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
192.168.0.0 0.0.0.0 255.255.255.0 U 0 0  0 eth1
192.168.10.0 0.0.0.0 255.255.255.0 U 0 0  0 eth0
127.0.0.0 0.0.0.0 255.0.0.0 U 0 0  0 lo
0.0.0.0 192.168.0.254 0.0.0.0 UG 0 0  0 eth1
有够简单吧！这样你的 Linux Router 就 OK 了吶！接下来则是 PC2 来作为范例。
• 受保护的网域，以 PC2 为例：
不论你的 PC2 是哪一种操作系统，你的环境都应该是这样的：
• IP: 192.168.10.20
• netmask: 255.255.255.0
• network: 192.168.10.0
• broadcast: 192.168.10.255
• gateway: 192.168.10.254
以 Linux 操作系统为例，并且 PC2 仅有 eth0 一张网卡时，他的设定是这样的：
[root@linux ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=static
BROADCAST=192.168.10.255
IPADDR=192.168.10.20
NETMASK=255.255.255.0
NETWORK=192.168.10.0
GATEWAY=192.168.10.254 <==这个设定最重要啦！
ONBOOT=yes
[root@linux ~]# /etc/init.d/network restart
[root@linux ~]# route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref  Use Iface
192.168.10.0 0.0.0.0 255.255.255.0 U 0 0  0 eth0
127.0.0.0 0.0.0.0 255.0.0.0 U 0 0  0 lo
0.0.0.0 192.168.10.254 0.0.0.0 UG 0 0  0 eth0
• Router A 的新增路由规则：
在这样的架构下，您的 PC2 已经可以连接上 Internet 了！只不过，当封包由 Internet 传回来时， 由
于 Router A 并没有连接到 192.168.10.0/24 网域的路由规则，所以该封包『会遗失』喔！那就麻烦了～
所以，你的 Router A 必须要额外增加一条规则，这条规则是『将目标为 192.168.10.0/24 的封包传送给
192.168.0.100 去处理』，假设 Router A 为 Linux 系统时，那他应该要这样：
[root@linux ~]# route add -net 192.168.10.0 netmask 255.255.255.0 \
> gw 192.168.0.100
[root@linux ~]# route -n
Destination Gateway Genmask Flags Metric Ref Use Iface
192.168.10.0 192.168.0.100 255.255.255.0 UG 0 0  0 eth0
# 你应该会发现上头这一条规则存在才行！
如此一来，你的 Router A 及 Linux Router 之间就可以沟通，并且可以传递 192.168.10.0/24 的网域吶！
• PC1 直接与 PC2 的沟通方式：
在图一当中，你会发现那个 PC1 必须要将预设路由设定为 192.168.0.254 ， 所以当 PC1 要与 PC2 沟通
时，封包将由：
PC1 --> Router A --> Linux Router --> PC2
不过，在图一当中我们知道其实 PC1 与 PC2 同时接到 Linux Router 上嘛！ 所以 PC1 其实可以直接加
入一条路由规则，规定当 192.168.10.0/24 的封包目标时， 他可以直接传到 Linux Router 上即可，那
可以这样做：
[root@linux ~]# route add -net 192.168.10.0 netmask 255.255.255.0 \
> gw 192.168.0.100
最后只要 PC2 使用 ping 可以连到 PC1，同样的， PC1 也可以 ping 到 PC2 的话， 就表示你的设定是 OK
的啦！嘿嘿！搞定！而透过这样的设定方式，您也可以发现到一件事， 那就是：『路由是双向的，你必须
要了解出去的路由与回来时的规则』。 举例来说，在预设的情况下 (Router A 与 PC1 都没有额外的路由
设定时)，其实封包是可以由 PC2 联机到 PC1 的，但是 PC1 却没有相关的路由可以响应到 PC2 ～所以上
头才会要您在 Router A 或者是 PC1 上面设定额外的路由规则啊！这样说，瞭了吧？ ^_^
所以说，用 Linux 作一个静态路由的 Router 很简单吧！以上面的案例来说，你在 Linux Router 上面几
乎没有作什么额外的工作，只要将网络 IP 与网络接口对应好启动，然后加上 IP Forward 的功能， 让你
的 Linux 核心支持封包转递，然后其它的工作咱们的 Linux kernel 就主动帮你搞定了！ 真是好简单！
^_^
不过这里必须要提醒的是，如果你的 Linux Router 有设定防火墙的话， 而且还有设定类似 NAT 主机的
IP 伪装技术，那可得特别留意，因为还可能会造成路由误判的问题～ 上述的 Linux Router 当中『并没
有使用到任何 NAT 的功能』喔！特别给他留意到！
动态路由之路由器设定：zebra
如前所述，系统管理员可以利用 route 这个指令手动的将路由规则加入核心当中，这个方式称为静态路由。
动态路由同样是将路由规则加入核心当中，只是这个加入的动作交由软件服务 (daemon) 自动来执行， 在
Linux 上面常见的路由服务就是 zebra 这个套件所提供的。
动态路由通常是用在路由器与路由器之间的沟通，所以要让您的路由器具有动态路由的功能， 你必须要了
解到对方路由器上面所提供的动态路由协议才行，这样两部路由器才能够透过该协议来沟通彼此的路由规
则。 目前常见的动态路由协议有：RIPv1, RIPv2, OSPF, BGP 等等， zebra 都有支持这些路由协议喔！
在 CentOS 上头，我们使用 quagga 这个套件来提供 zebra ，因为 quagga 是更新 zebra 而来的， 事实
上，你可以说， quagga 就是 zebra 啦！赶紧安装他先：
[root@linux ~]# yum install quagga
[root@linux ~]# ls -l /etc/quagga
-rw-r--r-- 1 root root 410 Jun 2 02:38 ripd.conf.sample
-rw-r----- 1 quagga quagga 30 Aug 29 10:50 zebra.conf
-rw-r--r-- 1 root root 373 Jun 2 02:38 zebra.conf.sample
.....其它省略.....
这个套件所提供的各项动态路由协议都放置到 /etc/quagga/ 目录内，底下我们以较为简单的 RIPv2 协议
来处理动态路由， 不过你得要注意的是，不论你要启动什么动态路由协议，那个 zebra 都必须要先启动
才行！ 这是因为：
• zebra 这个 daemon 的功能在更新核心的路由规则；
• RIP 这个 daemon 则是在向附近的其它 Router 沟通协调路由规则的传送与否。
而各个路由服务的设定档都必须要以 /etc/quagga/*.conf 的档名来储存才行，如上表我们可以发现
zebra 这个服务是有设定好了，不过 ripd 的档名却不是 .conf 结尾。所以我们必须要额外作些设定才行。
而假设我们的网络连结如下图二所示：
图二、动态路由的简易图标
这两部 Linux Router 分别负责不同的网域，且可以透过 192.168.0.0/24 这个网域来沟通。 在没有设定
额外路由规则的情况下，那个 PC1 与 PC2 是无法沟通的！另外， zebra 必须要同时安装在两部 Linux
Router 上头才行， 而且我们只要设定好这两部主机的网络接口 (eth0, eth1) 后，不需要手动输入额外
的路由设定喔！可以透过 RIP 这个路由协议来搞定的！
• 设定 zebra
我们先设定图二右手边那一部 Linux Router，关于 zebra.conf 你可以这样设定的：
1. 先设定 zebra 并且启动 zebra
[root@linux ~]# vi /etc/quagga/zebra.conf
hostname linux.router1 <==给予这个路由器一个主机名称，随便取！
password linux1 <==给予一个密码！
enable password iinux1 <==将这个密码生效！
log file zebra.log <==将所有 zebra 产生的信息存到登录文件中
[root@linux ~]# /etc/init.d/zebra start
[root@linux ~]# netstat -tunlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
tcp 0 0 127.0.0.1:2601 0.0.0.0:* LISTEN 6422/zebra
仔细看，由于 zebra 这个服务的任务主要是在修改 Linux 系统核心内的路由， 所以他仅监听本机接口而
已，并不会监听外部的接口才对！另外，在 zebra.conf 这个档案当中， 我们所设定的那个密码是有作用
的喔！可以让我们登入 zebra 这套软件呢！ 好了，我们来查一查这个 2601 的 port 是否正确的启动的
呢？
[root@linux ~]# telnet localhost 2601
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Hello, this is Quagga (version 0.98.3).
Copyright 1996-2005 Kunihiro Ishiguro, et al.
User Access Verification
Password: <==在这里输入刚刚你设定的密码啊！
linux.router1> <==在这边输入『 ? 』就能够知道有多少指令可使用
 echo Echo a message back to the vty
 enable Turn on privileged mode command
 exit Exit current mode and down to previous mode
 help Description of the interactive help system
 list Print command list
 quit Exit current mode and down to previous mode
 show Show running system information
 terminal Set terminal line parameters
 who Display who is on vty
linux.router1> list
 echo .MESSAGE
 enable
 exit
 help
 list
 quit
 show debugging zebra
 show history
 show interface [IFNAME]
 show ip forwarding
 show ip route
....其它省略....
linux.router1> show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP, O - OSPF,
 I - ISIS, B - BGP, > - selected route, * - FIB route
K>* 0.0.0.0/0 via 192.168.0.254, eth0
C>* 127.0.0.0/8 is directly connected, lo
C>* 192.168.0.0/24 is directly connected, eth0
C>* 192.168.10.0/24 is directly connected, eth1
linux.router1> exit
Connection closed by foreign host.
仔细看到，我们登入这个 zebra 的软件之后，可以输入『help』或问号『?』， zebra 就会显示出你能够
执行的指令有哪些，比较常用的当然是查询路由规则啰！ 以『 show ip route 』来查阅，结果可以发现
目前的接口与预设路由都被显示出来了， 显示的结果当中，K 代表以 router 这个指令直接加入核心的路
由规则，C 则代表你的网络接口相关的路由规则。
事实上，如果你还想要增加额外的静态路由的话，也可以透过 zebra 而不必使用 route 指令呢！ 例如想
要增加 10.0.0.0/24 给 eth0 来处理的话，可以这样做：
[root@linux ~]# vi /etc/quagga/zebra.conf
# 新增底下这一行喔！
ip route 10.0.0.0/24 eth0
[root@linux ~]# /etc/init.d/zebra restart
[root@linux ~]# telnet localhost 2601
User Access Verification
Password: <==这里输入密码
linux.router1> show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP, O - OSPF,
 I - ISIS, B - BGP, > - selected route, * - FIB route
K>* 0.0.0.0/0 via 192.168.0.254, eth0
S>* 10.0.0.0/24 [1/0] is directly connected, eth0
C>* 127.0.0.0/8 is directly connected, lo
C>* 192.168.0.0/24 is directly connected, eth0
C>* 192.168.10.0/24 is directly connected, eth1
嘿嘿！立刻就会多出一笔路由的规则，而且最右边会显示 S，亦即是静态路由 (Static route) 的意思。 如
此一来，我们系统管理员可就轻松多了！ 设定完 zebra 之后，接下来我们可以开始看看 ripd 这个服务
啰！
• 设定 ripd 服务
ripd 这个服务可以在两部 Router 之间进行路由规则的交换与沟通， 当然啦，如果你的环境里面有类似
Cisco 或者是其它有提供 RIP 协议的路由器的话， 那么你当然也是可以透过这个 RIP 让您的 Linux
Router 与其它硬件路由器互相沟通的吶！ 闲话少说，来设定 ripd 吧！
[root@linux ~]# vi /etc/quagga/ripd.conf
hostname linux.router1 <==这里是设定 Router 的主机名称而已
password linux1 <==设定好你自己的密码喔！
router rip <==启动 Router 的 rip 功能
network 192.168.0.0/24 <==针对这个网域来进行监听的动作！
network eth0 <==针对这个接口来进行监听的动作
network 192.168.10.0/24 <==针对这个网域来进行监听的动作！
network eth1 <==针对这个接口来进行监听的动作
version 2 <==启动的是 RIPv2 的服务
log stdout <==直接在屏幕输出标准输出的数据
[root@linux ~]# /etc/init.d/ripd start
[root@linux ~]# netstat -tulnp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
tcp 0 0 0.0.0.0:2602 0.0.0.0:* LISTEN 21373/ripd
基本上，这样就设定完成一部路由器的 RIP 动态路由协议了！在上头 ripd.conf 的设定当中， 他会主动
以 eth0 及 192.168.0.0/24 这个网域的功能来进行搜索，如此一来，未来你进行任何路由规则的变动， 或
者是整个网域的主机 IP 进行更动，你将不需要重新到每部 Router 上更动！ 因为这些路由器会自动的更
新他们自己的规则喔！嘿嘿！接下来，同样的动作请你到 图二左边那部 Linux Router 上面设定一下！ 因
为整个设定的流程都一样，所以这里鸟哥就省略啦！
• 检查 RIP 协议的沟通结果
在两部 Linux Router 都设定妥当之后，你可以登入 zebra 去看这两部主机的路由更新结果喔！ 举例来
说，鸟哥登入图二右边那部 Linux Router 后，并且登入 zebra ， 观察路由会是这样的情况：
[root@linux ~]# telnet localhost 2601
User Access Verification
Password: <==不要忘记了密码啊！
linux.router1> show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP, O - OSPF,
 B - BGP, > - selected route, * - FIB route
K>* 0.0.0.0/0 via 192.168.0.254, eth0
C>* 127.0.0.0/8 is directly connected, lo
C>* 192.168.0.0/24 is directly connected, eth0
R>* 192.168.5.0/24 [120/2] via 192.168.0.200, eth0, 00:06:48
C>* 192.168.10.0/24 is directly connected, eth1
如果你有看到上述的字体，嘿嘿！那就是成功啦！那个最左边的 R 代表的是透过 RIP 通讯协议所设定的
路由规则啦！ 如此一来，咱们的路由器设定就搞定啰～
透过这个 zebra 以及 RIPv2 的路由协议的辅助，我们可以轻松的就将路由规则分享到附近区网的其它路
由器上头， 比起单纯使用 route 去修改 Linux 的核心路由表，这个动作当然要快速很多！ 不过，如果
是很小型的网络环境，那么不要使用这个 zebra 啊！因为有点多此一举的感觉。 如果您的企业环境真的
有够大，那么玩一玩这个 zebra 配合一些动态路由协议，嘿嘿！也是可行的啦！
ARP Proxy 让路由器两端在同一网域
如果你一开始设计的网络环境就是同一个 C class 的网域，例如 192.168.10.0/24 ， 后来因为某些因素
必须要将某些主机搬到比较内部的环境中，例如图一的 PC2 ~ PC4 。 然后又因为某些因素，所以你不能
变更 PC2 ~ PC4 的 IP ，也就是说，有点像底下这样的图示：
图三、路由器两边是同一网域的特殊状况
初次见面～看到眼睛快要掉下来哩！怎么会两边的主机都在同一个网域内？而且还被规定不能够更改原先
的 IP 设定， .....真是一个头两个大啊～如此一来，在 Linux Router 两边要如何制作路由啊？好问题！
真是好问题～ 因为 OSI 第三层网络层的路由是一条一条去设定比对的，所以如果两块网卡上面都是同一
个网域的 IP 时， 就会发生错误。那如何处理啊？
既然 OSI 第三层无法解决，那么可否以第二层的数据连接层来处理？看倌应该还记得 OSI 第二层最重要
的就是那个 ARP 协议， 他可以用来进行 IP 与 MAC 的对应。那么由图三我们知道 PC1 要与 PC2 等主机
沟通时，都需要透过 Linux Router ， 那有没有办法透过 ARP 告知整个网域内的计算机，要传送到
PC2~PC4 的封包都需要经过 Linux Router 呢？ 呵呵！好想法。你可以这样想：
图四、路由器两边是同一网域的特殊状况
也就是说：
1. 当 Linux Router 的 eth1 那个网域主机想要连接到 PC2~PC4 的主机时，由 Linux Router 负责
接收；
2. 当 Linux Router 要传送数据到 PC2~PC4 时，务必要由 eth0 来传送；
3. 当 Linux Router 要传送的数据为 192.168.10.0/24 ，但并非 PC2~PC4 时，需由 eth1 传送；
4. 当 Linux Router 的 eth0 那个网域主机想要连接到 PC1 时，由 Lniux Router 负责接收。
要达到 (1) 与 (4) 的要求并不难，我们可以透过 ARP Proxy 这玩意儿，啥是 ARP Proxy 呢？就是在
Linux Router 上面预先规定『将 192.168.10.20, 192.168.10.30, 192.168.10.40 这三个 IP 的 MAC 都
对应到 Linux Router 上！』由于是局域网络内，因此都是透过广播的方式达到 ARP 协议所需要的 IP 与
MAC 的对应，所以啦，每一部在 eth1 那端的主机都会『误判』那三个 IP 是 Linux Router 所拥有， 这
样就能够让封包传给 Linux Router 啦！
再接下来，咱们的 Linux Router 必须要额外指定路由，设定：
• 若目标是 PC2 ~ PC4 时，该路由必须要由 eth0 发送出去才行，
• 若目标不为 PC2 ~ PC4 ，且目标在 192.168.10.0/24 的网域时，需由 eth0 发送出去才行。
也就是说，你必须要指定路由规则当中，那个 PC2~PC4 具有优先选择权，然后其它的同网域封包才由 eth1
来传送。 这样就能够达成我们所想要的结局啦！^_^！看样子似乎很难，其实设定方面还挺简单的，你可
以透过 arp 以及 route 这两个指令来达成喔！
1. 先设定 ARP Proxy ，告知 eth1 所在网域 IP 与 MAC 的对应
[root@linux ~]# arp -i eth1 -s 192.168.10.20 00:11:12:13:14:15 pub
[root@linux ~]# arp -i eth1 -s 192.168.10.30 00:11:12:13:14:15 pub
[root@linux ~]# arp -i eth1 -s 192.168.10.40 00:11:12:13:14:15 pub
# 看图四的说明，我这里假设 eth1 的 MAC 是 00:11:12:13:14:15 啦！
[root@linux ~]# arp -i eth0 -s 192.168.10.50 00:01:02:03:04:05 pub
# 看图四的说明，我这里假设 eth0 的 MAC 是 00:01:02:03:04:05 啦！
[root@linux ~]# arp -n
Address HWtype HWaddress Flags Mask Iface
192.168.10.20 * * MP eth1
192.168.10.30 * * MP eth1
192.168.10.40 * * MP eth1
192.168.10.50 * * MP eth0
# 瞧！有三个 IP 都变成属于俺的 eth1 的啦！然后一个属于 eth0
2. 开始处理路由，需要清除掉 eth0 的路由，并且增加 PC2~PC4 的单机路由
[root@linux ~]# route del -net 192.168.10.0 netmask 255.255.255.0 eth0
[root@linux ~]# route add -host 192.168.10.20 eth0
[root@linux ~]# route add -host 192.168.10.30 eth0
[root@linux ~]# route add -host 192.168.10.40 eth0
# 这样就设定妥当啦！将你的路由规划好啰！
[root@linux ~]# route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
192.168.10.20 0.0.0.0 255.255.255.255 UH 0 0 0 eth0
192.168.10.30 0.0.0.0 255.255.255.255 UH 0 0 0 eth0
192.168.10.40 0.0.0.0 255.255.255.255 UH 0 0 0 eth0
192.168.10.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1
# 看到上面这一行，虽然我的两块网卡都是在 192.168.10.0/24 ，
# 不过真正针对整个网域传送的，仅有 eth1 那一块的意思！
瞧！这样一来，你的 PC1 就可以 ping 到 PC2~PC4 的主机了！数据的传输上面也没有问题。 这个作法是
相当有帮助的吶！对于预设架构不想更动的环境来说。 ^_^！ 不过，由这个案例你也可以清楚的知道，能
不能联机其实与路由的关系才大哩！ 而路由是双向的，你必须要考虑到这个封包如何回来的问题喔！
重点回顾
• 网络卡的代号为 eth0, eth1, eth2...，而第一张网络卡的第一个虚拟接口为 eth0:0 ...
• 网络卡的参数可使用 ifconfig 直接设定，亦可使用设定档如
/etc/sysconfig/network-scripts/ifcfg-ethn 来设定；
• 路由是双向的，所以由网络封包发送处发送到目标的路由规划，必须要考虑回程时是否具有相对
的路由， 否则该封包可能会『遗失』；
• 每部主机都有自己的路由表，此路由表 (routing table) 是作为封包传送时的路径依据；
• 每部可对外 Internet 传送封包的主机，其路由信息中应有一个预设路由 (default gateway)；
• 要让 Linux 作为 Router 最重要的是启动核心的 IP Forward 功能；
• 重复路由可能会让你的网络封包传递到错误的方向；
• 动态路由通常是用在两个 Router 之间沟通彼此的路由规则用的，常见的 Linux 上的动态路由套
件为 zebra ；
• arp proxy 可以透过 arp 与 route 的功能，让路由器两端都在同一个网段内；
• 一般来说，路由器上都会有两个以上的网络接口
• 事实上，Router 除了作为路由转换之外，在 Router 上面架设防火墙，亦可在企业内部再分隔出
多个需要安全 (Security) 的单位数据的区隔！
课后练习
• 请问您如何将您的 eth0 这个接口修改成为 192.168.100.2 在网域 192.168.100.0/25 之内的
网络参数内容？
因为 192.168.100.0/25 的 netmask 为 255.255.255.128 ，所以可以这样做：
ifconfig eth0 192.168.100.2 netmask 255.255.255.128 up
这样即可！如果尚须其它的参数，则需要以档案形式来下达，如 vi
/etc/sysconfig/network-scripts/ifcfg-eth0，并修改为：
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=static
IPADDR=192.168.100.2
NETMASK=255.255.255.128
NETWORK=192.168.100.0
BROADCAST=192.168.100.127
• 请手动设定 eth0:1 这个虚拟接口，使成为网络参数： 192.168.200.2, 网域在
192.168.200.0/24。
ifconfig eth0:1 192.168.200.2 up
• 如何观察路由表？
route -n 即可查阅！注意到 0.0.0.0 那个目标(default gateway)。
• 如何启动 Linux 的 IP Forward 功能？
直接以『echo "1" > /proc/sys/net/ipv4/ip_forward 』即可！
• 假设您是一个学校单位的信息管理员，学校内有 200 部计算机，奉上面大头的旨意，必须要将 200
部计算机分为 4 个 Subnet ，请问您应该如何布线(请画出示意图)？而这 4 个 Subnet 的网络
参数如何选择(请自行选择)？而是否需要 Router ？如果需要的话，假设每个 Router 仅能有两
个网络实体接口，那么该如何布线？(注：不要使用虚拟接口)
• 假设你想要连接到 168.95.1.1 ，那么你该如何判断你经过『多少个』节点？
可以使用 traceroute 168.95.1.1 来分析每个节点的传送信息，也可以透过 ping 168.95.1.1 所
回传的那个 ttl 值判断节点数量。
• 万一您的网络有点停顿，发现可能是网络上某个节点出现问题，您应该如何确认是哪一部 Router
出问题？
就利用 traceroute 吧！
____________________________________________________________

认识网络安全
最近更新日期：2006/09/06
在介绍了『 网络基础』、『 限制联机 port number 』、『 网络升级套件』之后，再来准备要上 Internet 了
吗？！如果只是想要上 Internet 去浏览，那么自然没有问题，如果是想要对 Internet 开放网络服务，那么
最好还是先认识一下网络安全会比较好一些。什么？套件也更新了，  port 也关闭了，还需要认识什么网络
安全啊？！呵呵！当然啦！因为难保我们的主机不会被新的套件漏洞以及阻断式攻击 (DoS)所困扰啊！在
这个章节里面，我们会稍微介绍一些基础的网络防护观念，尤其是系统管理员应该要做的事情吶！ 
1. 网络封包联机进入主机的流程
 1.1 封包进入主机的流程
 1.2 主机能作的保护：权限设定、套件更新、SELinux
2. 主机的细部权限规划：ACL 的使用
 2.1 什么是 ACL ？
 2.2 如何启动 ACL？
 2.3 ACL 的设定技巧： getfacl , setfacl
3. 一些常见的攻击手法与主机的保护方式
4. 被入侵后的修复工作
 4.1 网管人员的额外技巧与任务
 4.2 入侵恢复工作
5. 重点回顾
6. 课后练习
7. 参考数据
8. 针对本文的建议：http://phorum.vbird.org/viewtopic.php?p=114062
网络封包联机进入主机的流程
在这一章当中，我们要讨论的是，当来自一个网络上的联机要求想进入我们的主机时， 这个网络封包在进
入主机实际取得数据的整个流程是如何？了解了整个流程之后， 你才会发现：原来系统操作的基本概念是
如此的重要！ 而你也才会了解要如何保护你的主机安全吶！闲话少说，咱们赶紧来瞧一瞧先。
封包进入主机的流程
在网络基础章节当中我们谈到过目前的网络架构主要是 TCP/IP 为主， 而绝大部分的网络联机是双向的，
其中又以 TCP 封包为代表。 另外，根据 Server/Client 的联机方向与 TCP/IP 的概念，我们会知道建立
一条可靠的网络联机需要一组 Socket Pair 的辅助， 亦即成对的来源与目标之 IP 与 port 啰，以使联
机的两端可以顺利的连接到相对的应用软件上。
上面谈到的这些都是属于网络的基础概念，在这里我们要谈的是，那么要让这个 TCP 封包顺利的进入到
Linux 主机上， 然后使用 port 所对应的软件来存取系统的档案系统资源时，还得要经过哪些关卡呢？ 举
例来说，如果你的 Linux 主机有开启 WWW 的 port 80 网络服务，而 port 80 是由一个名称为 httpd 的
程序所启动的，这个程序的设定文件为 httpd.conf ，那么 Client 的联机要进入到你 Linux 主机的 WWW
时， 会经过什么阶段呢？基本上，会经过如下图的几个阶段：
图一、网络封包进入本机的流程顺序
1. 封包过滤防火墙：IP Filtering 或 Net Filter
要进入 Linux 本机的封包都会先通过 Linux 核心的预设防火墙，就是称为 IP Filter 或 Net
Filter 的咚咚， 简单的说，就是 iptables 这个软件所提供的防火墙功能。iptables 这个 Linux
预设的防火墙软件可以针对网络封包的 IP, port, MAC, 以及联机状态如 SYN, ACK 等数据进行
分析， 以过滤不受欢迎的网络封包呢！举例来说，如果有个 IP 为 aaa.bbb.ccc.ddd 是个恶意
网站来源， 那你就可以透过 iptables 抵挡来自该 IP 的网络封包的联机，以达到基本的主机防
火墙功能。 这部份我们会在下一章深入了解。
2. 第二层防火墙：TCP Wrappers
通过 IP Filter 之后，网络封包会开始接受 Super daemons 及 TCP_Wrappers 的检验，那个是
什么呢？ 呵呵！说穿了就是 /etc/hosts.allow 与 /etc/hosts.deny 的设定文件功能啰。 这个
功能也是针对 TCP 的 Header 进行再次的分析，同样你可以设定一些机制来抵制某些 IP 或
Port ，好让来源端的封包被丢弃或通过检验；
3. 服务 (daemon) 的功能：
前面这两个动作基本上是 Linux 预设的功能，而这第三个步骤就是属于软件功能了。 举例来说，
你可以在 httpd.conf 这个设定档之内规范某些 IP 来源不能使用 httpd 这个服务来取得主机
的数据， 那么即使该 IP 通过前面两层的过滤，他依旧无法取得主机的资源喔！但要注意的是，
如果 httpd 这支程序本来就有问题的话，那么 client 端将可直接利用 httpd 软件的漏洞来入
侵主机，而不需要取得主机内 root 的密码！因此， 要小心这些启动在因特网上面的软件喔！ 所
以前一章网络升级套件是很重要的！
4. 使用主机的档案系统资源：
想一想，你使用浏览器连接到 WWW 主机最主要的目的是什么？当然就是读取主机的 WWW 数据啦！
那 WWW 资料是啥？就是档案啊！^_^！所以，最终网络封包其实是要向主机要求档案系统的数据
啦。 我们这里假设你要使用 httpd 这支程序来取得系统的档案数据，但 httpd 预设是由一个系
统账号名称为 httpd 来启动的，所以：你的网页数据的权限当然就是要让 httpd 这支程序可以
读取才行啊！如果你前面三关的设定都 OK ，最终权限设定错误， 使用者依旧无法浏览你的网页
数据的。
在这些步骤之外，我们的 Linux 以及相关的软件都可能还会支持登录文件记录的功能， 为了记录历史历
程，以方便管理者在未来的错误查询与入侵侦测，良好的分析登录档的习惯是一定要建立的， 尤其是
/var/log/messages 与 /var/log/secure 这些个档案！ 虽然各大主要 Linux distribution 大多有推出
适合他们自己的登录档分析套件，例如 CentOS 的 logwatch ，不过毕竟该套件并不见得适合所有的
distributions ，所以鸟哥尝试自己写了一个 logfile.sh 的 shell script，您可以在底下的网址下载该
程序：
• http://linux.vbird.org/download/index.php?action=detail&fileid=60
好了，那么根据这些流程，你觉得我们可以如何保护自己的主机呢？
主机能作的保护： 权限设定、套件更新、SELinux
在基础篇里面的前面几章我们谈到很多关于档案权限方面的注意事项， 关于目录最重要的是那个 w (可写
入)的权限，至于对档案来说，那个 r (可读取) 也是非常重要的！而由前一小节的图一我们也知道网络服
务其实就是提供主机的档案资源给 client 端来查阅就是了。
根据这样的说法，你可以知道，如果你有某些不想要被读取的数据在主机上面的话， 那么将该数据的权限
设定为不能被某些网络服务读取的情况， 就能达到最基础的保护了。所以您说档案权限重不重要啊！很重
要的！不是吗？
• 权限的重要性
鸟哥常常在上课的时候会开玩笑，说如果你只要下达一个指令，那你的系统就得要重新安装了！ 那就是：
『chmod -R 777 /』，这个指令可是『极度危险』的喔！为何呢？因为系统上面本来就有很多需要被保护
的数据， 例如 /etc/shadow 以及 /etc/passwd 等，尤其是 shadow 密码档案。虽然里头是加密过的数据，
不过别忘了，现在的 PC 速度实在太快了，而网络上又有太多暴力破解密码的软件， 如果你的 /etc/shadow
被取得后，嘿嘿！你的密码其实就算『公开了』。那万一你有开放某些网络服务的话， 例如可联机登入的
ssh 服务或 mail 服务，那任何人都可以使用你的主机来登入， 或者是利用你的主机来收你主机上的其它
使用者的信，唉！糗大了！
再者，很多朋友在主机上面常常喜欢建立权限为 drwxrwxrwx 的目录来提供使用者上传数据， 这实在是很
危险ㄟ！如果使用者的功力够高的话，他可以在网络软件如 httpd 的使用上， 来建立一些危险的 script
在你的 drwxrwxrwx 的目录中，那如果你不小心进入到该目录， 又不小心执行了该恶意使用者所建立的
script ，恭喜您～中标！
另外，如果你是学校老师，为了公平与同学本身的权益起见，你会希望同学们所上传的数据不会被其它同
学所窃取。 那么你该如何进行权限的规范？如果单纯的让学生通通上传到单一目录，并且没有指定特殊的
权限时， 不但某些同学的数据可能会被窃取与复制，更惨的是，可能数据会被某些恶意同学所删除！ 那
可就麻烦了！所以，权限的设定真的很重要啦！
而除了传统的权限之外，事实上目前 Linux 支持一种称为 ACL 的额外权限控制方式， 也支持更强化安全
的 SELinux ，这两个小东西我们会在本章的后面部分继续介绍。
• 严格的密码的重要性：
很多使用者为了方便记忆，老是跟系统管理员说：『喂！我的密码可不可以简单一点啊？ 太麻烦的我都记
不住！』如果您是那个可怜的系统管理员，你该如何响应？ 如果你大开方便之门，未来可是后患无穷的！
举例来说，如果你的 mail server 上面某个使用者账号为 alex 好了，那么他的 email address 将会是：
『 alex@your.host.name 』， 那这个使用者由于使用习惯不良，他将他的 mail address 留在 Internet
上，所以很多人都知道这个 address。
知道就知道，会有什么了不起吗？呵呵！了不起的很！如果有个坏家伙，他想要偷偷的收取 alex 的信，  那
他就在他的收信软件上面偷偷填上你的主机，然后偷偷输入账号 alex 并且输入密码为 alex ， 如果你真
的帮 alex 这个使用者建立同名的密码，哈哈！系啊(请台语发音，谢谢)！这个 alex 永远都收不到他的
信了！
这算还好吶！如果你有开放远程联机登入的服务，那么坏家伙就可以利用 alex 这个账号与密码来登入你
的主机， 如果你没有做好权限规划的话，哇！整部主机的数据被偷光光！那可有的瞧的了！ 所以，您说
密码不重要吗？我可不认为！
• 套件更新的重要性：
很多朋友由于网络文章的关系，可能会拿比较旧的 Linux distribution 来作为架站的平台， 举例来说，
使用 Red Hat 9 来架站的朋友想必还是不少的。如果你真的利用旧的版本来进行网站的架设， 而且还对
Internet 开放服务的话，那么你的主机将会在不到一天的时间内被『绑架』的！ 为什么呢？因为套件软
件都是可能有漏洞的，如果你没有补洞的话.....
有些朋友认为：『我的密码设定的严格一点，应该就好了吧？』真的吗？让我们瞧一瞧图一的流程， 第三
个步骤是否使用到 httpd 这个程序的功能了，万一这个程序有问题怎么办？ 举例来说， 酷学园的朋友曾
经在他举办的研讨会当中露一手如何绑架没有修补漏洞的 Linux 系统， 利用的就是 httpd 这个软件的漏
洞，整个入侵的过程没有花费一分钟以上！ 而且他取到的可是 root 的权限吶！不是什么阿猫阿狗的喔！
而且他完全没有输入任何密码，使用的入侵程序则是由 Internet 上面取得的。
在上头这个例子鸟哥不是要说该朋友的功力，而是要提醒大家，套件修补的重要性！ 要取得破解程序的管
道实在太多了，但如果你都有在最短的时间内取得套件的更新的话， 那么至少该破解程序对你的系统就不
会生效！你的主机自然就会比较安全些。 而这个问题在所有的操作系统上面都是存在的！ Windows 系统
也是每个月必须要推出他们的套件程序修补， 否则一样会被攻击或入侵啊！不过 Linux 的套件漏洞修补
要快多了！
• SELinux
在最新的 Linux 2.6 版核心上所发展的 distributions 目前预设都会启动一个名为 SELinux 的核心模
块， 这个 SELinux 必须要在开机加载核心时就得要加载，那这个玩意儿是啥咚咚？ SELinux 是 Security
Enhanced Linux (安全加强的 Linux) 的缩写， 他并不是一个防火墙的软件，而是一个『针对档案系统权
限作更细部规划的一个模块』。
传统的 Linux 权限是分为三种身份 (owner, group, others) 以及三种权限 (r, w, x)， 但事实上，这
三种身份的三种权限组合并无法有效的管理所有系统上的 daemon 存取数据时所需要的行为。 因此美国国
家安全局便发展出这个可以更细部规划档案权限功能的 SELinux 了。
由于 SELinux 主要是进行档案系统的细部权限设定，所以想要使用 SELinux 的配置时， 需要对 Linux 的
档案系统以及基础的操作系统概念要很清楚，否则将会使得很多的网络服务无法正确的启用系统资源， 导
致你的主机很多服务无法存取系统数据！因此，对于我们刚接触到 Linux 架站的朋友来说， 建议你先关
闭 SELinux ，等到两三年后对于 Linux 有很深的概念后， 再来尝试配置 SELinux 这个有趣的咚咚！
也就是说，如果你没有关闭 SELinux 的话，那么你就得要针对 SELinux 进行档案权限的额外配置， 否则
你的网络服务就不可能会正常的启动！那么如何关闭 SELinux 呢？你可以这样做：
1. 先关闭 /etc/selinux/config 的内容
[root@linux ~]# vi /etc/selinux/config
# 将底下的设定值改成这样：
SELINUX=disabled
2. 修改开机时 grub 的设定档
[root@linux ~]# vi /boot/grub/menu.lst
.....省略.....
 kernel /boot/vmlinuz-2.6.9 ro root=/dev/hda1 rhgb selinux=0
.....省略.....
3. 重新开机
[root@linux ~]# sync; reboot
因为 SELinux 必须要在开机的时候加载，同样的，要卸载也必须要重新开机才行！ 因此，如果你使用的
是您 distributions 的预设安装，那么几乎 SELinux 都是预设启动的！ 你可以依据上述的几个步骤将
SELinux 取消后，重新开机即可。如果对于 SELinux 有兴趣的话， 底下的连结可以参考看看：
• http://fedora.redhat.com/docs/selinux-faq-fc5/
• http://selinux.sourceforge.net/
• http://www.redhat.com/docs/manuals/enterprise/RHEL-4-Manual/selinux-guide/index.html
主机的细部权限规划：ACL 的使用
在前一小节当中我们提到 Linux 系统的权限是很重要的，偏偏传统的权限仅有三种身份、三种权限而已，
配合 chmod, umask, chown, chgrp 等指令来进行使用者与群组相关权限的设定。如果要进行比较复杂的
权限设定时， 例如某个目录要开放给某个特定的使用者来使用时，传统的 owner,group,others 的权限方
法可能就无法满足了。 不过还好，我们有 ACL 这个玩意儿可以使用！这玩意挺有趣的，底下我们就来谈
一谈：
什么是 ACL？
ACL 是 Access Control List 的缩写，主要的目的是在提供传统的 owner,group,others 的
read,write,execute 权限之外的细部权限设定。ACL 可以针对单一使用者， 单一档案或目录来进行 r,w,x
的权限规范，对于需要特殊权限的使用状况非常有帮助。
由于 ACL 是传统的 Unix-like 操作系统权限的额外支持项目，因此要使用 ACL 必须要有档案系统的支持
才行。 目前绝大部分的档案系统都有支持 ACL 的功能，包括 ReiserFS, EXT2/EXT3, JFS, XFS 等等。 在
SuSE 这个版本当中，预设是有启动 ACL 控制的，不过在 CentOS 则预设没有启动 ACL。 所以等一下要使
用 ACL 的功能时，你必须要先启动你系统 filesystem 的支持才行喔！
那 ACL 主要可以针对哪些方面来控制权限呢？他主要可以针对几个项目：
• 使用者 (user)：可以针对使用者来设定权限；
• 群组 (group)：针对群组为对象来设定其权限；
• 预设属性 (mask)：还可以针对在该目录下在建立新档案/目录时，规范新数据的预设权限；
好了，再来看看如何让你的档案系统可以支持 ACL 吧！
如何启动 ACL
要让你的档案系统支持 ACL 非常的简单！假如要让你的 /home 支持 ACL 的话，可以直接这样做：
[root@linux ~]# mount -o remount,acl /home
[root@linux ~]# mount | grep /home
/dev/hda5 on /home type ext3 (rw,acl)
看到那个出现的 ACL 了吧！那就对了～如果没有出现这一行，你的档案系统是无法支持 ACL 的， 那下一
节的练习您可就无能为力了～那如果想要一开机就让你的档案系统支持 ACL 呢？ 呵呵！修改 /etc/fstab
就对了！将他改成类似底下的模样：
[root@linux ~]# vi /etc/fstab
/dev/hda5 /home ext3 defaults,acl 1 2
加入那一段特殊字体的数据，那么下次开机就能够支持 ACL 了！很简单吧！ ^_^
ACL 的设定技巧： getfacl, setfacl
好了，让你的 filesystem 启动 ACL 支持后，接下来该如何设定与观察 ACL 呢？ 很简单，利用这两个指
令就可以了：
• getfacl：取得某个档案/目录的 ACL 设定项目；
• setfacl：设定某个目录/档案的 ACL 规范。
先让我们来瞧一瞧 setfacl 如何使用吧！
[root@linux ~]# setfacl [-mxdb] 设定值
参数：
-m ：设定一个 ACL 规范；
-x ：取消一个 ACL 规范；
-b ：全部的 ACL 规范都移除；
-d ：设定预设的 ACL 规范，仅能针对目录使用。
最常用的就是那个 -m 的参数啦！用来定义一笔 ACL 的设定规范说。那么 ACL 该如何设定呢？ 不同的使
用者、群组与预设权限设定方法有点不同，不过，基本上有底下这三种简易的设定方法：
1. 针对使用者
设定值的规范为： u:[使用者账号列表]:[rwx]
例如针对 dmtsai 这个使用者来规范其权限为 rx ，则：
[root@linux ~]# setfacl -m u:dmtsai:rx somefilename
2. 针对群组来设定
设定值的规范为： g:[群组名]:[rwx]
例如针对 users 这个群组来规范其权限为 rw ，则：
[root@linux ~]# setfacl -m g:users:rw somefilename
3. 针对预设权限来规范，类似 umask 的功能
设定值的规范为： m:[rwx]
例如假设预设权限为 rwx，则：
[root@linux ~]# setfacl -m m:rwx somefilename
了解了上面的设定方式后，现在让我们来实际操作一下吧！假设：
• 你已经将 /home 这个独立的 partition 设定了 ACL 的支持了，
• 并且在 /home 底下设定了一个名称为 project 的目录，
• 该目录要给 eric 这个使用者，且属于 users 这个群组，预设权限应该是 770 ；
• 有个使用者账号名称为 jordan ，他属于 jordan 那个群组，但他想要进入到 project 那个目录
来工作， 意思是说，jordan 在该目录下需有 w 的权限才行；
• 有个使用者他是其它班级的老师，名称为 tip ，群组名亦为 tip ，他想要进入该目录查阅所有
档案数据， 但是不能够进行删除与新增的工作，亦即他不能拥有 w 的权限。
在传统的 Linux 档案权限中，要达成上述的功能时，你得要让 jordan 与 tip 这两个使用者加入 users
那个群组才行，但是 jordan 是希望可以在该目录内工作的，所以他必须要拥有 w 的权限， 而 tip 却仅
能读取，所以他不能拥有 w 的权限！哇！如此一来，就无法完成上述的交代事项了！ 此时我们只好透过 ACL
来单独的针对 tip/jordan 这两个使用者来设定他的权限吶！整个流程可以是这样的：
1. 建立该目录并规划好权限：
[root@linux ~]# mkdir /home/project
[root@linux ~]# chown eric:users /home/project
[root@linux ~]# chmod 770 /home/project
[root@linux ~]# ls -ld /home/project
drwxrwx--- 2 eric users 4096 Sep 5 15:54 /home/project/
# 瞧！已经将需要的目录规划好了！使用者/群组与权限都 OK 了；
2. 建立 jordan 的使用权限(需要有 w)：
[root@linux ~]# cd /home
[root@linux home]# setfacl -m u:jordan:rwx project
[root@linux home]# getfacl project
# file: project <==前面三行只是指出这个档名的传统 Linux 权限
# owner: eric
# group: users
user::rwx <==注意看，这是针对『预设使用者』的权限设定；
user:jordan:rwx <==这是针对 jordan 的权限设定
group::rwx <==这是针对『预设群组』的权限设定
mask::rwx <==这玩意儿则是预设属性啦！
other::---
# 上面这个输出共 8 行我们会在底下详细说明！
[root@linux home]# ls -ld project
drwxrwx---+ 2 eric users 4096 Sep 5 15:54 project
# 看看！多了一个 + 的标志喔！
那个 getfacl 指令可以用来取得某个文件名的 ACL 数据啦！至于输出的共 8 行数据你必须要这样看：
• 第 1-3 行：前面三行会显示出这个档案的 Linux 传统属性，包括使用者、群组与档名，预设会
用 # 开头作为说明；
• 接下来的每一行的输出会以底下的格式来处理：
针对的目标(使用者、群组等]:[各种账号列表]:[rwx]
针对的目标主要有：
 user 使用者
 group 群组
 mask 预设权限
 other 非本群组的其它使用者
各种账号列表中，如果没有任何数据，如 user::rwx ，则代表预设使用者账号；
主要有三个字段，用『 : 』来隔开三个字段；
• 第 4 行『user::rwx』：由于使用者列表字段中没有填写任何账号，所以代表这个权限是针对预
设使用者， 亦即是这个目录的拥有人 eric 啦，是 eric 的权限为『 rwx 』的意思说！
• 第 5 行『user:jordan:rwx』：使用者 jordan 在这个目录下具有 rwx 的权限的意思啦！
• 第 6 行『group::rwx』：没有填写群组名称，所以同样是预设群组，亦即是那个 users 啰， 该
群组的权限为『rwx』啦；
• 第 7 行『mask::rwx』：预设的 mask 为 rwx 的意思，这个 mask 是有用途的！底下会说明。
• 第 8 行『other::---』：指的就是其它的未规定的使用者与群组的权限了
好了，现在 jordan 这位朋友当他进入 /home/project 后，立刻就会拥有 rwx 的权限了！ 而不需要加入
users 这个群组呢！真是很方便吧！太好了！ 另外，你如何知道某个档名具有额外的 ACL 权限呢？可以
参考上面最终的输出结果中， 会发现 /home/project 这个目录的权限项目竟然是出现『 drwxrwx---+ 』
呢！ 那个多出来的『 + 』就是表示该档名有额外的 ACL 控件目啦！ 那接下来如何处理 tip 呢？同样使
用 ACL 来控制：
3. 设定 tip 这个使用者的权限数据：
[root@linux home]# setfacl -m u:tip:rx project
[root@linux home]# getfacl project
# file: project
# owner: eric
# group: users
user::rwx
user:tip:r-x <==瞧！多出来的咚咚啦！
user:jordan:rwx
group::rwx
mask::rwx
other::---
如此一来， tip 这位使用者则仅能进入该目录去读取而已，而无法进行写入的动作呢！ 是否很方便啊！
有了 ACL 的控件目后，您就可以将你系统内的有需要使用到特殊权限设定的目录进行细部设定， 让你的
系统变的更合理，更安全啊！
• ACL 内的 mask 项目
虽然这样就能够设定好一个 ACL 控件目，不过你还需要了解到在 ACL 内的 mask 所代表的意义喔！ 在上
面的那个小案例当中，我们并没有去设定这个 mask，mask 需要与使用者的权限进行逻辑运算 (AND) 后，
才是有效的权限吶(effective permission)！
举例来说，如果你觉得你的目录要让所有的人都暂时仅能读取不能写入时，可以将 ACL 内的 mask 设定为
rx 即可， 那其它人就不需要再额外的设定了！看看底下这个例子：
[root@linux ~]# cd /home
[root@linux home]# setfacl -m m:rx project
[root@linux home]# getfacl project
# file: project
# owner: eric
# group: users
user::rwx
user:tip:r-x
user:jordan:rwx #effective:r-x
group::rwx #effective:r-x
mask::r-x
other::---
上面的输出全部都是 getfacl 的输出结果，鸟哥并没有加工啊！ ^_^！ 原本的 jordan 具有『rwx』的权
限，而 mask 仅有『r-x』，两者去比较后 『两者都有的权限才会生效，就称为有效权限 (effective
permission) 啰』！ 所以，jordan 则仅会有 rx 的权限而已啊！这样对 mask 的用法瞭了吗？
一些常见的攻击手法与主机的保护方式
我们由图一了解到数据传送到本机时所需要经过的几道防线后， 现在您应该比较清楚为何我们常常在基础
篇里面一直谈到设定正确的权限可以保护您的主机了吧？ 那么除了前面的谈到的主机基本保护之外， 通
常人家是如何攻击你的 Linux 主机呢？底下我们就来谈一谈吧！ 先了解一下人家是如何攻击你的，我们
才有办法想到如何防御，您说是吧？！
• 取得账号信息后猜密码：
由于很多人喜欢用自己的名字来作为账号信息，因此账号的取得是很容易的！ 举例来说，如果你的朋友将
你的 email address 不小心泄漏出去，例如： dmtsai@your.host.name 之类的样式， 那么人家就会知道
你有一部主机，名称为 your.host.name，且在这部主机上面会有一个使用者账号， 账号名称为 dmtsai ，
之后这个坏家伙再利用某些特殊软件例如 nmap 来进行你主机的 port scan 之后，嘿嘿！他就可以开始透
过你主机有启动的软件功能来猜你这个账号的密码了！
另外，如果你常常观察你的主机登录文件，那你也会发现如果你的主机有启动 Mail server 的服务时， 你
的登录档就会常常出现有些怪家伙尝试以一些奇怪的常见账号在试图猜测你的密码， 举例来说像：admin,
administrator, webmaster .... 之类的账号，尝试来窃取你的私人信件。 如果你的主机真的有这类的账
号，而且这类的账号还没有良好的密码规划，那就容易『中标』！ 唉！真是麻烦！所以我们常讲，系统账
号千万不能给予密码，容易被猜密码啊！
这种猜密码的攻击方式算是最早期的入侵模式之一了，攻击者知道你的账号，或者是可以猜出来你的系统
有哪些账号， 欠缺的就只是密码而已， 因此他会『很努力的』去猜你的密码，此时，你的密码规划如果
不好的话，很容易就被攻击了！ 主机也很容易被绑架啊！所以，良好的密码设置习惯是很重要的。
不过这种攻击方式比较费时，因为目前很多软件都有密码输入次数的限制， 如果连续输入三次密码还不能
成功的登入，那该次联机就会被断线！ 所以，这种攻击方式日益减少，目前偶而还会看到就是了！这也是
初级 cracker 会使用的方式之一。 那我们要如何保护呢？基本方式是这样的：
• 减少信息的曝光机会：例如不要将 Email Address 随意散布到 Internet 上头；
• 建立较严格的密码设定规则：包括 /etc/shadow, /etc/login.defs 等档案的设定， 建议您可以
参考基础篇内的 账号管理那一章来规范你的使用者密码变更时间等等， 如果主机够稳定且不会
持续加入某些账号时，也可以考虑使用 chattr 来限制账号 (/etc/passwd, /etc/shadow) 的更
改；
• 完善的权限设定：由于这类的攻击方式会取得你的某个使用者账号的登入权限， 所以如果你的系
统权限设定得宜的话，那么攻击者也仅能取得一般使用者的权限而已， 对于主机的伤害比较有限
啦！所以说，权限设定是重要的；
• 利用系统的程序漏洞『主动』攻击：
由图一里面的第三个步骤中，我们知道如果你的主机有开放网络服务时， 就必须有启动某个网络软件嘛！
我们也知道由于软件可能撰写方式的问题，可能产生一些会被 cracker 乱用的臭虫程序代码，而这些臭虫
程序代码由于产生问题的大小，有分为 bug (臭虫，可能会造成系统的不稳定或当机) 与 Security (安全
问题，程序代码撰写方式会导致系统的使用权限被恶意者所掌握) 等问题。
当程序的问题被公布后，某些较高阶的 cracker 会尝试撰写一些针对这个漏洞的攻击程序代码， 并且将
这个程序代码放置到 cracker 常去的网站上面，藉以推销自己的『功力』..... 鸟哥要提醒的是，这种程
序代码『是很容易被取得的』。 当更多『盈盈美黛子(台语，闲闲没事干之意)』取得这些程序代码后，他
可能会想要『试一试这个攻击程序的威力』， 所以就拿来『扫射』一番，如果你八字比较轻，或者当天星
座学家说你比较倒霉时， 可能就会被不小心的攻击到......
这种攻击模式是目前最常见的，因为攻击者只要拿到攻击程序就可以进行攻击了， 『而且由攻击开始到取
得你系统的 root 权限不需要猜密码， 不需要两分钟，就能够立刻入侵成功』，所以『盈盈美黛子』们最
爱的就是这个咚咚了。 但这个玩意儿本身是靠『你主机的程序漏洞』来攻击的，所以，如果你的主机随时
保持在实时更新的阶段， 或者是关闭大部分不需要的程序，那就可以躲避过这个问题。因此，你应该要这
样做：
• 关闭不需要的网络服务：开的 port 越少，可以被入侵的管道越少， 一部主机负责的服务越单纯，
越容易找出问题点。看看前面谈到的 限制 Linux 的联机埠口  一章吧！
• 随时保持更新：这个没话讲！一定要进行的！参考前一章 网络升级套件。
• 关闭不需要的软件功能：举例来说，后面会提到的远程登入服务器 SSH 可以提供 root 由远程登
入，那么危险的事情当然要给他取消啊！^_^
• 利用社交工程作欺骗：
社交工程 (Social Engineering) 指的其实很简单，就是透过人与人的互动来达到『入侵』的目的！ @_@！
人与人的互动可以入侵你的主机？鸟哥在呼咙你吗？当然不是。
近日在台湾的社会你不是常看到某些人会以『退税、中奖、花小钱买贵重物品』等名义来欺骗善良老百姓，
让老百姓掏出口袋里的金钱给那些可恶的金光党吗？社交工程也是类似的方法。在大公司里面， 或许你可
能会接到这样的电话：『我是人事部门的经理，我的账号为何突然间不能登入了？ 你给我看一看，恩？干
脆直接帮我另建一个账号，我告诉你我要的密码是....』。如果你一时不查给他账号密码的话， 你的主机
可能就这样被绑走了～
社交工程的欺骗方法多的是，包括使用『好心的 email 通知』、『警告信函』、『中奖单』等等， 在在
都是要欺骗你的账号密码，有的则利用钓鱼方式来欺骗你在某些恶意网站上面输入你的账号密码， 很讨厌
的啦！那要如何防范呢？
• 追踪对谈者：不要一味的相信对方，你必须要有信心的向上呈报， 不要一时心慌就中了计！
• 不要随意透露账号/密码等信息：最好不要随意在 Internet 上面填写这些数据， 真的很危险的！
因为在 Internet 上面，你永远不知道对方屏幕前面坐着的是谁？
• 利用程序功能的『被动』攻击：
啥？除了主动攻击之外，还有所谓的被动攻击喔？没错啊，『系金ㄟ』！那如何作被动攻击呢？ 那就得要
由『恶意网站』讲起了。如果你喜欢上网随意浏览的话，那么有的时候可能会连上一些广告很多， 或者是
一堆弹出式窗口的网站，这些网站有时还会很好心的『提供你很多好用的软件自动下载与安装』的功能， 如
果该网站是你所信任的，例如 Red Hat, CentOS, Windows 官网的话，那还好， 如果是一个你也不清楚他
是干嘛的网站，那你是否要同意下载安装该软件？
如果你常常在注意一些网络危机处理的相关新闻时，常会发现 Windows 的浏览器 (IE) 有问题， 有时则
是全部的浏览器 (Firefox, Netscap, IE...) 都会出现问题。那你会不会觉得奇怪啊， 怎么『浏览器也
会有问题？』这是因为很多浏览器会主动的答应对方 WWW 主机所提供的各项程序功能， 或者是自动安装
来自对方主机的软件，有时浏览器还可能由于程序发生安全问题， 让对方 WWW 浏览器得以传送恶意程序
代码给你的主机来执行，嘿嘿！中标！
那你又会想啊，那我干嘛浏览那样的恶意网站？喝！总是会有些粗心大意的时候啊！ 如果你今天不小心收
到一个 email ，里面告诉你你的银行账号有问题， 希望你赶紧连上某个网页去看看你的账号是否在有问
题的行列中，你会不会去？ 如果今天有个网络消息说某某网页在提供大特价商品，那你会不会去碰碰运
气？ 都是可能的啊！不过，这也就很容易被对方攻击到了。
那如何防备啊？当然建立良好的习惯最重要了：
• 随时更新主机上的所有套件：如果你的浏览器是没有问题的， 那对方传递恶意程序代码时，你的
浏览器就不会执行，那自然安全的多啊！
• 较小化软件的功能：举例来说，让你的收信软件不要主动的下载档案， 让你的浏览器在安装某些
软件时，要通过你的确认后才安装，这样就比较容易克服一些小麻烦；
• 不要连接到不明的主机：其实鸟哥认为这个才最难！ 因为很多时候我们都用 google 在搜寻问题
的解决之道啊，那你如何知道对方是否是骗人的？ 所以，前面两点防备还是很重要的！不要以为
没有连接上恶意网站就不会有问题啊！
• 蠕虫或木马的 rootkit：
rootkit 意思是说可以取得 root 权限的一群工具组 (kit)，就如同前面主动攻击程序漏洞的方法一样，
rootkit 主要也是透过主机的程序漏洞。不过， rootkit 也会透过社交工程让使用者下载、安装 rootkit
软件， 结果让 cracker 得以简单的绑架对方主机啊！
rootkit 除了可以透过上述的方法来进行入侵之外，rootkit 还会伪装或者是进行自我复制， 举例来说，
很多的 rootkit 本身就是蠕虫或者是木马间谍程序。蠕虫会让你的主机一直发送封包向外攻击， 结果会
让你的网络频宽被吃光光，例如 2001-2003 年间的 Nimda, Code Red 等等；至于木马程序 (Trojan Horse)
则会对你的主机进行开启后门 (开一个 port 来让 cracker 主动的入侵)，结果就是....绑架、绑架、绑
架！
rootkit 其实挺不好追踪的，因为很多时候他会主动的去修改系统观察的指令， 包括 ls, top, netstat,
ps, who, w, last, find 等等，让你看不到某些有问题的程序， 如此一来，你的 Linux 主机就很容易被
当成是跳板了！有够危险！那如何防备呢？
• 不要随意安装不明来源的档案或者是不明网站的档案数据；
• 不要让系统有太多危险的指令：例如 SUID/SGID 的程序， 这些程序很可能会造成使用者不当的
使用，而使得木马程序有机可趁！
• 可以定时以 rkhunter 之类的软件来追查：有个网站提供 rootkit 程序的检查，你可以前往下载
与分析你的主机：
http://www.rootkit.nl/projects/rootkit_hunter.html
• DoS 攻击法 ( Denial of Service )
这类型的攻击中文翻译成『阻断式攻击』，这种攻击法也很要命，而且方法有很多，最常见的就属 SYN Flood
攻击法了！还记得我们在网络基础里面提到的，当主机接收了一个带有 SYN 的 TCP 封包之后，就会启用
对方要求的 port 来等待联机，并且发送出回应封包 (带有 SYN/ACK 旗标的 TCP 封包)，并等待 Client
端的再次回应。
好了，在这个步骤当中我们来想一想，如果 cient 端在发送出 SYN 的封包后，却将来自 Server 端的确
认封包丢弃，那么您的 Server 端就会一直空等，而且 Client 端可以透过软件功能，在短短的时间内持
续发送出这样的 SYN 封包，那么您的 Server 就会持续不断的发送确认封包，并且开启大量的 port 在空
等～呵呵！等到全部主机的 port 都启用完毕，那么.....系统就挂了！
更可怕的是，通常攻击主机的一方不会只有一部！他会透过 Internet 上面的僵尸主机 (已经成为跳板，
但网站主却没有发现的主机) 发动全体攻击，让你的主机在短时间内就立刻挂点。 这种 DoS 的攻击手法
比较类似『玉石俱焚』的手段， 他不是入侵您的系统，而是要让您的系统挂点呢！ 最常被用来作为阻断
式服务的网络服务就是 WWW 了，因为 WWW 通常得对整个 Internet 开放服务。
这种攻击方法也是最难处理的，因为要嘛就得要系统核心有支持自动抵挡 DoS 攻击的机制， 要嘛您就得
要自行撰写侦测软件来判断！真是麻烦啊～而除非您的网站非常大， 并且『得罪不少人』，否则应该不会
被 DoS 攻击啦！ ^_^
• 其它：
上面提到的都是比较常见的攻击方法，是还有一些高竿的攻击法啦， 不过那些攻击法都需要有比较高的技
术水准，例如 IP 欺骗。他可以欺骗你主机告知该封包来源是来自信任网域， 而且透过封包传送的机制，
由攻击的一方持续的主动发送出确认封包与工作指令。 如此一来，你的主机可能就会误判该封包确实有响
应，而且是来自内部的主机。
不过我们知道因特网是有路由的，而每部主机在每一个时段的 ACK 确认码都不相同， 所以这个方式要达
成可以登入，会比较麻烦，所以说，不太容易发生在我们这些小型主机上面啦！ 不过你还是得要注意一下
说：
• 设定规则完善的防火墙：利用 Linux 内建的防火墙软件 iptables 建立较为完善的防火墙，可以
防范部分的攻击行为；
• 核心功能：这部份比较复杂，您必须要对系统核心有很深入的了解， 才有办法设定好你的核心网
络功能。
• 登录文件与系统监控：你可以透过分析登录文件来了解系统的状况， 另外也可以透过类似 MRTG
之类的监控软件 来实时了解到系统是否有异常，这些工作都是很好的努力方向！
• 主机防护小结语：
要让你的系统更安全，没有『三两三』是没办法达成的！我们也一直鼓吹， 『维护网站比架设网站还要重
要』的观念！因为『一人得道鸡犬升天』，同样的道理：『一人中标全员挂点』， 不要以为你的主机没有
啥重要数据，被入侵或被植入木马也没有关系， 因为我们的服务器通常会对内部来源的主机规范的较为宽
松，如果你的主机在公司内部， 但是不小心被入侵的话，那么贵公司的服务器是否就会暴露在危险的环境
当中了？
另外，在蠕虫很『发达』的年代，我们也会发现只要局域网络里面有一部主机中标， 整个局域网络就会无
法使用网络了，因为频宽已经被蠕虫塞爆！ 如果老板发现他今天没有办法收信了，但无法收信的原因并非
服务器挂点， 而是因为内部人员的某部个人计算机中了蠕虫，而那部主机中蠕虫的原因只是因为该使用者
不小心去看了一下色情网站， 你觉得老板会高兴的跟该员工一起看色情网站还是 fire 掉该人员？
所以啊，主机防护还是很重要的！不要小看了！提供几个方向给大家思考看看吧：
1. 建立完善的登入密码规则限制；
2. 完善的主机权限设定；
3. 设定自动升级与修补套件漏洞、及移除危险套件；
4. 在每项系统服务的设定当中，强化安全设定的项目；
5. 利用 iptables, TCP_Wrappers 强化网络防火墙；
6. 利用主机监控软件如 MRTG 与 logwatch 来分析主机状况与登录文件；
被入侵后的修复工作
如果你的主机被入侵的话，而你也由于了解到主机监控的需要，所以在最短的时间内发现此一事件， 那么
该如何针对这个被入侵的主机来修复？那如果你要修复的话，你这个网管人员还需要哪些额外的技能？ 底
下我们就来谈一谈。
网管人员的额外技巧与任务
从前一小节的分析当中，您会发现网管还真的是挺累的，他需要对于操作系统有一定程度的熟悉， 对于程
序的运作 (process) 与权限概念，则需要更了解！否则就麻烦了！那除了操作系统的基本概念之外， 咱
们网管还需要啥特殊技巧呢？当然需要啊！其实一部主机最常发生问题的状况， 都是由『内部的网络误用
所产生的』，所以啊，你只管好主机而已是『没有办法杜绝问题』的啦！ 底下就来谈谈你还需要啥技巧呢？
• 了解什么是需要保护的内容：
我的天吶，还要知道什么是需要保护的呀？呵呵！没错，就是如此！由刚刚我们知道的主机入侵方法当中，
不难了解，只要有人坐在您的主机前面，那么任何事都有可能会发生！因此，如果您的主机相当的重要，  请
『不要让任何人靠近！』您可以参考一下汤姆克鲁斯在『不可能的任务』里面要窃取一部计算机内的数据
的困难度！ ^_^""
• 硬件：能锁就锁吧！
• 软件：还包含最重要的数据呢！
• 预防黑客( Black hats )的入侵：
这可不是开玩笑的，什么是黑客呀！这是因为原本在西部电影当中，坏人都是戴黑色帽子的， 所以之前的
人们就称网络攻击者为 Black hats 啦！在预防这方面的攻击者时，除了严格管制网络的登入之外， 还需
要特别控制原本您的主机中的人物！就我们小网站来说，不要以为好朋友就随便他啦！ 他说要指定密码是
跟他的账号相同比较好记，您就答应他！等到人家用他的密码登入您的主机，并破坏您的主机， 那可就得
不偿失了！如果是大企业的话，那么员工使用网络时，也要分等级的呢！ ^_^
• 主机环境安全化：
没什么好讲的，除了多关心，还是多关心！仔细的分析登录档，常常上网看看最新的安全通告，这都是最
基础的！ 还包含了以最快的速度更新有问题的套件！因为，越快更新您的套件，就越快可以杜绝黑客的入
侵！
• 防火墙规则的订定：
这部份比较麻烦一些啦！因为您必需要不断的测试测试再测试！以取得最佳化的网络安全设定！ 怎么说呢？
要晓得的是，如果您的防火墙规则订定得太多的时候， 那么一个资料封包就要经过越多的关卡才能完整的
通过防火墙，以进入到主机内部！嘿嘿！ 这可是相当的花费时间的！会造成主机的效能不彰！特别留意这
一点呢！
• 实时维护您的主机：
就像刚刚说的，您必需要随时维护您的主机，因为，防火墙不是一经设定之后就不用在再他了！ 因为，再
严密的防火墙，也会有漏洞的！这些漏洞包括防火规则设定不良、利用较新的侦测入侵技术、 利用您的旧
软件的服务漏洞等等！所以，必需要实时维护您的主机呀！这方面除了分析 log files 之外，也可以藉由
实时侦测来进行这个工作！例如 PortSentry 就是蛮不错的一套软件呢！
• 良好的教育训练课程：
不是所有的人都是计算机网络高手，尤其虽然现在信息爆炸但是仍然有很多的机会会遇到计算机白痴呀！
这个时候，要晓得的是，我们对于内部网域通常没有太多的规范，那如果他用内部的计算机去做坏事怎么
办？ 有时候还是无心的～挖哩～所以说，需要特别的教育训练课程呀！这也是公司需要网管的主因之一！
• 完善的备份计划：
天有不测风云，人有旦夕祸福呀！什么人都不知道什么时候会有大地震、我们也都不知道什么时候会突然
的硬盘挂掉去～ 所以说，完善的备份计划是相当重要的！此外，大概没有人会说他的主机是 100% 的安全
吧！ 那如果你的系统被入侵，造成数据的损毁时，你要如何复原你的主机啊？呵呵！一个良好的网站管理
人员， 无时无刻都会进行重要数据的备份的！很重要啊！ 这一部份请参考一下基础学习篇之 Linux 主机
备份的内容吧！ 本书后续的远程联机服务器 SSH 章节内也会提到一个很棒的 rsync 工具，您可以瞧瞧！
入侵恢复工作
所谓『百密一疏』啊，人不是神，总会有考虑不周的情况，万一您的主机就因为这『一疏』导致被入侵了，
那该怎么办？由上面的说明当中，我们知道『木马』是很严重的，因为他会在您的系统下开个后门(Back door)
让攻击者可以登入您的主机，而且还会窜改您 Linux 上面的程序，让您找不到该木马程序！怎么办？
很多朋友都习惯『反正只要将 root 的密码改回来就好了』 这样的观点，事实上，那样一部主机还是有被
做为中继站的危险啊！所以， 万一您的主机被入侵了，最好的方法还是『重新安装 Linux 』会比较干净！
那该如何重新安装呢？很多朋友一再地安装，却一再地被入侵～为什么呢？因为他没有『记取教训』啊！
呵呵！ 底下我们就来谈一谈，一部被入侵的主机应该如何修复比较好？
1. 立即拔除网络线：
既然发现被入侵了，那么第一件事情就是拿掉网络功能！拿掉网络功能最简单的作法自然就是拔
掉网络线了！ 事实上，拿掉网络线最主要的功能除了保护自己之外，还可以保护同网域的其它主
机。怎么说呢？举个最近 (2003/08) 发病的疾风病毒好了，他会感染同网域之内的其它主机喔！
所以，拔除网络线之后， 远程的攻击者立即就无法进入您的 Linux 主机，而且您还可以保护网
域内的其它相关主机啊！
2. 分析登录文件信息，搜寻可能的入侵途径：
被入侵之后，决不是只要重新安装就好，还需要额外分析 『为什么我的主机这一次会被入侵，对
方是如何入侵的？』， 如果您能够找出问题点，那么不但您的 Linux 功力立刻增强了，主机也
会越来越安全喔！ 而如果您不知道如何找出被入侵的可能途径，那么重新安装后，下次还是可能
被以同样的方法入侵啊！ 粉麻烦的啦！好了，那该如何找出入侵的途径呢？
o 分析登录档：低级的 cracker 通常仅是利用工具软件来入侵您的系统，所以我们可以藉
由分析一些主要的登录档来找出对方的 IP 以及可能有问题的漏洞。可以分析
/var/log/messages, /var/log/secure 还有利用 last 指令来找出上次登入者的信息。
o 检查主机开放的服务：很多 Linux 使用者常常不晓得自己的系统上面开了多少的服务？
我们说过， 每个服务都有其漏洞或者是不应该启用的增强型或者是测试型功能，所以，
找出您系统上面的服务， 并且检查一下每个服务是否有漏洞，或者是在设定上面有了缺
失，然后一个一个的整理吧！
o 查询 Internet 上面的安全通报： 透过安全通报来了解一下最新的漏洞信息，说不定您
的问题就在上面！
3. 重要数据备份：
主机被入侵后，显得问题相当的严重，为什么呢？因为主机上面有相当重要的数据啊！ 如果主机
上面没有重要的数据，那么直接重新安装就好了！所以，被入侵之后，检查完了入侵途径， 再来
就是要备份重要的数据了。好了，问个问题，什么是『重要数据』？ who, ps, ls 等等指令是重
要数据吗？还是 httpd.conf 等设定文件是重要数据？又或者是 /etc/passwd, /etc/shadow 才
是重要数据？
呵呵！基本上，重要的数据应该是『非 Linux 系统上面原有的数据』，例如 /etc/passwd,
/etc/shadow, WWW 网页的数据, /home 里面的使用者重要档案等等，至于 /etc/*, /usr/, /var
等目录下的数据，就不见得需要备份了。 注意：不要备份一些 binary 执行文件，因为 Linux 系
统安装完毕后本来就有这些档案，此外， 这些档案也很有可能『已经被窜改过了』，那备份这些
数据，反而造成下次系统还是不干净！
4. 重新全新安装：
备份完了数据，再来就是重新安装 Linux 系统了。而在这次的安装中， 您最好选择适合您自己
的安装套件即可，不要全部套件都给他安装上去啊！挺危险的！
5. 套件的漏洞修补：
记得啊，重新安装完毕之后，请立即更新您的系统套件，否则还是会被入侵的啦！鸟哥喜欢先在
其它比较干净的环境下将 Internet 上面的漏洞修补套件下载下来，然后烧录起来，然后拿到自
己的刚刚安装完成的系统上面，mount CD 之后全部给他更新，更新之后，并且设定了相关的防火
墙机制，同时进行下一步骤『 关闭或移除不需要的服务』后，我才将网络线插上主机的网络卡上！
因为鸟哥不敢确定在安装完毕后，连上 Internet 去更新套件的这段时间，会不会又受到入侵攻
击说....
6. 关闭或移除不需要的服务：
这个重要性不需要再讲了吧？！启用越少的服务，系统当然可以被入侵的可能性就比较低。
7. 数据回复与恢复服务设定：
刚刚备份的数据要赶紧的复制回来系统，同时将系统的服务再次的重新开放，请注意， 这些服务
的设定最好能够再次的确认一下，避免一些不恰当的设定参数在里头喔！
8. 连上 Internet：
所有的工作都进行的差不多了，那么才将刚刚拿掉的网络线接上来吧！恢复主机的运作了！
经过这一连串的动作后，您的主机应该会恢复到比较干净的环境，此时还不能掉以轻心， 最好还是参考防
火墙的设定，并且多方面的参考 Internet 上面一些老手的经验，好让您的主机可以更安全一些！
重点回顾
• 要管制登入服务器的来源主机，得要了解网络封包的特性，这主要包括 TCP/IP 的封包协议， 以
及重要的 Socket Pair ，亦即来源与目标的 IP 与 port 等。在 TCP 封包方面，则还得了解
SYN/ACK 等封包状态；
• TCP 封包要进入我们 Linux 本机，至少需要通过 IP Filter, super daemon/TCP Wrappers,
Daemons, 密码验证功能 等等步骤；
• 主机的基本保护之一，就是拥有正确的权限设定。而复杂的权限设定可以利用 ACL 或者是
SELinux 来辅助；
• ACL 必须要让 Filesystem 支持，故可以在 /etc/fstab 内加入 acl 的控制参数；
• 关闭 SELinux 可在 /etc/selinux/config 档案内设定，亦可在核心功能中加入 selinux=0 的项
目；
• ACL 主要可针对 user, group, mask 来设定，可针对单一个人账号设定权限；
• 设定 ACL 的方法为使用 setfacl, 查阅则以 getfacl 指令来动作；
• ACL 内的 mask 是很重要的，必须与使用者的权限进行逻辑 AND 的运算，才会得到正确的最终权
限；
• rootkit 为一种取得 root 的工具组，您可以利用 rkhunter 来查询您主机是否被植入 rootkit；
• 网管人员应该注意在员工的教育训练还有主机的完善备份方案上面；
• 一些所谓的黑客软件，几乎都是透过您的 Linux 上面的套件漏洞来攻击 Linux 主机的；
• 套件升级是预防被入侵的最有效方法之一；
• 良好的登录档分析习惯可以在短时间内发现系统的漏洞，并加以修复。
课后练习
• 我老是发现我的系统怪怪的，似乎有点停顿的模样，怀疑可能是 CPU 负荷太大，所以要去检查一
下系统相关的信息。请问，我该以什么指令去检查我的系统相关的信息？
可以使用 top, sar, free, ps -aux, uptime, last 等功能去查询系统的相关信息喔！然后再以
kill 之类的指令删除；
• 我怀疑我的系统上面有过多的具有 SUID 的档案存在，导致一般使用者可以随意的取得 root 的
权限，请问，我要如何找出这些具有 SUID 权限的档案？
因为 SUID 是 4000 这个权限的模样，所以我可以这样做：
find / -perm +4000
• 我由国内一些 ftp 网站上下载了 Red Hat 公司释出的套件，我想安装他，但又不知道该套件档
案是否被修改过！ 请问我该如何确定这个套件的可用性？
利用最简易的 MD5 编码来测试一下，例如『 md5sum 套件名称』，再比对与原始套件释出的 MD5
数据是否相同！？
• 如果我发现使用『 setfacl -m u:dmtsai:rwx /path/to/file 』时，系统却显示『setfacl:
Operation not supported』， 你认为是哪里出问题？
这是由于您的 filesystem 没有启用 ACL 支持，或者是系统的核心不支持。 请先使用 mount -o
remount,acl /mount_point 测试看能否支持 ACL ，若不支持时，则可能是由于核心版本太旧了。
• 如果要设定 dmtsai 可以使用 /home/project 这个目录 (假设 /home 已经支持 ACL)，在该目录
内 dmtsai 可以拥有完整的权限。请问该如何设定该目录？
除了使用 setfacl -m u:dmtsai:rwx /home/project 之外，还需要设定 setfacl -m m:rwx
/home/project ， 因为 ACL 在目录方面，必须透过使用者权限及 mask 的逻辑运算后才能生效！
• SELinux 是否为防火墙？
SELinux 并非防火墙，他是用来作为更细部权限设定的一个核心模块。
• 良好的密码规划是防备主机的第一要务，请问 Linux 系统当中，关于密码相关的档案与规则设定
在哪些档案里面？
密码的设定规则在 /etc/login.defs 里面！至于密码档案在 /etc/shadow 内！
• 简易说明，当一部主机被入侵之后，应该如何处理？
找出问题、重新安装、漏洞修补、数据还原！请参考本章最后一节的说明。
____________________________________________________________

Linux 防火墙与 NAT 主机
最近更新日期：2006/09/15
在谈完了基本的网络安全观念之后，这个章节主要就要针对『防火墙』来进行介绍了！目前的防火墙机制
主要是以 Linux Kernel 2.6 版的 iptables 为主的，而 iptables 可以使用指令来下达，也可以透过编写 shell
script 来进行指令的整合。鸟哥本人比较习惯使用 scripts 来进行 iptables 的机制规划呢！除了  iptables 之
外，事实上，比较简单的还有 TCP Wrappers 这个玩意儿，他则主要是针对某些服务来进行管理的吶！本
章的内容主要就是在介绍这两个重要的防火墙软件了！ 
1. 本章的行前准备工作
2. 认识防火墙
 2.1 为何需要防火墙
 2.2 Linux 系统上防火墙的主要类别
 2.3 防火墙的一般线路布线与抵挡技巧
 2.4 防火墙的使用限制
3. Linux 的封包过滤机制： iptables
 3.1 不同 Linux 核心版本的防火墙软件
 3.2 iptables 的表格与封包进入流程
 3.3 本机的 iptables 语法
 规则的清除与观察
 定义预设政策 (policy)
 封包的基础比对 IP/netmask I/O 装置
 TCP, UDP 的规则比对
 状态模块：MAC 与 RELATED
 ICMP 封包规则的比对
 3.4 防火墙的记录、回复与测试
 3.5 IPv4 的核心管理功能：/proc/sys/net/ipv4/*
4. 本机防火墙的一个实例
 4.1 规则草拟
 4.2 实际设定
5. NAT 主机的设定
 5.1 什么是 NAT？ SNAT？ DNAT？
 5.2 最阳春 NAT 主机： IP 分享功能
 5.3 iptables 的额外核心模块功能
 5.4 在防火墙后端之网络服务器 DNAT 设定
6. 重点回顾
7. 课后练习
8. 参考数据
9. 针对本文的建议：http://phorum.vbird.org/viewtopic.php?p=114475
本章的行前准备工作
由于这个章节里面谈到非常多的封包概念，包括 MAC, IP, TCP, UDP, ICMP 等协议， 以及如何抵挡外部 IP
来源的防火墙基础，还有 IP/netmask 的整体网域写法等等。 而鸟哥对于您学习防火墙的建议是希望你可
以使用 shell script 来撰写脚本，如此一来可以让你的防火墙规则比较清晰一点。所以在您开始了解底
下的资料之前， 希望你可以先阅读过相关的数据了：
• 已经认识 Shell 以及 Shell script；
• 已经阅读过网络基础那一个章节的内容；
• 已经阅读过前一篇认识网络安全；
• 已经阅读过 路由器那一章节的内容，了解路由的概念；
• 最好拥有两部主机以上的小型局域网络环境，以方便测试防火墙；
• Linux 主机上最好有两张网卡，可以进行多种测试，并架设 NAT 主机；
• 使用 uname -r 确认你的核心是 2.4 或 2.6 版；
若准备妥当了，赶紧来开始进行吧！
认识防火墙
网络安全除了随时注意套件的漏洞，以及网络上的安全通报之外，你最好能够依据自己的环境来订定防火
墙机制， 这样对于你的网络环境，会比较有保障一点喔！那么什么是防火墙呢？ 其实防火墙就是在管制
进入到我们网域内的主机(或者可以说是网域)的资料封包的一种机制， 例如我们在前一章节认识网络安全
当中提到的 iptables 就是一种防火墙机制了。当然了，更广义的来说， 只要能够分析与过滤进出我们管
理之网域的封包数据，就可以称为防火墙。
而这个防火墙又可以分为硬件防火墙与本机的软件防火墙。硬件防火墙是由厂商设计好的主机硬件， 这部
硬件防火墙内的操作系统主要以提供封包数据的过滤机制为主，并将其它的功能拿掉。因为单纯作为防火
墙功能而已， 因此封包过滤的速度与效率较佳。至于软件防火墙呢？那就是我们这个章节要来谈论的啊！
软件防火墙本身就是在保护系统网络安全的一套软件(或称为机制)，例如 iptables 与 TCP Wrappers 都
可以称为软件防火墙。
无论怎么分，反正防火墙就是用来保护我们网络安全的咚咚就对啦！呵呵！我们这个章节主要在介绍 Linux
系统本身提供的软件防火墙的功能，那就是 iptables 。至于 TCP Wrappers 请前往基础篇的 认识系统服
务 参考参考喔！
为何需要防火墙
基本上，如果你的系统 (1)已经关闭不需要而且危险的服务； (2)已经将整个系统的所有套件都保持在最
新的状态； (3)权限设定妥当且定时进行备份工作； (4)已经教育使用者具有良好的网络、系统操作习惯。
那么你的系统实际上已经颇为安全了！要不要架设防火墙？那就见仁见智啰！
不过，毕竟网络的世界是很复杂的，而 Linux 主机也不是一个简单的东西， 说不定哪一天你在进行某个
软件的测试时，主机突然间就启动了一个网络服务， 如果你没有管制该服务的使用范围，那么该服务就等
于对所有 Internet 开放， 那就麻烦了！因为该服务可能可以允许任何人登入你的系统，那不是挺危险？
所以啰，防火墙能作什么呢？防火墙最大的功能就是帮助你『限制某些服务的存取来源』！ 举例来说： (1)
你可以限制档案传输服务 (FTP) 只在子网域内的主机才能够使用，而不对整个 Internet 开放； (2)你可
以限制整部 Linux 主机仅可以接受客户端的 WWW 要求，其它的服务都关闭； (3)你还可以限制整部主机
仅能主动对外联机，对我们主机主动联机的封包状态 (TCP 封包的 SYN flag) 就予以抵挡等等。 这些就
是最主要的防火墙功能了！
所以鸟哥认为，防火墙最重要的任务就是在规划出：
• 切割被信任(如子网域)与不被信任(如 Internet)的网段；
• 划分出可提供 Internet 的服务与必须受保护的服务；
• 分析出可接受与不可接受的封包状态；
当然啦，咱们 Linux 的 iptables 防火墙软件还可以进行更细部深入的 NAT (Network Address
Translation) 的设定，并进行更弹性的 IP 封包伪装功能，不过，对于单一主机的防火墙来说， 最简单
的任务还是上面那三项就是了！所以，你需不需要防火墙呢？理论上，当然需要！ 而且你必须要知道『你
的系统哪些数据与服务需要保护』，针对需要受保护的服务来设定防火墙的规则吧！ 底下我们先来谈一谈，
那在 Linux 上头常见的防火墙类型有哪些？
Linux 系统上防火墙的主要类别
除了以软件及硬件作为防火墙的分类之外，我们也可以使用 防火墙对于数据封包的取得方式来进行分类。
主要可以分为两大类， 分别是代理服务器 (Proxy) 以及 IP Filter。在代理服务器方面， 由名称我们就
可以知道，代理服务器仅是代理 Client 端去向 Internet 要求数据，所以 Proxy 其实已经将可代理的协
议限制的很少很少，并且由于内部与外部计算机的并不能直接互通， 所以可以达到良好的保护效果；另一
种则是上面提到的 IP fileter 啦！利用封包过滤的方式来达到防火墙的目的！
• IP filter (封包过滤机制)
直接使用进入本机的 TCP/IP 上面的封包协议来进行过滤分析，例如利用 TCP/IP 封包表头的 IP 来源、
Port number 等数据进行过滤，以判断该封包是否能够进入本机取得本机资源。由于这种方式可以直接分
析最底层的封包表头数据， 所以包括硬件地址(MAC), 软件地址 (IP), TCP, UDP, ICMP 等封包的信息都
可以进行过滤分析的功能， 因此用途非常的广泛。
在 Linux 上面我们使用核心内建的 iptables 软件来作为防火墙封包过滤的机制， 由于 iptables 是核
心内建的功能，因此他的效率非常的高！非常适合于一般小型环境的设定呢！ 他利用一些封包过滤的规则
设定，来定义出什么数据可以接收，什么数据需要剔除，以达到保护主机的目的喔！
• Proxy (代理服务器)
其实代理服务器是一种网络服务 (service, daemon)，他可以『代理』使用者的需求， 而代为前往服务器
取得相关的资料。就有点像底下这个图示吧：
图一、Proxy Server 的运作原理简介
以上图为例，当 Client 端想要前往 Internet 取得 WWW 的数据时，他取得数据的流程是这样的：
1. 他会向 proxy server 要求数据，请 proxy 帮忙处理；
2. Proxy 可以分析使用者的 IP 来源是否合法？使用者想要去的 WWW 服务器是否合法？ 如果这个
client 的要求都合法的话，那么 Proxy 就会主动的帮忙 client 前往 WWW 服务器取得数据；
3. Internet 所回传的数据是传给 Proxy server 的喔，所以 WWW 服务器上面看到的是 Proxy
Server 的 IP 啰；
4. 最后 Proxy 将 client 的要求传回给 client。
这样了解了吗？没错， client 并没有直接连上 Internet ，所以在实线部分(步骤 1, 4)只要 Proxy 与
Client 可以联机就可以了！此时 client 甚至不需要拥有 public IP 哩！而当有人想要攻击 client 端
的主机时， 除非他能够攻破 Proxy server ，否则是无法与 client 联机的啦！
另外，一般 proxy 主机通常仅开放 port 80, 21, 20 等 WWW 与 FTP 的埠口而已， 而且通常 Proxy 就
架设在 Router 上面，因此可以完整的掌控局域网络内的对外联机！ 让你的 LAN 变的更安全啊！更详细
的 Proxy 设定我们会在后续的 代理服务器 章节当中提及的！
在这个章节中，我们先不谈 Proxy 这个东西，而是介绍过滤机制的 iptables 啰！
防火墙的一般线路布线与抵挡技巧
由前面的说明当中，您应该可以了解到一件事，那就是防火墙除了可以『 保护防火墙机制 (iptables) 本
身所在的那部主机』之外，还可以『 保护防火墙后面的主机或 PC』。呵呵！ 也就是说，防火墙除了可以
防备主机被入侵之外， 他还可以架设在路由器上面藉以控管进出本地端网域 (LAN) 的网络封包。 这种规
划对于内部私有网域的安全也有一定程度的保护作用呢！底下我们稍微谈一谈目前常见的防火墙配置吧：
• 单一 Linux 主机兼任防火墙功能：
防火墙除了可以作为 Linux 本机的基本防护之外，他还可以架设在路由器上面以管控整个局域网络的封包
进出。 因此，在这类的防火墙上头通常至少需要有两个接口，将可信任的内部与不可信任的 Internet 分
开， 所以可以分别设定两块网络接口的防火墙规则啦！整个环境如同下列图二所示。
在图二中，由于防火墙是设定在所有网络封包都会经过的路由器上头， 因此这个防火墙可以很轻易的就掌
控到局域网络内的所有封包， 而且你只要管理这部防火墙主机，就可以很轻易的将来自 Internet 的不良
网络封包抵挡掉吶。 只要管理一部主机就能够造福整的 LAN 里面的 PC，很划算的啦。
如果你想要将局域网络控管的更严格的话，那你甚至可以在这部 Linux 防火墙上面架设更严格的代理服务
器， 让客户端仅能连上你所开放的 WWW 服务器而已，而且还可以透过代理服务器的登录文件分析功能， 明
确的查出来那个使用者在某个时间点曾经连上哪些 WWW 服务器，您瞧瞧！厉害吧！ 如果在这个防火墙上
面再加装类似 MRTG 的流量监控软件，还能针对整个网域的流量进行监测。 这样配置的优点是：
• 因为内外网域已经分开，所以安全维护在内部可以开放的权限较大！
• 安全机制的设定可以针对 Linux 主机来维护即可！
• 对外只看的到 Linux 主机，所以对于内部可以达到有效的安全防护！
图二、单一 Linux 防火墙主机
• 单一 Linux 防火墙，但 LAN 内另设防火墙
一般来说，我们的防火墙对于 LAN 的防备都不会设定的很严格，因为是我们自己的 LAN 嘛！所以是信任
网域之一啰！不过，最常听到的入侵方法也是使用这样的一个信任漏洞！ 因为您不能保证所有使用企业内
部计算机的使用者都是公司的员工，也无法保证您的员工不会『搞破坏！』 更多时候是由于某些外来访客
利用移动式装置 (笔记型计算机) 连接到公司内部的无线网络来加以窃取企业内部的重要信息。
呵呵！所以，如果您有特别重要的部门需要更安全的保护网络环境，那么将 LAN 里 面再加设一个防火墙，
将安全等级分类，那么将会让您的重要数据获得更佳的保护喔！ 整个架构有点像下图三所示。
图三、单一 Linux 防火墙主机，但 LAN 内另设防火墙
• 在防火墙后端的主机设定
还有一种更有趣的设定，那就是将提供网络服务的服务器放在防火墙后面，这有什么好处呢？ 如下图四所
示，Web, Mail 与 FTP 都是透过防火墙连到 Internet 上面去，所以， 底下这四部主机在 Internet 上
面的 Public IP 都是一样的！ (这个观念我们会在本章底下的 NAT 主机的时候再次的强调)。 只是透过
防火墙的封包分析后，将 WWW 的要求封包转送到 Web 主机，将 Mail 送给 Mail Server 去处理而已(透
过 port 的不同来转递)。
好了，因为四部主机在 Internet 上面看到的 IP 都相同，但是事实上却是四部不同的主机， 而当有攻击
者想要入侵您的 FTP 主机好了，他使用各种分析方法去进攻的主机，其实是『防火墙』那一部， 攻击者
想要攻击您内部的主机，除非他能够成功的搞定您的防火墙，否则就很难入侵您的内部主机呢！
而且，由于主机放置在两部防火墙中间，内部网络如果发生状况时 (例如某些使用者不良操作导致中毒啊、
被社交工程攻陷导致内部主机被绑架啊等等的) ，是不会影响到网络主机的正常运作的。 这种方式适用在
比较大型的企业当中，因为对这些企业来说，网络主机能否提供正常稳定的服务是很重要的！
不过，这种架构下所进行的设定就得包含 port 的转递，而且要有很强的逻辑概念， 可以厘清封包双向沟
通时的流动方式。对于新手来说，设定上有一定的难度， 鸟哥个人不太建议新手这么做，还是等以后有经
验之后再来玩这种架构吧！
图四、架设在防火墙后端的主机服务器
通常像上图四的环境中，将网络服务器独立放置在两个防火墙中间的网络， 我们称之为非军事区域 (DMZ)。
DMZ 的目的就如同前面提到的，重点在保护服务器本身， 所以将 Internet 与 LAN 都隔离开来，如此一
来不论是服务器本身，或者是 LAN 被攻陷时， 另一个区块还是完好无缺的！
好了，那么我们 Linux 防火墙软件 iptables 是可以进行封包过滤的，他可以分析网络封包的 socket
pair ， 还可以分析不同网络协议的状态，例如 TCP 封包的旗标 (flags) ，甚至可以分析网络卡的卡号
呢！ 经由分析这些数据后，咱们的 iptables 至少可以有底下这几种抵挡封包的方式：
• 拒绝让 Internet 的封包进入 Linux 主机的某些 port
这个应该不难了解吧！例如您的 port 20-21 这个 FTP 相关的 port ， 您只要开放给内部网络
的话，所以不对 Internet 开放，那么当 Internet 来的封包想要进入您的 port 20-21 的话，
就可以将该数据封包丢掉！因为我们可以分析的到该封包所带有的 port 号码呀！
• 拒绝让某些来源 IP 的封包进入
例如您已经发现某个 IP 主要都是来自攻击行为的主机，那么只要来自该 IP 的数据封包，就将
他丢弃！这样也可以达到基础的安全呦！
• 拒绝让带有某些特殊旗标( flag )的封包进入
最常拒绝的就是带有 SYN 的主动联机的旗标了！只要一经发现，嘿嘿！您就可以将该封包丢弃呀！
• 分析硬件地址(MAC)来提供服务
如果您的局域网络里面有比较捣蛋的但是又具有比较高强的网络功力的高手时，如果您使用 IP
来抵挡他使用网络的权限，而他却懂得反正换一个 IP 就好了，都在同一个网域内嘛！ 同样还是
在搞破坏～怎么办？没关系，我们可以死锁他的网络卡硬件地址啊！因为 MAC 是焊在网络卡上面
的，所以您只要分析到该使用者所使用的 MAC 之后，可以利用防火墙将该 MAC 锁住，呵呵！除
非他能够一换再换他的网络卡来取得新的 MAC，否则换 IP 是没有用的啦！
当然还有更多的使用技巧，你可以参考本章最后列出的参考数据， 里头有更多可用的小技巧喔。我们这里
仅会真对简单的本机防火墙，以及作为类似 IP 分享器的 NAT 主机作简单的介绍而已啦！ ^_^！好了，开
始来玩一玩那个 iptables 吧！
防火墙的使用限制
什么？！设定防火墙之后还不安全啊？！那当然啦！谁说设定了防火墙之后您的系统就一定安全？ 防火墙
虽然可以防止不受欢迎的封包进入我们的网络当中，不过，某些情况下， 他并不能保证我们的网络一定就
很安全。举几个例子来谈一谈：
• 防火墙并不能很有效的抵挡病毒或木马程序
假设您已经开放了 WWW 的服务，那么您的 WWW 主机上面，防火墙一定得要将 WWW 服务的 port
开放给 Client 端登入才行吧！否则您的 WWW 主机设定了等于没有用对吧！也就是说，只要进入
您的主机的封包是要求 WWW 数据的，就可以通过您的防火墙。那好了，『万一您的 WWW 服务器
软件有漏洞，或者本身向您要求 WWW 服务的该封包就是病毒在侦测您的系统』时，您的防火墙可
是一点办法也没有啊！ 因为本来设定的规则就是会让他通过啊。
• 防火墙对于来自内部 LAN 的攻击较无承受力
一般来说，我们对于 LAN 里面的主机都没有什么防火墙的设定，因为是我们自己的 LAN 啊，所
以当然就设定为信任网域了！不过， LAN 里面总是可能有些网络小白啊，虽然他们不是故意要搞
破坏， 但是他们就是不懂嘛！所以就乱用网络了。这个时候就很糟糕，因为防火墙对于内部的规
则设定通常比较少， 所以就容易造成内部员工对于网络误用或滥用的情况。
所以啦，在您的 Linux 主机实地上网之前，还是得先：
• 关闭几个不安全的服务；
• 升级几个可能有问题的套件；
• 架设好最起码的安全防护--防火墙--
其它相关的讯息请到 认识网络安全 里面去看一看怎么增加自身的安全吧！
Linux 的封包过滤机制：iptables
上面谈了这么多，主要还是希望您能了解到防火墙是什么这个议题！而且也希望您知道防火墙并非万能的。
好了，那么底下我们终于可以来瞧一瞧，那目前我们的 2.6 版这个 Linux 核心到底使用什么核心功能来
进行防火墙设定？
不同 Linux 核心版本的防火墙软件
Linux 的防火墙为什么功能这么好？这是因为他本身就是由 Linux kernel 所提供， 由于直接经过核心来
处理，因此效能非常好！不过，不同核心版本所使用的防火墙软件是不一样的！ 因为核心支持的防火墙是
逐渐演进来的嘛！
• Version 2.0：使用 ipfwadm 这个防火墙机制；
• Version 2.2：使用的是 ipchains 这个防火墙机制；
• Version 2.4 与 2.6 ：主要是使用 iptables 这个防火墙机制，不过在某些早期的 Version 2.4
版本的 distributions 当中，亦同时支持 ipchains (编译成为模块)，好让使用者仍然可以使用
来自 2.2 版的 ipchains 的防火墙规划。不过，不建议在 2.4 以上的核心版本使用 ipchains
喔！
因为不同的核心使用的防火墙机制不同，且支持的软件指令与语法也不相同， 所以在 Linux 上头设定属
于你自己的防火墙规则时，要注意啊，先用 uname -r 追踪一下你的核心版本再说！ 如果你是安装 2004 年
以后推出的 distributions ，那就不需要担心了，因为这些 distributions 几乎都使用 kernel 2.6 版
的核心啊！ ^_^
iptables 的表格与封包进入流程
前面的几个小节里面我们一直谈到：『防火墙规则』，咦！啥是规则啊？因为 iptables 是利用封包过滤
的机制， 所以他会分析封包的表头数据。根据表头数据与定义的『规则』来决定该封包是否可以进入主机
或者是被丢弃。 意思就是说：『根据封包的分析资料 "比对" 你预先定义的规则内容， 若封包数据与规
则内容相同则进行动作，否则就继续下一条规则的比对！』 重点在那个『比对与分析顺序』上。
举个简单的例子，假设我预先定义 10 条防火墙规则好了，那么当 Internet 来了一个封包想要进入我的
主机， 那么防火墙是如何分析这个封包的呢？我们以底下的图示来说明好了：
图五、封包过滤的规则动作及分析流程
当一个网络封包要进入到主机之前，会先经由 NetFilter 进行检查，那就是 iptables 的规则了。 检查
通过则接受 (ACCEPT) 进入本机取得资源，如果检查不通过，则可能予以丢弃 (DROP) ！ 上图五主要的目
的在告知您：『规则是有顺序的』！例如当网络封包进入 Rule 1 的比对时， 如果比对结果符合 Rule 1 ，
此时这个网络封包就会进行 Action 1 的动作，而不会理会后续的 Rule 2, Rule 3.... 等规则的分析了。
而如果这个封包并不符合 Rule 1 的比对，那就会进入 Rule 2 的比对了！如此一个一个规则去进行比对
就是了。 那如果所有的规则都不符合怎办？此时就会透过预设动作 (封包政策, Policy) 来决定这个封包
的去向。 所以啦，当您的规则顺序排列错误时，就会产生很严重的错误了。 怎么说呢？让我们看看底下
这个例子：
假设您的 Linux 主机提供了 WWW 的服务，那么自然就要针对 port 80 来启用通过的封包规则，但是您发
现 IP 来源为 192.168.100.100 老是恶意的尝试入侵您的系统，所以您想要将该 IP 拒绝往来，最后，所
有的非 WWW 的封包都给他丢弃，就这三个规则来说，您要如何设定防火墙检验顺序呢？
1. Rule 1 先抵挡 192.168.100.100 ；
2. Rule 2 再让要求 WWW 服务的封包通过；
3. Rule 3 将所有的封包丢弃。
这样的排列顺序就能符合您的需求，不过，万一您的顺序排错了，变成：
1. Rule 1 先让要求 WWW 服务的封包通过；
2. Rule 2 再抵挡 192.168.100.100 ；
3. Rule 3 将所有的封包丢弃。
此时，那个 192.168.100.100 『可以使用您的 WWW 服务』喔！因为只要他对您的主机送出 WWW 要求封包，
就可以使用您的 WWW 主机功能了，因为您的规则顺序定义第一条就会让他通过， 而不去考虑第二条规则！
这样可以理解规则顺序的意义了吗！现在再来想一想，如果 Rule 1 变成了『将所有的封包丢弃』，Rule 2
才设定『WWW 服务封包通过』，请问，我的 client 可以使用我的 WWW 服务吗？呵呵！答案是『否～』想
通了吗？ ^_^
• iptables 的表格与链 (chain)
事实上，那个图五所列出的规则仅是 iptables 众多表格当中的一个链 (chain) 而已。 什么是链呢？这
得由 iptables 的名称说起。为什么称为 ip"tables" 呢？ 因为这个防火墙软件里面有多个表格
(table) ，每个表格都定义出自己的预设政策与规则， 且每个表格都用途都不相同。我们可以使用底下这
张图来稍微了解一下：
图六、iptables 的表格示意图
刚刚图五的规则内容仅只是图六内的某个 chain 而已！ 而预设的情况下，咱们 Linux 的 iptables 至少
就有三个表格，包括管理本机进出的 filter 、管理后端主机 (防火墙内部的其它计算机) 的 nat 、 管
理特殊旗标使用的 mangle (较少使用) 。更有甚者，我们还可以自订额外的链呢！ 真是很神奇吧！每个
表格与其中链的用途分别是这样的：
• filter：主要跟 Linux 本机有关，这个是预设的 table 喔！
o INPUT：主要与封包想要进入我们 Linux 本机有关；
o OUTPUT：主要与我们 Linux 本机所要送出的封包有关；
o FORWARD：这个咚咚与 Linux 本机比较没有关系，他可以封包『转递』到后端的计算机
中，与 nat 这个 table 相关性很高。
• nat：这个表格主要在用作来源与目的之 IP 或 port 的转换， 与 Linux 本机较无关，主要与
Linux 主机后的局域网络内的计算机较有相关。
o PREROUTING：在进行路由判断之前所要进行的规则(DNAT/REDIRECT)
o POSTROUTING：在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)
o OUTPUT：与发送出去的封包有关
• mangle：这个表格主要是与特殊的封包的路由旗标有关， 早期仅有 PREROUTING 及 OUTPUT 链，
不过从 kernel 2.4.18 之后加入了 INPUT 及 FORWARD 链。 由于这个表格与特殊旗标相关性较
高，所以像咱们这种单纯的环境当中，较少使用 mangle 这个表格。
那么各个表格与链的相关性可以使用下图来表示：
图七、iptables 内建各表格与链的相关性
上面的图示很复杂喔！不过基本上你依旧可以看出来，我们的 iptables 可以控制两种封包的流向：
• 如上图的 A ，封包主要是要读取我们 Linux 本机内的数据，会经过 filter 的 INPUT 链， 而
数据的输出则是经过 filter 的 OUTPUT 链；
• 如上图的 B ，封包主要是要透过防火墙而去后端，也就是说，该封包的目标并非我们的 Linux 本
机。 主要经过的链是 filter 的 FORWARD 以及 nat 的 POSTROUTING, PREROUTING。
由于 mangle 这个表格很少被使用，如果将图七的 mangle 拿掉的话，那就容易看的多了：
图八、iptables 内建各表格与链的相关性(简图)
透过图八你就可以更轻松的了解到，事实上与本机最有关的其实是 filter 这个表格内的 INPUT 与
OUTPUT 这两条链，如果你的 iptables 只是用来防备 Linux 主机本身的话，那 nat 的规则根本就不需要
理他，直接设定为开放即可。
不过，如果你的防火墙事实上是用来管制 LAN 内的其它主机的话，那么你就必须要再针对 filter 的
FORWARD 这条链，还有 nat 的 PREROUTING, POSTROUTING 以及 OUTPUT 进行额外的规则订定才行。 nat
表格的使用需要很清晰的路由概念才能够设定的好，建议新手先不要碰！ 最多就是先玩一玩最阳春的 nat
功能『IP 分享器的功能』就好了！ ^_^！ 这部份我们在本章的最后一小节会介绍的啦！
本机的 iptables 语法
理论上，当你安装好 Linux 之后，系统应该会主动的帮你启动一个阳春的防火墙规则才是。 不过如果您
是依照鸟哥的建议来安装 Linux 时，那么安装完毕后，你的系统应该是没有防火墙的啦。 另外，某些早
期的版本 (例如 Red Hat 9) 本身同时提供 iptables 及 ipchains 这两个防火墙模块， 不过这两个模块
是无法同时存在的！所以你仅能启动其中一个，那当然是启动 iptables 才对啊！ 如果不小心启动了
ipchains 的话 (新版的 Linux 都不会有这个困扰) ，那请使用 rmmod 来移除吧！
不过，在开始进行底下的练习之前，鸟哥这里有个很重要的事情要告知一下。 因为 iptables 的指令会将
网络封包进行过滤及抵挡的动作，所以 请不要在远程主机上进行防火墙的练习，因为您很有可能一不小心
将自己关在家门外！ 尽量在本机前面登入 tty1-tty6 终端机进行练习，否则常常会发生悲剧啊！ 鸟哥以
前刚刚在玩 iptables 时，就常常因为不小心规则设定错误，导致常常要请远程的朋友帮忙重新开机...
刚刚提到咱们的 iptables 至少有三个预设的 table (filter, nat, mangle)，较常用的是本机的 filter
表格， 这也是预设表格啦。另一个则是后端主机的 nat 表格，至于 mangle 较少使用，所以这个章节我
们并不会讨论 mangle。 由于不同的 table 他们的链不一样，导致使用的指令语法或多或少都有点差异。
在这个小节当中，我们主要将针对 filter 这个预设表格的三条链来做介绍。底下就来玩一玩吧！
Tips:
防火墙的设定主要使用的就是 iptables 这个指令而已。而防火墙
是系统管理员的主要任务之一， 且对于系统的影响相当的大，因
此『只能让 root 使用 iptables 』，不论是设定还是观察防火墙
规则喔！
• 规则的清除与观察
如果你在安装的时候选择没有防火墙的话，那么 iptables 在一开始的时候应该是没有规则的，不过， 可
能因为你在安装的时候就有选择系统自动帮您建立防火墙机制，那系统就会有预设的防火墙规则了！ 无论
如何，我们先来看看目前本机的防火墙规则是如何吧！
[root@linux ~]# iptables [-t tables] [-L] [-nv]
参数：
-t ：后面接 table ，例如 nat 或 filter ，若省略此项目，则使用预设的 filter
-L ：列出目前的 table 的规则
-n ：不进行 IP 与 HOSTNAME 的反查，显示讯息的速度会快很多！
-v ：列出更多的信息，包括通过该规则的封包总位数、相关的网络接口等
范例：列出 filter table 三条链的规则
[root@linux ~]# iptables -L -n
Chain FORWARD (policy ACCEPT)
target prot opt source destination
Chain INPUT (policy ACCEPT)
target prot opt source destination
Chain OUTPUT (policy ACCEPT)
target prot opt source destination
范例：列出更多的信息
[root@linux ~]# iptables -L -nv
Chain INPUT (policy ACCEPT 5748 packets, 746K bytes)
 pkts bytes target prot opt in out source  destination
....底下省略....
仔细看到上面表格的输出，因为没有加上 -t 的参数，所以预设就是 filter 这个表格内的 INPUT, OUTPUT,
FORWARD 三条链的规则啰。由于没有规则嘛！所以每个链内部的规则都是空的。 同时注意一下，在每个
chain 后面括号内的 policy 项目，那就是『预设动作(政策)』咯！以上面来看， 虽然我们启动了
iptables ，但是我们没有设定规则，然后政策又是 ACCEPT， 所以是『任何封包都会接受』的意思喔！至
于如果加上 -v 的参数时， 则连同该规则所通过的封包总位数也会被列出来啊。底下则是 nat 表格的规
则项目：
[root@linux ~]# iptables -t nat -L -n
Chain OUTPUT (policy ACCEPT)
target prot opt source destination
Chain POSTROUTING (policy ACCEPT)
target prot opt source destination
Chain PREROUTING (policy ACCEPT)
target prot opt source destination
瞧！与 fiter 表格一模一样吧！只是三条链的内容不同啰！要注意啊！ ^_^！ 以后当你设定每一条防火
墙的规则时，记得瞧一瞧设定先！好，那如何清除规则？这样做就对了：
[root@linux ~]# iptables [-t tables] [-FXZ]
参数：
-F ：清除所有的已订定的规则；
-X ：杀掉所有使用者 "自订" 的 chain (应该说的是 tables ）啰；
-Z ：将所有的 chain 的计数与流量统计都归零
范例：清除本机防火墙 (filter) 的所有规则
[root@linux ~]# iptables -F
[root@linux ~]# iptables -X
[root@linux ~]# iptables -Z
由于这三个指令会将本机防火墙的所有规则都清除，但却不会改变预设政策 (policy) ， 所以如果你不是
在本机下达这三行指令时，很可能你会被自己挡在家门外 (若 INPUT 设定为 DROP 时)！ 要小心啊！
一般来说，我们在重新定义防火墙的时候，都会先将规则给他清除掉。还记得我们前面谈到的， 防火墙的
『规则顺序』是有特殊意义的，所以啰， 当然先清除掉规则，然后一条一条来设定会比较容易一点啦。底
下就来谈谈定义预设政策吧！
• 定义预设政策 (policy)
清除规则之后，再接下来就是要设定规则的政策啦！还记得政策指的是什么吗？『 当您的封包不在您设定
的规则之内时，则该封包的通过与否，以 Policy 的设定为准』，在本机方面的预设政策中，假设您对于
内部的使用用者有信心的话， 那么 filter 内的 INPUT 链方面可以定义的比较严格一点，而 FORWARD 与
OUTPUT 则可以订定的松一些！通常鸟哥都是将 INPUT 的 policy 定义为 DROP 啦，其它两个则定义为
ACCEPT。 至于 nat table 则暂时不理会他。
[root@linux ~]# iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]
参数：
-P ：定义政策( Policy )。注意，这个 P 为大写啊！
ACCEPT ：该封包可接受
DROP ：该封包直接丢弃，不会让 client 端知道为何被丢弃。
范例：将本机的 INPUT 设定为 DROP ，其它设定为 ACCEPT
[root@linux ~]# iptables -P INPUT DROP
[root@linux ~]# iptables -P OUTPUT ACCEPT
[root@linux ~]# iptables -P FORWARD ACCEPT
[root@linux ~]# iptables -L -n
Chain FORWARD (policy ACCEPT)
target prot opt source destination
Chain INPUT (policy DROP)
target prot opt source destination
Chain OUTPUT (policy ACCEPT)
target prot opt source destination
# 由于 INPUT 设定为 DROP 而又尚未有任何规则，所以上面的输出结果显示：
# 所有的封包都无法进入你的主机！是不通的防火墙设定！(网络联机是双向的)
看到输出的结果了吧？INPUT 被修改设定了喔！其它的 nat table 三条链的设定也是一样的，例如：
『 iptables -t nat -P PREROUTING ACCEPT 』就设定了 nat table 的 PREROUTING 链为可接受的意思！
预设政策设定完毕后，来谈一谈关于封包的基础比对设定吧。
• 封包的基础比对 IP/netmask I/O 装置
开始来进行封包的比对设定吧！我们先由最基础的 IP 与网域的特征谈起，再谈装置 (网络卡) 的限制等
等。
[root@linux ~]# iptables [-AI 链] [-io 网络接口] [-p 协议] \
> [-s 来源 IP/网域] [-d 目标 IP/网域] -j [ACCEPT|DROP]
参数：
-AI 链：针对某的链进行规则的 "插入" 或 "累加"
 -A ：新增加一条规则，该规则增加在原本规则的最后面。例如原本已经有四条规则，
 使用 -A 就可以加上第五条规则！
 -I ：插入一条规则。如果没有指定此规则的顺序，预设是插入变成第一条规则。
 例如原本有四条规则，使用 -I 则该规则变成第一条，而原本四条变成 2~5 号
 链 ：有 INPUT, OUTPUT, FORWARD 等，此链名称又与 -io 有关，请看底下。
-io 网络接口：设定封包进出的接口规范
 -i ：封包所进入的那个网络接口，例如 eth0, lo 等接口。需与 INPUT 链配合；
 -o ：封包所传出的那个网络接口，需与 OUTPUT 链配合；
-p 协定：设定此规则适用于哪种封包格式
 主要的封包格式有： tcp, udp, icmp 及 all 。
-s 来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：
 IP ：192.168.0.100
 网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。
 若规范为『不许』时，则加上 ! 即可，例如：
 -s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；
-d 目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。
-j ：后面接动作，主要的动作有接受 (ACCEPT)、丢弃 (DROP) 及记录 (LOG)
iptables 的基本参数就如同上面所示的，仅只谈到 IP 、网域与装置等等的信息， 至于 TCP, UDP 封包
特有的埠口 (port number) 与状态 (如 SYN 旗标) 则在下小节才会谈到。 好，先让我们来看看最基础的
几个规则，例如开放 lo 这个本机的接口以及某个 IP 来源吧！
范例一：所有的来自 lo 这个接口的封包，都予以接受
[root@linux ~]# iptables -A INPUT -i lo -j ACCEPT
# 仔细看上面并没有列出 -s, -d 等等的规则，这表示：不论封包来自何处或去到哪里，
# 只要是来自 lo 这个界面，就予以接受！这个观念挺重要的，就是
#『没有设定的规定，则表示该规定完全接受』的意思！例如这个案例当中，
# 关于 -s, -d...等等的参数没有规定时
范例二：目标来自 192.168.0.1 这个 IP 的封包都予以接受
[root@linux ~]# iptables -A INPUT -i eth0 -s 192.168.0.1 -j ACCEPT
# 不管什么封包格式，只要来自 192.168.0.1 就予以接受。
范例三：目标来自 192.168.1.0/24 可接受，但 192.168.1.10 丢弃
[root@linux ~]# iptables -A INPUT -i eth0 -s 192.168.1.10 -j DROP
[root@linux ~]# iptables -A INPUT -i eth0 -s 192.168.1.0/24 -j ACCEPT
# 上述这两个范例很重要啊！因为有点关系！要先丢弃 192.168.1.10 才能接受该网域。
[root@linux ~]# iptables -L -n
Chain INPUT (policy DROP)
target prot opt source destination
ACCEPT all -- 0.0.0.0/0 0.0.0.0/0
ACCEPT all -- 192.168.0.1 0.0.0.0/0
DROP all -- 192.168.1.100 0.0.0.0/0
ACCEPT all -- 192.168.1.0/24 0.0.0.0/0
# 瞧！刚刚的设定在这里已经生效啰！
这就是最单纯、简单的防火墙规则的设定与观察方式。你在设定完毕后，都可以利用 iptables -L -n 或
iptables -L -v 来简单的查阅一下。而如果你想要记录某个规则的纪录怎么办？可以这样做：
[root@linux ~]# iptables -A INPUT -s 192.168.2.200 -j LOG
[root@linux ~]# iptables -L -n
target prot opt source destination
LOG all -- 192.168.2.200 0.0.0.0/0 LOG flags 0 level 4
看到输出结果的最左边，会出现的是 LOG 喔！只要有封包来自 192.168.2.200 这个 IP 时， 那么该封包
的相关信息就会被写入到核心讯息，亦即是 /var/log/messages 这个档案当中。 然后该封包会继续进行
后续的规则比对。所以说， LOG 这个动作仅在进行记录而已，并不会影响到这个封包的其它规则比对的。
好了，接下来我们分别来看看 TCP,UDP 以及 ICMP 封包的其它规则比对吧！
• TCP, UDP 的规则比对
我们在网络基础谈过各种不同的封包格式， 在谈到 TCP 与 UDP 时，比较特殊的就是那个埠口 (port
number)，在 TCP 方面则另外有所谓的联机封包状态， 包括最常见的 SYN 主动联机的封包格式。那么如
何针对这两种封包格式进行防火墙规则的设定呢？你可以这样看：
[root@linux ~]# iptables [-AI 链] [-io 网络接口] [-p tcp,udp] \
> [-s 来源 IP/网域] [--sport 埠口范围] \
> [-d 目标 IP/网域] [--dport 埠口范围] -j [ACCEPT|DROP]
参数：
--sport 埠口范围：限制来源的端口口号码，端口口号码可以是连续的，例如 1024:65535
--dport 埠口范围：限制目标的端口口号码。
事实上就是多了那个 --sport 及 --dport 这两个玩意儿，重点在那个 port number 上面啦！ 底下让我
们来进行几个小测试：
范例一：想要联机进入本机 port 21 的封包都抵挡掉：
[root@linux ~]# iptables -A INPUT -i eth0 -p tcp --dport 21 -j DROP
范例二：想连到我这部主机的网芳 (upd port 137,138 tcp port 139,445) 就放行
[root@linux ~]# iptables -A INPUT -i eth0 -p udp --dport 137:138 -j ACCEPT
[root@linux ~]# iptables -A INPUT -i eth0 -p tcp --dport 139 -j ACCEPT
[root@linux ~]# iptables -A INPUT -i eth0 -p tcp --dport 445 -j ACCEPT
瞧！你可以利用 UDP 与 TCP 协议所拥有的端口口号码来进行某些服务的开放或关闭喔！ 你还可以综合处
理呢！例如：只要来自 192.168.1.0/24 的 1024:65535 埠口的封包， 只要想要联机到本机的 ssh port 就
予以抵挡，可以这样做：
[root@linux ~]# iptables -A INPUT -i eth0 -p tcp -s 192.168.1.0/24 \
> --sport 1024:65534 --dport ssh -j DROP
注意啊！如果你有使用到 --sport 及 --dport 的参数时，就必须指定 udp 或 tcp 的封包格式才行！否
则的话， iptables 的指令就会出现如下的错误：
[root@linux ~]# iptables -A INPUT -i eth0 --dport 21 -j DROP
iptables v1.2.11: Unknown arg `--dport'
Try `iptables -h' or 'iptables --help' for more information.
你应该会觉得很奇怪，怎么『 --dport 』会是未知的参数 (arg) 呢？这是因为你没有加上 -p tcp 或 -p
udp 的缘故啊！因为 port 是 TCP,UDP 特有的，其它类似 ICMP 则没有这种类的端口口数据啊！ 这样说，
您可以理解吧！ ^_^
除了埠口之外，在 TCP 还有特殊的旗标啊！最常见的就是那个主动联机的 SYN 旗标了。 我们在 iptables
里面还支持『 --syn 』的处理方式，我们以底下的例子来说明好了：
范例：将来自任何地方来源 port 1:1023 的主动联机到本机端的 1:1023 联机丢弃
[root@linux ~]# iptables -A INPUT -i eth0 -p tcp --sport 1:1023 \
> --dport 1:1023 --syn -j DROP
一般来说，client 端启用的 port 都是大于 1024 以上的埠口，而 server 端则是启用小于 1023 以下的
埠口在监听的。所以我们可以让来自远程的小于 1023 以下的端口口数据的主动联机都给他丢弃！ 但不适
用在 FTP 的主动联机中！这部份我们未来在 FTP 章节当中再来谈吧！
• 状态模块：MAC 与 RELATED
在早期的 kernel 2.2 以前使用 ipchains 管理防火墙时，通常会让系统管理员相当头痛！ 因为 ipchains
没有所谓的封包状态模块，因此我们必须要针对封包的进、出方向进行管控。 举例来说，如果你想要联机
到远程主机的 port 22 时，你必须要针对两条规则来设定：
• 本机端的 1024:65535 到远程的 port 22 必须要放行 (OUTPUT 链)；
• 远程主机 port 22 到本机的 1024:65535 必须放行 (INPUT 链)；
这会很麻烦！因为如果你要联机到 10 部主机的 port 22 时，假设 OUTPUT 为预设开启 (ACCEPT)， 你依
旧需要填写十行规则，让那十部远程主机的 port 22 可以联机到你的本地端主机上。 那如果开启全部的
port 22 呢？又担心某些恶意主机会主动以 port 22 联机到你的机器上！ 同样的道理，如果你要让本地
端主机可以连到外部的 port 80 (WWW 服务)，那就更不得了～ 这就是网络联机是双向的一个很重要的概
念！
好在我们的 iptables 免除了这个困扰！他可以透过一个状态模块来分析 『这个想要进入的封包是否为刚
刚我发出去的响应？』 如果是刚刚我发出去的响应，那么就可以予以接受放行！哇！真棒！这样就不用管
远程主机是否联机进来的问题了！ 那如何达到呢？看看底下的语法：
[root@linux ~]# iptables -A INPUT -m state --state 状态
参数：
-m ：一些 iptables 的模块，主要常见的有：
 state ：状态模块
 mac ：网络卡硬件地址 (hardware address)
--state ：一些封包的状态，主要有：
 INVALID ：无效的封包，例如数据破损的封包状态
 ESTABLISHED：已经联机成功的联机状态；
 NEW ：想要新建立联机的封包状态；
 RELATED ：这个最常用！表示这个封包是与我们主机发送出去的封包有关
范例：只要已建立或相关封包就予以通过，只要是不合法封包就丢弃
[root@linux ~]# iptables -A INPUT -m state \
> --state RELATED,ESTABLISHED -j ACCEPT
[root@linux ~]# iptables -A INPUT -m state --state INVALID -j DROP
所以说，如果你的 Linux 主机只想要作为 client 的用途，不许所有主动对你联机的来源， 那么你可以
这样做即可：
1. 清除所有已经存在的规则 (iptables -F...)
2. 设定预设政策，除了 INPUT 预设为 DROP 其它为预设 ACCEPT；
3. 开放本机的 lo 可以自由放行；
4. 设定有相关的封包状态可以联机进入本机。
这就是最最阳春的防火墙，你可以透过第二步骤抵挡所有远程的来源封包， 而透过第四步骤让你要求的远
程主机响应封包可以进入， 加上让本机的 lo 这个内部循环装置可以放行，嘿嘿！一部 client 专用的防
火墙规则就 OK 了！ 你可以在某个 script 上面这样做即可：
#!/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin; export PATH
iptables -F
iptables -X
iptables -Z
iptables -P INPUT DROP
iptables -P OUTPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -A INPUT -i lo -j ACCEPT
iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT
#iptables -A INPUT -i eth0 -s 192.168.1.0/24 -j ACCEPT
那如果局域网络内有其它的主机时，再将上表最后一行的 # 取消，就可以接受来自本地 LAN 的其它主机
的联机了。 而如果你担心某些 LAN 内的恶意来源主机会主动的对你联机时，那你还可以针对信任的本地
端主机的 MAC 进行过滤！ 同样是使用状态模块！这次的状态则是 MAC 的比对。举例来说：
范例一：针对局域网络内的 aa:bb:cc:dd:ee:ff 主机开放其联机
[root@linux ~]# iptables -A INPUT -m mac --mac-source aa:bb:cc: dd:ee:ff \
> -j ACCEPT
参数：
--mac-source ：就是来源主机的 MAC 啦！
透过这个玩意儿，你就可以定义更严格的 LAN 内的其它主机能否联机到你的主机的权限了！
• ICMP 封包规则的比对
在网络基础的 ICMP 协议当中我们知道 ICMP 的格式相当的多，而且很多 ICMP 封包的类型格式都是为了
要用来进行网络检测用的！ 所以最好不要将所有的 ICMP 封包都丢弃！通常我们会把 ICMP type 8 (echo
request) 拿掉而已， 让远程主机不知道我们是否存在，也不会接受 ping 的响应就是了。ICMP 封包格式
的处理是这样的：
[root@linux ~]# iptables -A INPUT -p icmp --icmp-type 类型 -j ACCEPT
参数：
--icmp-type ：后面必须要接 ICMP 的封包类型，也可以使用代号，
 例如 8 代表 echo request 的意思。
范例：让 0,3,4,11,12,14,16,18 的 ICMP type 可以进入本机：
[root@linux ~]# vi somefile
#!/bin/bash
icmp_type="0 3 4 11 12 14 16 18"
for typeicmp in $icmp_type
do
 iptables -A INPUT -i eth0 -p icmp --icmp-type $typeicmp -j ACCEPT
done
[root@linux ~]# sh somefile
这样就能够开放部分的 ICMP 封包格式进入本机进行网络检测的工作了！真好！不是嘛！^_^
防火墙的记录、回复与测试
刚刚上面我们谈了很多的设定了，那么我该如何观察目前主机上面的防火墙规则呢？ 我们可以使用
『iptables -L -n 』来观察，不过，该指令所显示的信息其实还是不太足够的。 这个时候，我们其实可
以使用底下的两个指令来将目前主机上面的防火墙机制『储存』下来， 在下次想要将这个规则『回复』的
时候，就能够直接利用指令将规则直接回复喔！
[root@linux ~]# iptables-save > filename
[root@linux ~]# iptables-restore < filename
一个是储存一个是回复！而在 Red Hat 系统的 RHEL,CentOS,Fedora 当中，如果你将那个 filename 档案
存成『 /etc/sysconfig/iptables 』，并且利用 chkconfig 将 iptables 在开机时预设启 动的话，那么
一开机系统就会主动的帮你把防火墙的规则给加载了就是！ 那么使用 iptables-save 所得到的结果会是
如何呢？让我们来看看：
[root@linux ~]# iptables-save
# Generated by iptables-save v1.2.11 on Mon Sep 11 17:47:35 2006
*filter <==使用的 table
:INPUT DROP [7335:859454] <==三条预设的链与预设政策
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [16992:13134791]
-A INPUT -i lo -j ACCEPT <==开始各个规则的设定
-A INPUT -m state --state RELATED -j ACCEPT
-A INPUT -m mac --mac-source 00:04:75:D0:A2:58 -j ACCEPT
-A INPUT -m state --state ESTABLISHED -j ACCEPT
-A INPUT -i eth0 -p icmp -m icmp --icmp-type 0 -j ACCEPT
-A INPUT -i eth0 -p icmp -m icmp --icmp-type 3 -j ACCEPT
....中间省略....
-A INPUT -i eth0 -p tcp -m tcp --dport 22 -j ACCEPT
COMMIT
# Completed on Mon Sep 11 17:47:35 2006
# 井号 (#) 是批注，星号 (*) 代表预设的 table，而冒号 (:) 代表各条链的预设政策；
# 后续的动作则是各个规则啦！
你瞧到输出的结果啦！整个数据几乎就是类似手动在指令列模式输入的指令！ 比起 iptables -L -n 所得
到的信息要仔细的多。这也是 iptables 的特殊格式， 可以用在 iptables-restore 的指令读入呢！ 比
起这种方式，鸟哥还是比较喜欢使用 script 来撰写自己的防火墙规则啦。 制订好规则后当然就是要测试
啰！那么如何测试呢？
1. 先由主机向外面主动联机试看看；
2. 再由私有网域内的 PC 向外面主动联机试看看；
3. 最后，由 Internet 上面的主机，主动联机到您的 Linux 主机试看看；
一步一步作下来，看看问题出在哪里，然后多多的去改进、改良！基本上， 网络上目前很多的资料可以提
供您不错的参考了！这一篇的设定写的是很简单， 大部分都还在介绍阶段而已！希望对大家有帮助！ 鸟
哥在参考数据当中列出几个有用的防火墙网页， 希望大家有空真的要多多的去看看！会很有帮助的！
IPv4 的核心管理功能： /proc/sys/net/ipv4/*
除了 iptables 这个防火墙软件之外，其实咱们 Linux kernel 2.6 提供很多核心预设的攻击抵挡机制喔！
由于是核心的网络功能，所以相关的设定数据都是放置在 /proc/sys/net/ipv4/ 这个目录当中。 至于该
目录下各个档案的详细资料，可以参考核心的说明文件：
• /usr/src/linux-{version}/networking/ip-sysctl.txt
上面的这个说明数据可以由 http://www.kernel.org 这个网站下载任何一个核心原始码后，解压缩就能够
看到。 鸟哥这里也放一份备份：
• http:/linux.vbird.org/linux_server/0250simple_firewall/ip-sysctl.txt
有兴趣的话应该要自行去查一查比较好的喔！我们底下就拿几个简单的档案来作说明吧！
• /proc/sys/net/ipv4/tcp_syncookies
我们在前一章谈到所谓的阻断式服务 (DoS)  攻击法当中的一种方式，就是利用 TCP 封包的 SYN 三向交握
原理所达成的， 这种方式称为 SYN Flooding 。那如何预防这种方式的攻击呢？我们可以启用核心的 SYN
Cookie 模块啊！ 这个 SYN Cookie 模块可以在系统用来启动随机联机的埠口 (1024:65535) 即将用完时
自动启动。
当启动 SYN Cookie 时，主机在发送 SYN/ACK 确认封包前，会要求 Client 端在短时间内回复一个序号，
这个序号包含许多原本 SYN 封包内的信息，包括 IP、port 等。若 Client 端可以回复正确的序号， 那
么主机就确定该封包为可信的，因此会发送 SYN/ACK 封包，否则就不理会此一封包。
透过此一机制可以大大的降低无效的 SYN 等待埠口，而避免 SYN Flooding 的 DoS 攻击说！ 那么如何启
动这个模块呢？很简单，这样做即可：
[root@linux ~]# echo "1" > /proc/sys/net/ipv4/tcp_syncookies
但是这个设定值由于违反 TCP 的三向交握 (因为主机在发送 SYN/ACK 之前需要先等待 client 的序号响
应)， 所以可能会造成某些服务的延迟现象，例如 SMTP (mail server)。 不过总的来说，这个设定值还
是不错用的！ 只是不适合用在负载已经很高的服务器内喔！ 因为负载太高的主机有时会让核心误判遭受
SYN Flooding 的攻击呢。
如果是为了系统的 TCP 封包联机最佳化，则可以参考 tcp_max_syn_backlog, tcp_synack_retries,
tcp_abort_on_overflow 这几个设定值的意义。
• /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
阻断式服务常见的是 SYN Flooding ，不过，我们知道系统其实可以接受使用 ping 的响应， 而 ping 的
封包是可以给很大的！想象一个状况， 如果有个搞破坏的人使用 1000 台主机传送 ping 给你的主机，而
且每个 ping 都高达数百 K bytes时， 你的网络频宽会怎样？要嘛就是频宽被吃光，要嘛可能系统会当机！
这种方式分别被称为 ping flooding (不断发 ping) 及 ping of death (发送大的 ping 封包)。
那如何避免呢？取消 ICMP 类型 8 的 ICMP 封包回应就是了。我们可以透过防火墙来抵挡， 这也是比较
建议的方式。当然也可以让核心自动取消 ping 的响应。不过您必须要了解， 某些局域网络内常见的服务
(例如动态 IP 分配 DHCP 协议) 会使用 ping 的方式来侦测是否有重复的 IP ，所以你最好不要取消所有
的 ping 响应比较好。
核心取消 ping 回应的设定值有两个，分别是：/proc/sys/net/ipv4 内的 icmp_echo_ignore_broadcasts
(仅有 ping broadcast 地址时才取消 ping 的回应) 及 icmp_echo_ignore_all (全部的 ping 都不回
应)。鸟哥建议设定 icmp_echo_ignore_broadcasts 就好了。 你可以这么做：
[root@linux ~]# echo "1" > \
> /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
• /proc/sys/net/ipv4/conf/网络接口/*
咱们的核心还可以针对不同的网络接口进行不一样的参数设定喔！网络接口的相关设定放置在
/proc/sys/net/ipv4/conf/ 当中，每个接口都以接口代号做为其代表，例如 eth0 接口的相关设定数据在
/proc/sys/net/ipv4/conf/eth0/ 内。那么网络接口的设定数据有哪些比较需要注意的呢？ 大概有底下这
几个：
• rp_filter：称为逆向路径过滤 (Reverse Path Filtering)， 可以藉由分析网络接口的路由信息
配合封包的来源地址，来分析该封包是否为合理。举例来说，你有两张网卡，eth0 为
192.168.10.100/24 ，eth1 为 public IP 。那么当有一个封包自称来自 eth1 ，但是其 IP 来
源为 192.168.10.200 ， 那这个封包就不合理，应予以丢弃。这个设定值建议可以启动的。
• log_martians：这个设定数据可以用来启动记录不合法的 IP 来源， 举例来说，包括来源为
0.0.0.0、127.x.x.x、及 Class E 的 IP 来源，因为这些来源的 IP 不应该应用于 Internet 啊。
记录的数据预设放置到核心放置的登录档 /var/log/messages。
• accept_source_route：或许某些路由器会启动这个设定值， 不过目前的设备很少使用到这种来
源路由，你可以取消这个设定值。
• accept_redirects：当你在同一个实体网域内架设一部路由器， 但这个实体网域有两个 IP 网域，
例如 192.168.0.0/24, 192.168.1.0/24。此时你的 192.168.0.100 想要向 192.168.1.100 传送
讯息时，路由器可能会传送一个 ICMP redirect 封包告知 192.168.0.100 直接传送数据给
192.168.1.100 即可，而不需透过路由器。因为 192.168.0.100 与 192.168.1.100 确实是在同
一个实体线路上 (两者可以直接互通)，所以路由器会告知来源 IP 使用最短路径去传递数据。但
那两部主机在不同的 IP 段，却是无法实际传递讯息的！这个设定也可能会产生一些轻微的安全
风险，所以建议关闭他。
• send_redirects：与上一个类似，只是此值为发送一个 ICMP redirect 封包。 同样建议关闭。(事
实上，鸟哥在某补教中心教同学架设路由器时，就曾经为了这个 ICMP redirect 的问题伤脑筋！
其实关闭 redirect 的这两个项目即可啊！)
要达成上面的功能你必须要这样做：
[root@linux ~]# vi somefile
for i in /proc/sys/net/ipv4/conf/*/rp_filter; do
 echo "1" > $i
done
for i in /proc/sys/net/ipv4/conf/*/log_martians; do
 echo "1" > $i
done
for i in /proc/sys/net/ipv4/conf/*/accept_source_route; do
 echo "0" > $i
done
for i in /proc/sys/net/ipv4/conf/*/accept_redirects; do
 echo "0" > $i
done
for i in /proc/sys/net/ipv4/conf/*/send_redirects; do
 echo "0" > $i
done
[root@linux ~]# sh somefile
本机防火墙的一个实例
介绍了这么多的防火墙语法与相关的注意事项后，终于要来架设防火墙了。如同前面谈到的， 你当然可以
使用 iptables-save 的语法将相关的防火墙规则转存到 /etc/sysconfig/iptables 去， 然后透过
iptables-restore 或者是重新启动 iptables 来启用你的新防火墙规则。 不过鸟哥还是比较习惯使用
shell script 来撰写防火墙规则，而且此一特色还可以用在呼叫其它的 scripts ， 可以让防火墙规则具
有较为灵活的使用方式。好了，那就来谈谈如何设定咱们的防火墙规则吧！
规则草拟
鸟哥底下介绍的这个防火墙，其实可以用来作为路由器上的防火墙，也可以用来作为本机的防火墙。 假设
硬件联机如同图二所示那样的环境， Linux 主机本身也是内部 LAN 的路由器！ 亦即是一个简单的 IP 分
享器的功能啦！假设鸟哥网络接口有底下这些：
• 外部网络使用 eth1 (如果是拨接，有可能是 ppp0，请针对您的环境来设定)；
• 内部网络使用 eth0 ，且内部使用 192.168.1.0/24 这个 Class ；
• 主机预设开放的服务有 WWW, SSH, SMTP 等等；
由于希望将信任网域 (LAN) 与不信任网域 (Internet) 整个分开的完整一点， 所以希望你可以在 Linux
上面安装两块以上的实体网卡，将两块网卡接在不同的网域，这样可以避免很多问题。 至于最重要的防火
墙规则是：『关闭所有的联机，仅开放特定的服务』模式。 而且假设内部使用者已经受过良好的训练，因
此在 filter table 的三条链个预设政策是：
• INPUT 为 DROP
• OUTPUT 及 FORWARD 为 ACCEPT
为了未来修改的方便，鸟哥将整个 script 拆成三部分，分别是：
• iptables.rule：设定最基本的规则，包括清除防火墙规则、加载模块、设定服务可接受等；
• iptables.deny：设定抵挡某些恶意主机的进入；
• iptables.allow：设定允许某些自订的后门来源主机！
鸟哥底下预计提供的防火墙流程是这样的：
图九、防火墙规则的流程
原则上，内部 LAN 主机与主机本身的开放度很高，因为 Output 与 Forward 是完全开放不理的！对于小
家庭的主机是可以接受的，因为我们内部的计算机数量不多，而且人员都是熟悉的， 所以不需要特别加以
控管！但是：『在大企业的内部，这样的规划是很不合格的， 因为您不能保证内部所有的人都可以按照您
的规定来使用 Network ！』也就是说『家贼难防』呀！ 因此，连 Output 与 Forward 都需要特别加以管
理才行！
实际设定
事实上，我们在设定防火墙的时候，不太可能会一个一个指令的输入，通常是利用 shell scripts 来帮我
们达成这样的功能吶！底下是利用上面的流程图所规划出来的防火墙 scripts，您可以参考看看， 但是您
需要将环境修改成适合您自己的环境才行喔！
[root@linux ~]# mkdir -p /usr/local/virus/iptables
[root@linux ~]# cd /usr/local/virus/iptables
[root@linux iptables]# vi iptables.rule
#!/bin/bash
# 请先输入您的相关参数，不要输入错误了！
 EXTIF="eth1" # 这个是可以连上 Public IP 的网络接口
 INIF="eth0" # 内部 LAN 的连接接口；若无请填 ""
 INNET="192.168.1.0/24" # 内部 LAN 的网域，若没有内部 LAN 请设定为 ""
 export EXTIF INIF INNET
# 第一部份，针对本机的防火墙设定！###########################
# 1. 先设定好核心的网络功能：
 echo "1" > /proc/sys/net/ipv4/tcp_syncookies
 echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
 for i in /proc/sys/net/ipv4/conf/*/rp_filter; do
 echo "1" > $i
 done
 for i in /proc/sys/net/ipv4/conf/*/log_martians; do
 echo "1" > $i
 done
 for i in /proc/sys/net/ipv4/conf/*/accept_source_route; do
 echo "0" > $i
 done
 for i in /proc/sys/net/ipv4/conf/*/accept_redirects; do
 echo "0" > $i
 done
 for i in /proc/sys/net/ipv4/conf/*/send_redirects; do
 echo "0" > $i
 done
# 2. 清除规则、设定预设政策及开放 lo 与相关的设定值
 PATH=/sbin:/usr/sbin:/bin:/usr/bin; export PATH
 iptables -F
 iptables -X
 iptables -Z
 iptables -P INPUT DROP
 iptables -P OUTPUT ACCEPT
 iptables -P FORWARD ACCEPT
 iptables -A INPUT -i lo -j ACCEPT
 iptables -A INPUT -m state --state RELATED -j ACCEPT
# 3. 启动额外的防火墙 script 模块
 if [ -f /usr/local/virus/iptables/iptables.deny ]; then
 sh /usr/local/virus/iptables/iptables.deny
 fi
 if [ -f /usr/local/virus/iptables/iptables.allow ]; then
 sh /usr/local/virus/iptables/iptables.allow
 fi
 if [ -f /usr/local/virus/httpd-err/iptables.http ]; then
 sh /usr/local/virus/httpd-err/iptables.http
 fi
 iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT
# 4. 允许某些类型的 ICMP 封包进入
 AICMP="0 3 3/4 4 11 12 14 16 18"
 for tyicmp in $AICMP
 do
 iptables -A INPUT -i $EXTIF -p icmp --icmp-type $tyicmp -j ACCEPT
 done
# 5. 允许某些服务的进入，请依照您自己的环境开启
# iptables -A INPUT -p TCP -i $EXTIF --dport 22 -j ACCEPT # SSH
# iptables -A INPUT -p TCP -i $EXTIF --dport 25 -j ACCEPT # SMTP
# iptables -A INPUT -p UDP -i $EXTIF --sport 53 -j ACCEPT # DNS
# iptables -A INPUT -p TCP -i $EXTIF --sport 53 -j ACCEPT # DNS
# iptables -A INPUT -p TCP -i $EXTIF --dport 80 -j ACCEPT # WWW
# iptables -A INPUT -p TCP -i $EXTIF --dport 110 -j ACCEPT # POP3
# iptables -A INPUT -p TCP -i $EXTIF --dport 443 -j ACCEPT # HTTPS
# 第二部份，针对后端主机的防火墙设定！##############################
# 1. 先加载一些有用的模块
 modules="ip_tables iptable_nat ip_nat_ftp ip_nat_irc ip_conntrack
ip_conntrack_ftp ip_conntrack_irc"
 for mod in $modules
 do
 testmod=`lsmod | grep "${mod} "`
 if [ "$testmod" == "" ]; then
 modprobe $mod
 fi
 done
# 2. 清除 NAT table 的规则吧！
 iptables -F -t nat
 iptables -X -t nat
 iptables -Z -t nat
 iptables -t nat -P PREROUTING ACCEPT
 iptables -t nat -P POSTROUTING ACCEPT
 iptables -t nat -P OUTPUT ACCEPT
# 3. 开放成为路由器，且为 IP 分享器！
 if [ "$INIF" != "" ]; then
 iptables -A INPUT -i $INIF -j ACCEPT
 echo "1" > /proc/sys/net/ipv4/ip_forward
 if [ "$INNET" != "" ]; then
 for innet in $INNET
 do
 iptables -t nat -A POSTROUTING -s $innet -o $EXTIF -j MASQUERADE
 done
 fi
 fi
# 4. 内部服务器的设定：
# iptables -t nat -A PREROUTING -p tcp -i $EXTIF --dport 80 \
 -j DNAT --to 192.168.1.210:80
特别留意上面程序代码的特殊字体部分，基本上，你只要修改一下最上方的接口部分， 应该就能够运作这
个防火墙了。不过因为每个人的环境都不相同， 因此你在设定完成后，依旧需要测试一下才行喔！不然，
出了问题不要怪我啊！.... 再来看一下关于 iptables.allow 的内容是如何？假如我要让一个
140.116.44.0/24 这个网域的所有主机来源可以进入我的主机的话，那么这个档案的内容可以写成这样：
[root@linux iptables]# vi iptables.allow
#!/bin/bash
# 底下则填写你允许进入本机的其它网域或主机啊！
 iptables -A INPUT -i $EXTIF -s 140.116.44.0/24 -j ACCEPT
# 底下则是关于抵挡的档案设定法！
[root@linux iptables]# vi iptables.deny
#!/bin/bash
# 底下填写的是『你要抵挡的那个咚咚！』
 iptables -A INPUT -i $EXTIF -s 140.116.44.254 -j DROP
[root@linux iptables]# chmod 700 iptables.*
将这三个档案的权限设定为 700 且只属于 root 的权限后，就能够直接执行 iptables.rule 啰！ 不过要
注意的是，在上面的案例当中，鸟哥预设将所有的服务的通道都是关闭的！ 所以你必须要到本机防火墙的
第 5 步骤处将一些批注符号 (#) 解开才行。 同样的，如果有其它更多的 port 想要开启时，一样需要增
加额外的规则才行喔！
不过，还是如同前面我们所说的，这个 firewall 仅能提供基本的安全防护，其它的相关问题还需要再测
试测试呢！ 此外，如果你希望一开机就自动执行这个 script 的话，请将这个档案的完整档名写入
/etc/rc.d/rc.local 当中，有点像底下这样：
[root@linux ~]# vi /etc/rc.d/rc.local
.....其它省略.....
# 1. Firewall
/usr/local/virus/iptables/iptables.rule
.....其它省略.....
上述三个档案请你不要在 Windows 系统上面编辑后传送到 Linux 上运作，因为 Windows 系统的断行字符
问题， 将可能导致该档案无法执行。建议你直接到底下去下载，传送到 Linux 后可以利用 dos2unix 指
令去转换断行字符！ 就不会有问题！
• http://linux.vbird.org/download/index.php?action=detail&fileid=43
这就是一个最简单、阳春的防火墙。同时，这个防火墙还可以具有最阳春的 IP 分享器的功能呢！ 也就是
在 iptables.rule 这个档案当中的第二部分了。 这部分我们在下一节会再继续介绍的。
NAT 主机的设定
呼呼！终于来到这个地方了！我们准备要架设一个路由器的延伸服务器，就称之为 NAT 主机。 NAT 是什
么呢？简单的说，你可以称他为内部 LAN 主机的『 IP 分享器』啦！
NAT 的全名是 Network Address Translation，字面上的意思是『网络地址的转换』。由字面上的意思我
们来想一想， TCP/IP 的网络封包不是有 IP 地址吗？那 IP 地址不是有来源与目的吗？我们的 iptables
指令就能够修改 IP 封包的表头数据， 嘿嘿！连目标或来源的 IP 地址都可以修改呢！甚至连 TCP 封包
表头的 port number 也能修改！真是有趣！
NAT 主机的功能可以达到类似图二所介绍的类似 IP 分享的功能之外， 还可以达到类似图四所介绍的 DMZ
(非军事区) 的功能！这完全取决于我们的 NAT 是修改： (1)来源 IP 还是 (2)目标 IP ！底下我们就来
聊一聊吧！ ^_^
什么是 NAT？ SNAT？ DNAT？
在谈到 NAT 的实际运作之前，让我们再来看一下比较简单的封包透过 iptables 而传送到后端主机的流程
(请往前参考图八)。当网络布线如图二的架构， 若内部 LAN 有任何一部主机想要传送封包出去时，那么
这个封包要如何透过 Linux 主机而传送出去？ 他是这样的：
1. 先经过 NAT table 的 PREROUTING 链；
2. 经由路由判断确定这个封包是要进入本机与否，若不进入本机，则下一步；
3. 再经过 Filter table 的 FORWARD 链；
4. 通过 NAT table 的 POSTROUTING 链，最后传送出去。
NAT 主机的重点就在于上面流程的第 1,4 步骤，也就是 NAT table 的两条重要的链：PREROUTING 与
POSTROUTING。 那这两条链有什么重要的功能呢？重点在于修改 IP 嘛！但是这两条链修改的 IP 是不一
样的！ POSTROUTING 在修改来源 IP ，PREROUTING 则在修改目标 IP 。 由于修改的 IP 不一样，所以就
称为 来源 NAT (Source NAT, SNAT) 及目标 NAT (Destination NAT, DNAT)。我们先来谈一谈 IP 分享器
功能的 SNAT 吧！
• 来源 NAT, SNAT
你应该有听说过 IP 分享器这个玩意儿，他可以让你家庭里的好几部主机同时透过一条 ADSL 网络联机到
Internet 上面， 例如图二联机的方式来说，那个 Linux 主机就是 IP 分享器啦！那么他是如何达到 IP 分
享的功能？就是透过 NAT 表格的 POSTROUTING 来处理的。假设你的网络布线如图二所示， 那么 NAT 主
机是如何处理这个封包的呢？
图十、SNAT 封包传送出去的示意图
如上图所示，在客户端 192.168.1.100 这部主机要联机到 http://tw.yahoo.com 去时，他的封包表头会
如何变化？
1. 客户端所发出的封包表头中，来源会是 192.168.1.100 ，然后传送到 NAT 这部主机；
2. NAT 这部主机的内部接口 (192.168.1.2) 接收到这个封包后，会主动分析表头资料， 因为表头
数据显示目的并非 Linux 本机，所以开始经过路由， 将此封包转到可以连接到 Internet 的
Public IP 处；
3. 由于 private IP 与 public IP 不能互通，所以 Linux 主机透过 iptables 的 NAT table 内的
Postrouting 链将封包表头的来源伪装成为 Linux 的 Public IP ，并且将两个不同来源
(192.168.1.100 及 public IP) 的封包对应写入暂存内存当中， 然后将此封包传送出去了；
此时 Internet 上面看到这个封包时，都只会知道这个封包来自那个 Public IP 而不知道其实是来自内部
啦。 好了，那么如果 Internet 回传封包呢？又会怎么作？
图十一、SNAT 封包接收的示意图
4. 在 Internet 上面的主机接到这个封包时，会将响应数据传送给那个 Public IP 的主机；
5. 当 Linux NAT 主机收到来自 Internet 的响应封包后，会分析该封包的序号，并比对刚刚记录到
内存当中的数据， 由于发现该封包为后端主机之前传送出去的，因此在 NAT Prerouting 链中，
会将目标 IP 修改成为后端主机，亦即那部 192.168.1.100，然后发现目标已经不是本机 (public
IP)， 所以开始透过路由分析封包流向；
6. 封包会传送到 192.168.1.2 这个内部接口，然后再传送到最终目标 192.168.1.100 机器上去！
经过这个流程，您就可以发现到，所有内部 LAN 的主机都可以透过这部 NAT 主机联机出去， 而大家在
Internet 上面看到的都是同一个 IP (就是 NAT 那部主机的 public IP 啦！)， 所以，如果内部 LAN 主
机没有连上不明网站的话，那么内部主机其实是具有一定程度的安全性的啦！ 因为 Internet 上的其它主
机没有办法主动攻击你的 LAN 内的 PC 嘛！所以我们才会说， NAT 最简单的功能就是类似 IP 分享器啦！
那也是 SNAT 的一种。
Tips:
NAT 主机与路由器有啥不同？基本上，NAT 主机一定是路由器，不
过， NAT 主机由于会修改 IP 表头数据， 因此与单纯转递封包的
路由器不同。最常见的 IP 分享器就是一个路由器，但是这个 IP
分享器一定会有一个 Public IP 与一个 Private IP，让 LAN 内
的 Private IP 可以透过 IP 分享器的 Public IP 传送出去喔！
至于路由器通常两边都是 Public IP 或同时为 Private IP。
• 目标 NAT, DNAT
SNAT 主要是应付内部 LAN 连接到 Internet 的使用方式，至于 DNAT 则主要用在内部主机想要架设可以
让 Internet 存取的服务器啦！ 就有点类似图四的 DMZ 内的主机啊！底下也先来谈一谈 DNAT 的运作吧！
图十二、DNAT 的封包传送示意图
如上图十二所示，假设我的内部主机 192.168.1.210 启动了 WWW 服务，这个服务的 port 开启在 port
80 ， 那么 Internet 上面的主机 (61.xx.xx.xx) 要如何连接到我的内部服务器呢？当然啦， 还是得要
透过 Linux NAT 主机嘛！所以这部 Internet 上面的机器必须要连接到我们的 NAT 的 public IP 才行。
1. 外部主机想要连接到目的端的 WWW 服务，则必须要连接到我们的 NAT 主机上头；
2. 我们的 NAT 主机已经设定好要分析出 port 80 的封包，所以当 NAT 主机接到这个封包后， 会
将目标 IP 由 public IP 改成 192.168.1.210 ，且将该封包相关信息记录下来，等待内部服务
器的响应；
3. 上述的封包在经过路由后，来到 private 接口处，然后透过内部的 LAN 传送到 192.168.1.210
上头！
4. 192.186.1.210 会响应数据给 61.xx.xx.xx ，这个回应当然会传送到 192.168.1.2 上头去；
5. 经过路由判断后，来到 NAT Postrouting 的链，然后透过刚刚第二步骤的记录，将来源 IP 由
192.168.1.210 改为 public IP 后，就可以传送出去了！ (类似图十的状态！)。
其实整个步骤几乎就等于 SNAT 的反向传送哩！这就是 DNAT 啰！很简单吧！
最阳春 NAT 主机： IP 分享功能
在 Linux 的 NAT 主机服务当中，最常见的就是类似图二的 IP 分享器功能了。 而由刚刚的介绍你也该知
道，这个 IP 分享器的功能其实就是 SNAT 啦！作用就只是在 iptables 内的 NAT 表格当中，那个路由后
的 POSTROUTING 链进行 IP 的伪装就是了。另外， 你也必须要了解，你的 NAT 主机必须要有一个 public
IP 接口，以及一个内部 LAN 连接的 private IP 接口才行。
同样的，我的假设是这样的：
• 外部接口使用 eth1 ，这个接口具有 public IP 喔；
• 内部接口使用 eth0 ，假设这个 IP 为 192.168.1.2 ；
记住！当你利用前面几章谈到的数据来设定你的网络参数后，务必要进行路由的检测， 因为在 NAT 主机
的设定方面，最容易出错的地方就是路由了！尤其是在拨皆产生 ppp0 这个对外接口的环境下， 这个问题
最严重。反正你要记得：『如果你的 public IP 取得的方式是拨接或 cable modem 时，你的设定档
/etc/sysconfig/network, ifcfg-eth0, ifcfg-eth1 等档案，千万不要设定 GATEWAY 啦！』否则就会出
现两个 default gateway ，反而会造成问题。
如果你刚刚已经下载了 iptables.rule ，那么该档案内已经含有 NAT 的脚本了！ 你可以看到该档案的第
二部份关于 NAT 主机的部分，应该有看到底下这几行：
iptables -A INPUT -i $INIF -j ACCEPT
# 这一行在让 NAT 主机可接受来自内部 LAN 的封包
echo "1" > /proc/sys/net/ipv4/ip_forward
# 上头这一行则是在让你的 Linux 具有 router 的能力
iptables -t nat -A POSTROUTING -s $innet -o $EXTIF -j MASQUERADE
# 这一行最关键！就是加入 nat table 封包伪装！
重点在那个『 MASQUERADE 』！这个设定值就是『 IP 伪装成为封包出去 (-o) 的那块装置上的 IP 』！
以上面的例子来说，就是 $EXTIF ，也就是 eth1 啦！ 所以封包来源只要来自 $innet (也就是内部 LAN 的
其它主机) ，只要该封包可透过 eth1 传送出去， 那就会自动的修改 IP 的来源表头成为 eth1 的 public
IP 啦！就这么简单！ 你只要将 iptables.rule 下载后，并设定好你的内、外网络接口， 执行
iptables.rule 后，你的 Linux 就拥有主机防火墙以及 NAT 主机的功能了！
• LAN 内其它 PC 的设定
上面提到的是 NAT 主机的设定，那么在 LAN 内的其它 PC 网络参数要如何设定呢？很简单啊， 只要记得
底下的参数值即可：
• NETWORK 为 192.168.1.0
• NETMASK 为 255.255.255.0
• BROADCAST 为 192.168.1.255
• IP 可以设定 192.168.1.1 ~ 192.168.1.254 间，不可重复！
• 通讯闸 (Gateway) 需要设定为 192.168.1.2 (NAT 主机的 Private IP)
• DNS (/etc/resolv.conf) 需设定为 168.95.1.1 (Hinet) 或 139.175.10.20 (Seed Net)， 这个
请依您的 ISP 而定；
这样就搞定一部阳春的 NAT 主机了！简单的要命啊！
事实上，除了 IP 伪装 (MASQUERADE) 之外，我们还可以直接指定修改 IP 封包表头的来源 IP 呢！ 举例
来说，如下面这个例子：
范例：将要由 eth1 传送出去的封包，封包来源改为 192.168.200.250
[root@linux ~]# iptables -t nat -A POSTROUTING -o eth1 \
> -j SNAT --to 192.168.200.250
范例：同上，但封包来源为 192.168.200.210~220
[root@linux ~]# iptables -t nat -A POSTROUTING -o eth1 \
> -j SNAT --to 192.168.200.210-192.168.200.210
这样也可以修改网络封包的来源 IP 资料喔！不过，除非你使用的是固定 IP ， 且有多个 IP 可以对外联
机，否则一般使用 IP 伪装即可，不需要使用到这个 SNAT 吧？ 当然，你也可能有自己的独特的环境啦！
^_^
iptables 的额外核心模块功能
如果你刚刚在 iptables.rule 内的第二部分有仔细看的话， 那有没有觉得很奇怪，为何我们需要加载一
些有用的模块？举例来说， ip_nat_ftp 及 ip_net_irc ？ 这是因为很多通讯协议使用的封包传输比较特
殊，尤其是 FTP 档案传输使用到两个 port 来处理资料！ 这个部分我们会在 FTP 章节再次的详谈，在这
里你要先知道，我们的 iptables 提供很多好用的模块， 这些模块可以辅助封包的过滤用途，让我们可以
节省很多 iptables 的规则拟定， 好棒的吶！ ^_^
在防火墙后端之网络服务器 DNAT 设定
既然可以做 SNAT 的 IP 分享功能，我们当然可以使用 iptables 做出 DMZ 啦！ 但是再次重申，不同的
服务器封包传输的方式可能有点差异，因此，建议新手不要玩这个咚咚！ 否则很容易导致某些服务无法顺
利对 Internet 提供的问题。
先来谈一谈，如果我想要处理 DNAT 的功能时， iptables 要如何下达指令？ 另外，你必须要知道的是，
DNAT 用到的是 nat table 的 Prerouting 链喔！不要搞错了。
范例：将连接到 eth1 接口的 port 80 传导到内部的 192.168.1.210
[root@linux ~]# iptables -t nat -A PREROUTING -p tcp -i eth1 \
> --dport 80 -j DNAT --to 192.168.1.210:80
那个『 -j DNAT --to IP[:port] 』就是精髓啦！代表从 eth1 这个接口传入的，且想要使用 port 80 的
服务时， 将该封包重新传导到 192.168.1.210:80 的 IP 及 port 上面！可以同时修改 IP 与 port 呢！
真方便。 其它还有一些较进阶的 iptables 使用方式，如下所示：
-j REDIRECT --to-ports <port number>
# 这个也挺常见的，基本上，就是进行本机上面 port 的转换就是了！
# 不过，特别留意的是，这个动作仅能够在 nat table 的 PREROUTING 以及
# OUTPUT 链上面实行而已喔！
范例：将要求与 80 联机的封包转递到 8080 这个 port
[root@linux ~]# iptables -t nat -A PREROUTING -p tcp --dport 80 \
> -j REDIRECT --to-ports 8080
# 这玩意最容易在您使用了非正规的 port 来进行某些 well known 的协议，
# 例如使用 8080 这个 port 来启动 WWW ，但是别人都以 port 80 来联机，
# 所以，您就可以使用上面的方式来将对方对您主机的联机传递到 8080 啰！
至于更多的用途，那就有待你自己的发掘啰！ ^_^
重点回顾
• 要拥有一部安全的主机，必须要有良好的主机权限设定；随时的更新套件；定期的重要数据备份；
完善的员工教育训练。 仅有防火墙是不足够的；
• 防火墙最大的功能就是帮助你『限制某些服务的存取来源』，可以管制来源与目标的 IP ；
• 防火墙依据封包抵挡的阶层，可以分为 Proxy 以及 IP Filter (封包过滤) 两种类型；
• 为了将整个网络的信任 (LAN) 与不信任 (Internet) 网域完整切割，防火墙通常具有两个实体网
络接口， 分别连结信任与不信任网域；
• 在防火墙内，但不在 LAN 内的服务器所在网域，通常被称为 DMZ (非军事区)，如图四所示；
• 封包过滤机制的防火墙，通常至少可以分析 IP, port, flag (如 TCP 封包的 SYN), MAC 等等；
• 防火墙对于病毒的抵挡并不敏感；
• 防火墙对于来自内部的网络误用或滥用的抵挡性可能较不足；
• 并不是架设防火墙之后，系统就一定很安全！还是需要更新套件漏洞以及管制使用者及权限设定
等；
• 核心 2.4 以后的 Linux 使用 iptables 作为防火墙的软件；
• 防火墙的订定与『规则顺序』有很大的关系；若规则顺序错误，可能会导致防火墙的失效；
• iptables 的预设 table 共有三个，分别是 filter, nat 及 mangle ，惯用者为 filter (本机)
与 nat (后端主机)。
• filter table 主要为针对本机的防火墙设定，依据封包流向又分为 INPUT, OUTPUT, FORWARD 三
条链；
• nat table 主要针对防火墙的后端主机，依据封包流向又分为 PREROUTING, OUTPUT, POSTROUTING
三条链， 其中 PREROUTING 与 DNAT 有关， POSTROUTING 则与 SNAT 有关；
• iptables 的防火墙为规则比对，但所有规则都不符合时，则以预设政策 (policy) 作为封包的行
为依据；
• 核心本身有提供很多网络相关功能，针对 IPv4 之设定值都在 /proc/sys/net/ipv4/* 内；
• iptables 的指令列当中，可以下达的参数相当的多，当下达 -j LOG 的参数时，则该封包的流程
会被纪录到 /var/log/messages 当中；
• 防火墙可以多重设定，例如虽然已经设定了 iptables ，但是仍然可以持续设定 TCP Wrappers ，
因为谁也不晓得什么时候 iptables 会有漏洞～或者是规则规划不良！
课后练习
• 为什么我架设了防火墙，我的主机还是可能中毒？
防火墙不是万灵丹，他还是可能被病毒或者是木马程序所入侵的！ 此外，如果您的主机本身就已
经提供了多个网络服务，则当该网络服务的套件有漏洞时， 防火墙仍然无法克服该服务的漏洞的！
因此仍然需要持续的进行主机的监视工作
• 请说明为何架设了防火墙，我的主机还是可能被入侵？入侵的依据可能是什么方法？
因为防火墙仅是抵挡某些不受欢迎的封包，如果您有开放 WWW 的服务时，则要求您主机 port 80
的封包将可直接进入您的主机，万一 WWW 套件有漏洞时，那么就可能被入侵了！所以套件的更新
很重要！
• 我们知道核心为 2.4 的 Linux 使用的防火墙机制为 iptables ，请问，如何知道我的 Linux 核
心版本？
利用 uname -r 可以查得！
• 请列出 iptables 预设的两个主要的 table ，以及各个 table 里面的 chains 与各个 chains
所代表的意义；
filter 为预设的 Table，里头预设的链有：
o INPUT：为来自外部，想要进入主机的封包；
o OUTPUT：为来自主机，想要离开主机的封包；
o FORWARD：为主机内部网域与外部网域的封包(不论进或者出)，但该封包不会进入主机。
还有 nat 这个 table：
o PREROUTING：进行路由之前的封包传送过程
o OUTPUT：离开主机的封包传送过程；
o POSTROUTING：已经经过路由了，然后才进行的过滤规则。
• 什么是 iptables 的预设政策 (Policy)？若我要针对 filter 的 INPUT 做成 DROP 的预设政
策，指令如何下达？
当封包的所有属性都不在防火墙的规则当中时，那么这个封包能否顺利的通过防火墙，则以
Policy 作为这个封包的最终动作了！
iptables -P INPUT DROP
• 假设今天我的 Linux 仅是作为 Client 之用，并没有对 Internet 进行任何服务， 那么您的防
火墙规划应该如何设定比较好？！
既然没有对 Internet 提供任何服务，那么(1)请将所有的对外埠口先关闭吧！(2)防火墙规则当
中，最重要的是 INPUT 的 Policy 一定要 DROP ，然后将『 iptables -A INPUT -m state --state
RELATED,ESTABLISHED -j ACCEPT 』即可！
• 我要将来自 192.168.1.50 这个 IP 来源的封包，只要是向我的 21~23 埠口要求的封包，就将他
抵挡，应该如何下达 iptables 指令？
iptables -A INPUT -p tcp -s 192.168.1.50 --dport 21:23 -j DROP
• 我要将我自己主机 ping 的响应功能取消，应该如何下达 iptables 的指令？
因为 ping 能否响应用的是 icmp 的 type 8 (请参考网络基础内的 ICMP 相关内容)，所以我可
以这样做：
iptables -I INPUT -p icmp --icmp-type 8 -j DROP
• 请说明为何这个指令是错误的？『iptables -A INPUT -p udp --syn -s 192.168.0.20 -j DROP』？
因为只有 TCP 封包才会具有 SYN 的标志， UDP 并没有 SYN 的标志啊！所以上面的指令是错误
的
• DNS 的要求是必须的，那么我该如何设定我的主机可以接受要求 DNS 的响应呢？
因为 DNS 的来源是 port 53 ，因此要接受来自 port 53 的封包就成为了：
iptables -A INPUT -p udp --sport 53 -j ACCEPT
iptables -A INPUT -p tcp --sport 53 -j ACCEPT
• 如何取消 iptables 在我的系统上面？
先要清除规则后，才能够将 iptables 移除！不过，我们主要将规则清除即可！
iptables -F; iptables -X; iptables -Z
iptables -t nat -F; iptables -t nat -X; iptables -t nat -Z
• 如何储存目前的防火墙机制，以及如何将上次储存下来的机制回复到目前的系统中？
请利用 iptables-save 以及 iptables-restore 这两个指令，配合命令重导向即可！
• 如果你的区网当中有个 PC 使用者老是连上 Internet 乱搞，你想要将他的 IP 锁住，但他总是
有办法修改成其它 IP 来连外， 那你该怎么办？让他无法继续连外？
可以利用封锁网络卡卡号 MAC 来处理！


另外：关于域名的处理
1、如果网关没有开DNS服务器，就只在FOWARD链加入就可以了：
iptables -I FORWARD 1 -p udp -m domain --name "www.126.com" -j DROP
2、如果网关运行DNS服务，还要加入下面的：
iptables -I INPUT 1 -p udp -m domain --name "www.126.com" -j DROP

____________________________________________________________

申请合法的主机名称
最近更新日期：2006/09/16
呵呵！在您读完了网络基础，设定好了防火墙，解决了认识埠口的问题，并且架设了个人简易的防火墙之
后， 总算是准备要开始来给他进入 Server 的架设了！服务器架设的步骤里面，很重要的一点是『您的主
机名称必须要在 Internet 上面可以被查询』才好！由网络基础我们知道网络上的设备(主机或其它网络媒体)
仅认识 IP ，但人类对于 IP 记忆力又不佳，所以才会以主机名称来取代 IP。不过， 您的主机名称要能
够被查询到才有用啊！这个时候，一个『合法』的主机名称就很重要了！那要合法的主机，就得要让 DNS
系统能够找的到您的主机啊！不过，如果我们的主机是使用拨接得到的不固定 IP 呢？又该如何申请 DNS
主机名称？那就得要使用动态 DNS 的系统啰！在这个章节中，我们主要在介绍 Client 端的设定，而不是
在设定 DNS 主机喔！  ^_^
1. 本章的行前准备工作
2. 为何需要主机名称
 2.1 主机名称的由来
 2.2 重点在合法授权
 2.2 申请静态还是动态 DNS 主机名称
3. 注册一个合法的主机名称
 3.1 静态 DNS 注册：以 Hinet 为例
 3.2 动态 DNS 注册：以 no-ip 为例
4. 课后练习
5. 参考数据
5. 针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=26634
本章的行前准备工作
在这个章节当中，我们将会介绍如何申请一个合法的主机名称。目前 Internet 上面使用的主机名称都是
透过所谓的 DNS 系统，而你想要取得一个 DNS 的主机名称，就必须要『注册』，所谓的『注册』就是要
钱去申请啦！ 当然也有免费提供主机名称的服务啦！在这个章节当中鸟哥不会介绍如何架设一部 DNS 主
机， 而是介绍如何利用注册或免费申请的方式来达成主机名称的取得。在这一章开始前，您最好先复习一
下：
• 因为需要安装软件，你需要知道原始码、tarball 及安装的流程；
• 取得主机名称你需要知道网络基础章节内的 DNS 简介；
• 由于谈到很多 IP 的观念，你必须要知道网络基础章节内的自动取得 IP 与固定 IP 的意义；
如果没问题的话，那就赶紧来玩玩！
为何需要主机名称
如果你已经将网络基础那一章看完的话，应该会知道其实我们的 TCP/IP 环境只要有 IP 与正确的路由即
可联机了。 那么你申请主机名称要干嘛？因为『没办法啊！人脑太不中用了！』 举例来说，你可以背出
来我们常上去查数据的 www.google.com 的 IP 吗？报告！鸟哥没办法背出来～
因为 IP 是那么难背的东西，而且，如果您的 IP 又是类似拨接的不固定的 IP 时，那还更伤脑筋呢！ 因
此我们才会习惯以熟悉的英文字符串来做为主机名称， 然后让『这个主机名称与 IP 达成对应』，那直接
记忆主机名称就行了，反正 IP 的查询就交给计算机主机来做即可！ 在这样的想法下，我们当然就需要有
主机名称啦！底下咱们就来谈一谈先！
主机名称的由来
从上面的说明我们知道因为 IP 不好记，所以人类习惯使用主机名称来记忆与连上某部主机。 好在早期连
上网络的计算机数量不多，所以在网络上的人们就想出一个简单的办法来进行主机名称与 IP 的对应，那
就是『在每部计算机的 /etc/hosts 里面设定好主机名称与 IP 的对应表』。那么未来人们就可以直接藉
由主机名称来连接上某些网络上的主机啰！
然而因为科技的发达，连上 Internet 的人们越来越多，使用 /etc/hosts 的方法已经搞不定了(只要一部
计算机上线，全部的 Internet 上面的所有计算机都要重新改写 /etc/hosts！不太好吧！) ，这个时候领
域名称系统 ( Domain Name System, DNS ) 就适时的出现了！
DNS 利用类似树状目录的型态，将主机名称的管理分配在不同层级的 DNS 主机当中，经由分层管理，所以
每一部主机的记忆的信息就不会很多，而且异动上面也相当的容易修改！ 那么这个 DNS 的功能您知道了
吗？对啦！就是『将计算机主机的名称转译成 IP 』就是了！当然啰，他的额外功能还很多，关于 DNS 的
详细的解析部分我们将在后续的 DNS 主机架设章节当中在持续的加强内容，总之， 他的最大功能就是『让
有意义的，人类较容易记忆的主机名称(英文字母) ，转译成为计算机所熟悉的 IP 地址！』
重点在合法授权
很多朋友都认为：『因为我想要架站，所以主机需要有个主机名称， 因此我就得要架设 DNS？』是这样吗？
当然不是啰！DNS 是个很庞大的架构， 而且是串连在全球的网络当中，除非你经由『注册』的手续来让 DNS
系统承认你的主机名称的存在， 否则你架设的 DNS 只能说是一个『地下练习的测试站』而已啦！并没有
用途的。
那我要如何加入 DNS 系统呢？很简单啦！首先你必须要选择一个注册单位， 并且检查出你想要注册的主
机名称是否存在？主机名称是有意义的，并不是你可以随便注册的喔！ 举例来说，在台湾常见的个人网站
注册主机名称为： *.idv.tw ，而公司行号则可能注册为 *.com.tw 了！这个得要特别留意。至于台湾地
区的注册单位很多，你可以选择例如 Hinet 或 Seednet 之类的 ISP 来注册。当然，你也可以选择免费的
no-ip.org 来注册的。
但要请您特别注意的是，并不是所有的注册单位都提供单纯主机名称的对应功能， 所以要注册前，请『货
比三家』啊！鸟哥所申请的单位分别是国外的 .org 及台湾的 Hinet 两家， Hinet 有提供 .idv.tw 的主
机名称对应，还不错。 当然你也可以使用免费的 no-ip.org 来进行主机名称的注册！
Tips:
在这个章节当中，鸟哥的讲解比较少，因为很多数据都与 DNS 服
务器篇 有重复，在这个章节当中鸟哥主要在介绍动态 IP 架站的
一个简单主机名称申请方式啦！ ^_^
申请静态还是动态 DNS 主机名称
由上面的说明当中，我们可以很清楚的知道 DNS 系统最大的功能就是在主机名称对应 IP 的转译上面。当
然啦，预设的 DNS 转译是用在『固定 IP 对应主机名称』 的方法上面的！夭寿喔！我们的小站很多都是
以非固定 IP (很多人也称为浮动式 IP 、动态 IP 等等的名称) 来上网的，更有甚者， Hinet 的 ADSL 拨
接都是 24 小时强制断线一次的，所以我们都得需要重新拨接上网， 而每次拨接成功后取得的 IP 可不见
得相同啊，如此一来 IP 不是一直在变吗？ 那么我不就需要一直跟我上层 DNS 主机的管理员申请『变更
IP 』吗？会不会太麻烦了点？
是很麻烦啊！所以现在为了解决这个问题，很多 ISP 提供了所谓的 动态 DNS 主机服务 的功能，他是这
样做的：
1. Client 端(就是您啦)每次开机或者是重新拨接，并取得一个新的 IP 之后，会向 DNS Server 端
提出要求，希望 Server 端变更主机名称与 IP 的对应 (这个步骤在每个主要的 ISP 都有提供适
当的 program 来提供给 client 使用)；
2. Server 端接受 Client 端的要求之后，会先去查询 Client 提供的账号密码是否正确， 正确之
后就会立即修改 Server 本身对于您的主机名称的设定值。
所以啰，每次我们取得了新的 IP 之后，我们的主机名称对应的 IP 也会跟着在 DNS 系统上面更新， 如
此一来，只要别人知道您的主机名称，不论您的 IP 为何，他一定可以连上您的主机 (因为 IP 跟着您的
主机而变！) 这对于我们这种使用动态 IP 的人是很有帮助的！ (阿！真是造福我们这些穷苦人家的孩子
呀！)
不过，还是需要注意的是，目前的主机名称申请很多是『需要钱的』！如果您需要比较稳定的主机名称对
应 IP 的服务，那么花点钱来注册还是必须的，不过，如果是实验性质的网站，那么也是可以申请免费的
动态 DNS 系统喔！
注册一个合法的主机名称
静态 DNS 主机注册：
好了，既然知道了 DNS 的用途，那么自然我们就需要来申请 DNS 啦！不然怎么架设网站呢？目前的静态 IP
对应主机名称的注册网站实在太多了，我们仅提出几个出来分享就是了！
• 台湾网络信息中心： http://www.twnic.net
• 国外的领域名称系统： http://www.netsol.com/
• 国外的领域名称系统： http://www.dotster.com/
动态 DNS 主机注册：
那么有没有免费的 DNS 系统呀！呵呵！当然有啰！我们要感谢造福我们这些穷苦人家的孩子的大好人～ 您
可以在底下找到相关的信息：
• 国外的免费 DNS 系统： http://www.no-ip.com
静态 DNS 注册：以 Hinet 为例
静态 DNS 的申请方式其实都差不多，都是需要：
1. 先查询所想要注册的网域是否存在；
2. 进入 ISP 去申请注册您所想要的主机名称；
3. 缴费，并等待主机名称被启用。
我们以台湾蛮常见的 Hinet 这个 ISP 提供的『个人网域, .idv.tw』注册方式来说明：
1. 登入主画面，并查询欲注册网域是否存在
直接连结到底下的网页去： http://nweb.hinet.net/ ，并在 whois 的画面当中(右上角)选择您
想要注册的主机名称，按下『Go』开始搜寻。
图一、利用 whois 查询欲注册网域是否存在
2. 逐步进行注册
如果确认您的主机名称没有被注册掉，那么您就可以开始注册了！同样的在上面的网站连结当中，
选择『个人网域名称』就可以开始申请了！请依序一步一步办理！这里不再说明了，反正都是中
文， 看的懂得啦！ ^_^
图二、个人网域逐步注册的流程示意图
3. 填写主机名称对应的 IP
缴费完毕之后，我们就可以开始进行主机名称的填写了！在图二的图示中按下『DNS 指定/异动』
的项目， 并填入您的主机名称与密码，然后就会出现如下的画面了：
图三、主机名称与 IP 对应的填写范例
特别的给他留意，因为我们没有要架设 DNS 主机，所以当然最上方要选择『主机』的项目， 然
后您可以填入三部主机名称喔！当然，这三部主机名称可以通通指向同一个 IP ，也可以不同！ 随
您的便吶！需要注意到的是，您的主机名称应该是『othername.yourhost.idv.tw』后面的
yourhost.idv.tw 是不变的，前面的 othername 则可以自由选取呢！例如鸟哥上面的设定，后面
均是 vbird.idv.tw ，而前面的名称就可以让我自由选择啦！
4. 等待 DNS 启用
在上图三当中按下『填写完请按这里』后，就等着启用吧！不过设定成功到可以使用， 其实需要
一定的时间的，以鸟哥为例，第一次申请之后，大约过了 20 小时该设定才正确的启动呢！请以
请耐心等候啊！不要太着急啰！ ^_^
各家的领域名称注册流程都差不多，不过，金额是有点差异的，当然，服务也就有不同啊！鸟哥的 vbird.org
领域名称则是在 http://www.godaddy.com 注册的喔！如果您不想要使用 .idv.tw 来注册的话，那么国外
的 ISP 提供的 DNS 也可以考虑看看说！
动态 DNS 注册：以 no-ip 为例
如果你跟鸟哥一样使用 ADSL 拨接的方式来上网，这表示你的 IP 应该是不固定的！果真如此的话， 那想
要架站就比较麻烦一点！因为上面利用 Hinet 注册的方式通常是给固定 IP 使用的， 你应该不会想要天
天上去更新你的 IP 吧？此时这个 no-ip.com 所提供的免费动态 IP 对应主机名称的服务就很重要啦！我
们先来申请一个主机名称来玩玩吧！ ^_^
1. 登入主网页，并且注册一个新账号
你必须要连上 http://www.no-ip.com 这个网站， 然后在出现的画面当中选择『 Sign-up Now 』
那个项目：
图四、 no-ip 网站的注册流程之一
2. 开始填写识别数据
因为 no-ip 会发给您一份密码，所以在出现的如下画面中，您必须要填写『 一个可以收到邮件
的合法 Email 』，以及您的身份确认数据， 这很重要，因为后续的数据都是使用您注册时的这
个咚咚吶！然后再按下最底下的『SIGN UP NOW』即可！ 如果没有 Email 怎么办？现在免费的 email
这么多，随便申请一个吧！ ^_^
图五、 no-ip 网站的注册流程之二
3. 启用账号
在你申请注册一个新账号后， no-ip 会发一封信给你，信件的内容有点像底下那样：
图六、 no-ip 网站的注册流程之三
你必须要按下上图第一个箭头所指的连结后，你的账号才会正式的被启用的！ 而上图第二个连结
则是在告知你可以到哪里去下载动态 DNS 的客户端软件喔！ 也就是说， no-ip 也有提供一个好
用的软件给 client 端，让使用者可以『自动更新主机名称与 IP 的对应』， 呵呵！很棒吧！
4. 登入 no-ip 且设定主机名称与 IP 的对应
让我们回到图四的地方察看一下，不是有可以输入账号与密码的地方吗？ 请你填入你刚刚注册时
所填写的 email 地址以及密码后，就能够登入你的 no-ip 账号了。 在登入后的第一个画面左手
边有点类似底下的图示：
图七、 no-ip 网站的注册流程之四
在你按下那个『add』后，画面就会产生如下的变化：
图八、 no-ip 网站的注册流程之五
请依序填写你想要的主机名称、网域名称 (通常鸟哥都建议使用 no-ip.org 这一个领域名称！)，
还有你的 IP 后，咦！往下一看，竟然还有 MX 的纪录！这东西很重要！ 是用在做 mail server
时所需要的一项参数！你可以直接填写与你的完整主机名称相同的名字即可！ 填写完毕后，就按
下『Create Host』吧！如果该主机名称有被使用掉的话， 屏幕会出现警告讯息，此时请再选填
另外的主机名称吧！ ^_^
如果未来你想要修改或者是删除该主机名称时，可以按下图七内的 Manage 项目， 就能够进行删
除与修订的工作啰！就这么简单吶！
5. 设定自动更新主机名称与 IP 的对应
如果系统重新开机，或者是重新拨接取得一个新的 IP 后，我们都要登入 no-ip 来修改的话， 那
就太没有效率了！所以 no-ip 提供一个好用的客户端程序给使用者使用，就是在 图六 email 内
的那个下载连结！你可以点选该下载连结， 在出现的窗口当中会有三种程序，包括『 Windows, Mac,
Linux/BSD/Unix 』， 我们当然是选择 Linux 那个项目啊！请自行下载并且将该程序移动到 Linux
主机上吧！
整个安装与启用的流程式这样的：
1. 编译与安装：
[root@linux ~]# cd /usr/local/src
[root@linux src]# tar -zxvf /root/noip-duc-linux.tar.gz
# 假设你将程序放置到 /root 底下时
[root@linux src]# cd noip-2.1.3
# 注意一下，这个目录里面有个文件名为 README.FIRST 的档案，务必察看一下内容！
[root@linux noip-2.1.3]# make
[root@linux noip-2.1.3]# make install
# 这样会将主程序安装在 /usr/local/bin/noip2 而主参数档放在
# /usr/local/etc/no-ip2.conf 当中！然后你必须要开始回答一些问题：
Please select the Internet interface from this list.
By typing the number associated with it.
0 eth0
1 eth1
1 <==因为鸟哥的主机对外使用 eth1 接口
Please enter the login/email string for no-ip.com kiki@gmail.com
Please enter the password for user 'kiki@gmail.com' ***
# 上面这两个是你刚刚注册时所填写的 email 与密码喔！
Only one host [tsai.no-ip.org] is registered to this account.
It will be used.
Do you wish to run something at successful update?[N] (y/N) n
mv /tmp/no-ip2.conf /usr/local/etc/no-ip2.conf
# 重点在此！刚刚你做的设定档被放到上面这个档案中了！
这样就将你的 no-ip 制作完毕，而且也可以开始来执行啰！执行的方法也是很简单啦！
2. noip2 的程序使用：
[root@linux ~]# /usr/local/bin/noip2
# 不要怀疑！这样输入后，你在 no-ip 上面注册的主机名称，
# 就开始可以自动的产生对应了！就这么简单！
[root@linux ~]# noip2 [-CS]
参数：
-C ：重新设定参数，亦即设定刚刚我们上面输入粗体字的咚咚！
 如果您有两个以上的 no-ip 主机名称时，就一定需要使用 noip2 -C
 来重新设定参数档案！
-S ：将目前的 noip2 的状况显示出来！
[root@linux ~]# noip2 -S
1 noip2 process active.
Process 4998, started as /usr/local/src/noip-2.1.3/noip2
Using configuration from /usr/local/etc/no-ip2.conf
Last IP Address set 61.xxx.111.ddd
Account kiki@gmail.com
configured for:
 host tsai.no-ip.org
Address check every 1 minute, directly connected via /dev/eth1.
嘿嘿！这样就成功了！而且每分钟 noip2 可以自动的去主网站上面进行更新呢！ 真是很不错！
那如果想要一开机就启动 noip2 呢？这样做即可：
3. 设定开机启动：
[root@linux ~]# vi /etc/rc.d/rc.local
# 加入底下这一行：
/usr/local/bin/noip2
课后练习
• 请简易说明 /etc/hosts 的用途；
这个档案是早期用在进行主机名称与 IP 的解析的，目前比较常用在内部网域的名称解析上，可
以加快内部网域的反查喔！
• 请说明『合法授权』的主机名称需要做什么？
如果想要合法授权，就需要向上层 DNS 主机『注册』才行！而且还要上层 DNS 主机管理员愿意
将领域名称的解析权限授权给您啊！
• 什么是动态 DNS 系统？(仅说明 client 端)
因为我们的 Client 拨接时，得到的 IP 都不是固定的，所以无法以 DNS 系统进行固定 IP 对应
主机名称的工作！ 此时就需要动态 DNS 系统了！以 DNS 主机提供的动态更新主机名称对应 IP
的机制，可以让我们的不同 IP 对应到同一个主机名称吶！
• 如果您使用 adsl 拨接来上网设定服务器，那么该申请哪一类型的主机名称？为什么？
因为我是以 ADSL 上网拨接，所以 IP 是不固定的，此时需要申请动态 DNS 主机的主机名称，例
如 no-ip.org 等等！
____________________________________________________________

远程联机服务器 Telnet / SSH / VNC / XDMCP / RSH
最近更新日期：2006/09/19
一部连上 Internet 上面的您的个人主机，最重要的是什么呢？ 大概就是如何让您自己可以联机进入自己的
主机，并且进行所谓的『远程操控』了吧！ 也就是说，您可以在任何具有连上 Internet 的计算机中，以远
程联机软件连上 Internet ，并藉由您主机上面的远程联机服务器软件提供的功能，直接登入您的主机来进
行操控的工作！此时，您将发现 Linux 有趣又好玩的地方啰！在早期的 Unix Like 机器当中，几乎都提供
Telnet 这个远程联机服务器软件，不过，  Telnet 本身是以『明码』来传送您操作的数据，安全上面是值得
来思考要不要开放吶！ 这个时候就有需要了解一下传送过程中以加密动作来传送数据封包的 SSH 这个远
程联机服务器软件啦！ 另外，除了纯文字接口登入主机来进行操控之外，在现在的 Linux distributions 当
中， 还可以利用 X 相关的服务来帮助我们以图形接口登入喔！很棒吧！  ^_^
1. 本章的行前准备工作
2. 远程联机服务器
 2.1 什么是远程联机服务器
 2.2 有哪些可供登入的类型？
3. Telnet 服务器
 3.1 安装、启动与关闭服务
 3.2 好用的联机软件
 3.3 iptables, TCP_Wrappers, 纯建议
4. SSH 服务器
 4.1 联机加密技术简介
 4.2 启动 ssh 服务
 4.3 ssh 客户端联机： ssh, sftp, scp, putty 与 pietty, psftp
 4.4 详细设定 sshd 服务器：
 4.5 制作不用密码可立即登入的 ssh 用户 ： ssh-keygen
 4.6 安全设定：
5. Xdmcp 服务的启用
 5.1 X Window 的 Server/Client 架构
 5.2 设定 XDMCP
 5.3 用户登入
 5.4 关闭 XDMCP
6. VNC 服务器
7. RSH 服务器
 7.1 RSH Server： /etc/hosts.equiv, ~user/.rhosts
 7.2 RSH Client： rsh, rcp
8. 以 rsync 进行同步镜相备份
9. 重点回顾
10. 课后练习
11. 参考资源
12. 针对本文的建议：http://phorum.vbird.org/viewtopic.php?p=114550

远程联机服务器
远程联机服务器对我们来说，可是一项很有用的工具啊！他可以让我们更方便的管理主机。 不过，方便是
方便，安全性其实不很好的～所以，才要特别强调一下这个玩意儿啊！
什么是远程联机服务器
首先，我们要先来了解一下，什么是『远程联机服务器』？ 这个东西的功能为何？我想，您应该已经听过，
一个良好的网络环境当中，一部开放到 Internet 上面的服务器，基本上，他可以不需要屏幕、键盘、鼠
标等等的配备， 只要有基本的主机板、CPU、RAM、硬盘再加上一块好一点的网络卡，并且连上 Internet ！
哈哈！那么您要操控这部主机的时候，只要透过网络联机进来，然后进行任何修改即可！ 嘿！所以啰，这
个时候主机自然不需要接口设备啦！
以鸟哥个人为例，目前鸟哥管理大约七、八部左右的 Unix-Like 主机， 这些主机都不在同一个地方，分
布在南台湾各处！那么当有新的套件的漏洞被发布， 或者是需要进行一些额外的设定的时候，是否鸟哥本
人一定要到现场吗？当然不需要， 只要透过网络联机到该主机上面，就可以进行任何工作了！真的就好像
在主机前面工作一般的轻松愉快！ ^_^！这就是远程联机服务器啦！
远程联机服务器的功能当然还不只如此！举个例子来说：当您的工作需要使用到 Linux 的强大的编译功能
时，那么您一定需要 Linux 对吧！而且最好是运算速度快一点的主机， 这个时候您可以将您研究室最快
的那一部主机开放出来，设定一下远程联机服务器，让您的学生啦， 或者是研究室的同仁啦，可以透过这
部机器帮他们进行研究的工作，这个时候，您的主机就可以让多人进行分享 Linux 运算的功能啦！
在早期的网络世界里，由于只有 Unix 机器，而且个人计算机还不流行的时候， 想要使用大型主机来进行
数值程序的运算时(在我们工程界，比较常使用 Fortran 这一类的程序语言，至于 C 语言则较少碰～)，
就需要向学校单位申请 Unix 工作站的账号， 并且以远程联机程序连进主机，以使用 Unix 的资源来进行
我们的数值模式运算！所以啦，那个远程联机服务器的设定， 对于系统管理员是很重要的！尤其对于大型
工作站类型的 Unix-Like 主机，由于很多人都需要使用到他的运算功能，或者是他的编译程序( compiler )
来进行运算，这时的远程联机就更形重要啦！
那么是否每一部连上 Internet 上面的主机都应该要开放远程联机的功能呢？其实并不尽然， 还是需要针
对您的主机来进行规划的，我们底下分服务器与工作站来说明：
• 服务器类型( Server )的联机程序：
在一般开放因特网服务的服务器中，由于开放的服务可能会有较为重要的信息， 而远程联机程序连进主机
之后，可以进行的工作又太多了(几乎就像在主机前面工作一般！)， 因此因特网的远程联机程序通常仅针
对少部分系统维护者开放而已！ 除非必要，否则 Server 类型的主机还真的不建议开放联机的服务呢！ 以
鸟哥为例，我的主机提供了我们研究室使用 Mail 与 Internet 上面的 WWW 服务，如果还主动提供远程联
机的话， 那么万一不小心被入侵，那可就伤脑筋了！因此，鸟哥仅开放『很小部分的网域』让系统管理员
连进来， 其它来源的 IP 一律抵挡！不许使用远程联机的功能呢！
• 工作站类型( Workstation )的联机程序：
至于工作站的情况就跟服务器不太一样了！工作站常常仅针对内部的几个使用者开放而已， 通常是不希望
连上 Internet 的啦！而且所谓的工作站自然就是用来做工的！ 例如鸟哥的其中一部 Linux 就是专门用
来进行大型的数值模式计算仿真之用！ 这个时候的远程联机服务器可能就得要对多人启动了！ 因为工作
站的强大运算功能可以让很多人一同使用他的计算能力！而且也可以免除每部计算机都得要安装 compiler
的窘境！要知道，某些工程用的 compiler 是粉贵的～
有哪些可供登入的类型？
那么目前远程联机服务器的主要类型有哪些？如果以显示的类型来分类， 基本上有文字接口与图形接口两
种。
在文字类型登入方面的服务器，主要有以『明码』传送数据的 telnet 服务器，及以加密技术进行封包加
密来传送的 SSH 服务器！虽然 telnet 可以支持的 client 端软件比较多，不过由于他是使用明码来传送
数据， 您的数据很容易遭到有心人士的撷取！所以近来我们都呼吁大家多使用 SSH 这一种联机方式，而
舍弃掉 telnet 这个比较不安全的咚咚啰！
至于图形接口的服务器，比较简单的有 Xdmcp ，架设 Xdmcp 很简单， 不过 client 端的软件比较少。另
外一款目前很常见的服务器，就是 VNC (Virtual Network Computing)， 透过 VNC server/client 软件
来进行连接。图形接口最大的优点是『图形』啊！ 不过，因为是透过图形来传送，传输的数据量相当的大，
所以速度与安全性都有待考虑。 因此，我们仅建议您将图形接口的远程登入服务器开放在内部网域 (LAN)
就好了！
那么什么是『明码』与『加密』的数据封包传送模式呢？ 为什么 telnet 使用明码就比较不安全？所谓的
明码就是： 『当我们的数据封包在网络上流窜时，该数据封包的内容为数据的原始格式』， 还记得我们
在网络常用指令章节当中介绍的 tcpdump 吧？ 我们在 telnet 下达的指令与密码等等，都会以类似
ASCII 的格式传送到主机端， 而主机端就藉由这些数据来下达指令。如果这些数据封包在经过某些
broadcast 或者是 Router 时，被有心人士捉去，那么他将会完整的取得您的数据喔！ 所以啦，万一您的
数据封包里面含有信用卡数据、密码、身份确认等重要信息时，是否很危险吶？！ 因此，目前我们通常都
希望使用可以将这些在网络上面跑的数据加密的技术，以增加数据在 Internet 上面传送的安全性啊！

SSH 服务器
既然 telnet 的数据在 Internet 上不是很安全，那么我又需要以远程联机服务来操控我的 Linux 主机，
那么应该怎么办呀？最好的方法当然就是以较为安全的联机机制来解决联机的问题啰！ 那么该如何解决这
样的问题呢？这也不难啦，使用 SSH 即可。那么 SSH 是什么呢？他有什么特异功能？
简单的来说，SSH 是 Secure SHell protocol 的简写，他可以经由将联机的封包加密的技术， 来进行数
据的传递，因此，数据当然就比较安全啰！这个 SSH 可以用来取代 Internet 上面较不安全的 finger, R
Shell (rcp, rlogin, rsh 等指令), talk 及 telnet 等联机模式。底下我们将先简介一下 SSH 的联机模
式，来说明为什么 SSH 会比较安全呢！
特别注意：这个 SSH 协议，在预设的状态中，本身就提供两个服务器功能：
1. 一个就是类似 telnet 的远程联机使用 shell 的服务器，亦即是俗称的 ssh ；
2. 另一个就是类似 FTP 服务的 sftp-server ！提供更安全的 FTP 服务。
联机加密技术简介：
什么是『数据加密』呢？简单的说，就是将人们看的懂得电子数据，经过一些运算， 让这些数据变成没有
意义的(至少对人类来说)咚咚，然后这个咚咚可以在网络上面传输， 而当使用者想要查阅这个数据时，再
透过反向运算，将这些咚咚反推出原始的电子数据。 由于这些数据已经被重新处理过，所以，即使数据在
Internet 上被 cracker 监听而窃取，他们也不容易就推算得出来原始资料内容的。
网络封包的加密技术通常是藉由所谓的『一对公钥与私钥』 亦即『Public and Private 组合成的 key pair』
来进行加密与解密的动作！如下图所示。主机端所要传给 client 端的数据，会先经由公钥加密后才到网
络上传输。 而到达 client 端之后，再经由私钥将加密的数据解开来～由于在 Internet 上面跑的数据是
加密过后的， 所以你的数据内容当然就比较安全啦！
图一、公钥与私钥在进行数据传输时的角色示意图
Tips:
数据加密的技术真的相当的多，也各有其优缺点，有的运算速度快，
但是不够安全；有的够安全，但是加密/解密的速度较慢～ 目前在
SSH 使用上，主要是利用 RSA/DSA/Diffie-Hellman 等机制喔！
那么这些公钥与私钥是如何产生的呢？底下我们来谈一谈目前 SSH 的两种版本的联机模式啰！
• SSH protocol version 1：
每一部 SSH 服务器主机都可以使用 RSA 加密方式来产生一个 1024-bit 的 RSA Key ， 这个 RSA 的加密
方式，主要就是用来产生公钥与私钥的演算方法！这个 version 1 的整个联机的加密步骤可以简单的这么
看：
1. 当每次 SSH daemon (sshd) 启动时，就会产生一支 768-bit 的公钥(或称为 server key)存放在
Server 中；
2. 若有 client 端的 ssh 联机需求传送来时，那么 Server 就会将这一支公钥传给 client ，此时
client 也会比对一下这支公钥的正确性。比对的方法为利用 /etc/ssh/ssh_known_hosts 或
~/.ssh/known_hosts 档案内容。
3. 在 Client 接受这个 768-bit 的 server key 之后，Client 自己也会随机产生一支 256-bit 的
私钥(host key)，并且以加密的方式将 server key 与 host key 整合成一对完整的 Key pair，
并且将这对 Key pair 也传送给 server ；
4. 之后，Server 与 Client 在这次的联机当中，就以这一对 1024-bit 的 Key pair 来进行数据的
传递！
也就是说，Public Key 是放在 Server 上的，而 Client 端的软件必须要能接受 Public Key 以及计算出
Private Key 以组合成为一把独一无二的 key pair ，因为 Client 端每次的 256-bit 的 Key 是随机取
的，所以您这次的联机与下次的联机的 Key 可能就会不一样啦！此外在 Client 端的使用者家目录下的
~/.ssh/known_hosts 会记录曾经联机过的主机的 public key ，用以确认每次来自该主机的联机是正确
的。 这个 ~/.ssh/known_hosts 档案的意义后续还会介绍的。
• SSH protocol version 2：
在 SSH version1 的联机过程当中，当 server 端接受 client 端的 private key 后，就不再针对该次联
机的 key pair 进行检验。此时若有恶意的 cracker 针对该联机给予恶意的程序代码时，由于主机端不会
检验联机的正确性， 因此可能会接受该程序代码，进一步造成系统被黑掉的问题。
为了改正这个缺失，SSH version 2 多加了一个确认联机正确性的 Diffie-Hellman 机制， 在每次数据的
传输当中 server 端都会以该机制检查资料的来源是否正确， 所以可以避免联机过程当中被插入恶意程序
代码的问题！ 也就是说， ssh version 2 是比较安全的喔！
由于 SSH version 1 本身存在着的一些问题，因此，近来我们都希望大家使用 ssh version 2 的联机模
式， 会比较安全一点。而联机版本的设定则需要在 ssh 主机端与客户端均设定好才行喔！
启动 SSH 服务：
事实上，在我们使用的 Linux 系统当中，预设就已经含有 SSH 的所有需要的套件了！ 这包含了可以产生
密码等协议的 OpenSSL 套件与 OpenSSH 套件，所以呢，要启动 SSH 真的是太简单了！就直接给他启动就
是了！此外，在目前的 Linux Distributions 当中，都是预设启动 SSH 的， 所以一点都不麻烦，因为不
用去设定，他就已经启动了！哇！真是爽快～无论如何， 我们还是得说一说这个启动的方式吧！直接启动
就是以 SSH daemon ，简称为 sshd 来启动的，所以，手动可以这样启动：
[root@linux ~]# /etc/init.d/sshd restart
[root@linux ~]# netstat -tlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
tcp 0 0 *:ssh *:* LISTEN 24266/sshd
启动后，利用 netstat 查阅一下 sshd 这个程序是否正确的在 LISTEN 即可！当然，这个时候您的 SSH 服
务器设定值均是使用系统默认值， 能不能够仅用较安全的 version 2 ，则需要进一步的设定呢。 接下来，
如果您想要在开机就启动 SSH 的话(预设也是启动的！)，可以利用 chkconfig 来设定开机启动即可。
虽然新的 Linux distributions 都预设会有 SSH 存在的，但是较旧的版本就仅有 telnet 而已。 例如
Red Hat 6.x 之前的版本。那么如果您想要在旧的 distributions 当中安装 SSH 该如何是好？ 嘿嘿！可
以参考一下鸟哥之前写过的一篇咚咚，有详细的说明 tarball 的安装流程哩！
使用 Tarbal 安装 SSH 以及升级 SSH 可能会遇到的问题说明
(http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh-2.php)
需要注意的是， SSH 不但提供了 shell 给我们使用，亦即是 ssh protocol 的主要目的，同时亦提供了
一个较为安全的 FTP server ，亦即是 ssh-ftp server 给我们当成是 FTP 来使用！所以，这个 sshd 可
以同时提供 shell 与 ftp 喔！而且都是架构在 port 22 上面的呢！所以，底下我们就来提一提，那么怎
么样由 Client 端连接上 Server 端呢？同时，如何以 FTP 的服务来连接上 Server 并且使用 FTP 的功
能呢？
ssh 客户端联机：
由于 Linux 与 Windows 这两个客户端 Client 联机软件/指令并不一样，所以我们分别来介绍可以使用的
指令：
• Linux Client: ssh
SSH 在 client 端使用的是 ssh 这个指令，这个指令可以指定联机的版本 (version1, version2)， 还可
以指定非正规的 ssh port (正规 ssh port 为 22)。不过，一般的用法可以使用底下的方式：
1. 直接登入到对方主机的方法：
[root@linux ~]# ssh account@hostname
# 连接到我们自己本机上面的 ssh 服务！更多讯息，请 man ssh 喔！
[root@linux ~]# ssh dmtsai@localhost
The authenticity of host 'localhost (127.0.0.1)' can't be established.
RSA key fingerprint is f8:ae:67:0e:f0:e0:3e:bb:d9:88:1e:c9:2e:62:22:72.
Are you sure you want to continue connecting (yes/no)? yes
# 上面很重要喔！务必填入完整的 "yes" 而不是 Y 或 y 而已。
Warning: Permanently added 'localhost' (RSA) to the list of known hosts.
dmtsai@localhost's password: <== 在这里填入密码，同样的，屏幕不会有讯息的！
Last login: Fri Jul 1 14:23:27 2005 from localhost.localdomain
[dmtsai@linux ~]$ <== 瞧！已经登入啰～
[dmtsai@linux ~]$ exit <== 输入 exit 就能够离开对方主机啰！
2. 不登入对方主机，直接在对方主机执行指令的方法：
[root@linux ~]# ssh dmtsai@localhost date
dmtsai@localhost's password:
Tue Nov 22 11:57:27 CST 2005
[root@linux ~]#
# 看！身份还是 root 喔！只是以 dmtsai 的身份在远程主机上执行了一个指令而已！
这里请特别留意的是，如果直接以『 ssh hostname 』这个指令来连接进入 hostname 这个主机时，则进
入 hostname 这个主机的『账号名称』将会是目前您所在的这个环境当中的使用者账号！ 以上面为例，因
为我是以 root 的身份在执行，所以如果我执行了『 ssh host.domain.name 』时， 那么对方
host.domain.name 这部主机，就会以 root 的身份来让我进行密码确认的登入动作！
因此，为了避免这样的麻烦，通常鸟哥都是以简单的 e-mail 的写法来登入远方的主机， 例如『ssh
user@hostname 』即表示， 鸟哥是以 user 这个账号去登入 hostname 这部主机的意思。当然，也可以使
用 -l username 这样的形式来书写！登入对方主机之后，其它的所有执行行为都跟在 Linux 主机内没有
两样～所以，真的是很简单吧！ ^_^ 这样就可以达到远程控管主机的目的了！
此外，在预设的情况下， SSH 是『允许您以 root 的身份登入』喔 ！呵呵！更是爽快啦！要特别留意的
是，当您要连接到对方的主机时，如果是首次连接，那么 Server 会问您，您的联机的 Key 尚未被建立，
要不要接受 Server 传来的 Key ，并建立起联机呢？呵呵！这个时候请『务必要输入 yes 而不是 y 或 Y』，
这样程序才会接受喔！
• 关于 Server Keys 的纪录数据： ~/.ssh/known_hosts
如果您刚刚有研究过 SSH 的联机流程的话，会发现到当 client 端接受来自 server 端的 public key 之
后，会主动的比对这支 Key 的正确性。而比对的档案是 ~/.ssh/known_hosts 。 若是接受到的这支 public
key 并没有被纪录在这档案内，那么上面表格的讯息， 就是要您回答 yes/no 的那个讯息才会出现～而您
回答 yes 之后，该 public key 信息就会被记录起来，以留待下次登入同一部主机时的检查之用啊！ 如
果 Server Key 与 ~/.ssh/known_hosts 比对成功， 那么您就会直接进入等待密码输入的画面， 那就不
必每次都得要输入 (yes/no) 啰～
不过，您或许也会发现一件事情啊，我们知道 SSH server 虽然使用 version 2 已经不会重复制造 server
key (public key) 了，但是如果该主机重新安装过新的 linux distributions 时， 那把 server key 就
会被改变啊！而 client 又会去比对这个 public key 与 ~/.ssh/known_hosts ， 此时 Client 就会发现
两者不同了，于是乎产生如下的错误讯息了：
[root@linux ~]# ssh dmtsai@localhost
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
f8:ae:67:0e:f0:a0:3e:aa:d9:77:19:c9:2e:62:22:72.
Please contact your system administrator.
Add correct host key in /root/.ssh/known_hosts to get rid of this message.
Offending key in /root/.ssh/known_hosts:1
RSA host key for localhost has changed and you have requested strict checking.
Host key verification failed.
这个错误讯息在告诉您，上次所登录的远程 SSH 主机的 Keys 已经被改过了(最可能的原因就是 Server
端重新开机/重新安装/更新套件等等啦！)， 所以无法继续登入～呵呵！这个时候怎么办？很简单啊！进
入您的家目录的 ~/.ssh 里面，编辑一下 known_hosts ，将欲连接的主机名称的 Key 给他消除，就可以
重新联机啦！
[root@linux ~]# vi ~/.ssh/known_hosts
localhost ssh-rsa AAAAB3NzaC1yc2Euowireffodjoiwjefmoeiwhoqhwupoi
t[egmlomowimvoiweo6VpTHTw2/tENp4U7Wn8J6nxYWP36YziFgxtWu4MPSKaRmr
E4eUpR1G/zV3TkChRZY5hGUybAreupTVdxCZvJlYvNiejfijoejwiojfijeoiwx5
eRkzvSj7a19vELZ5f8XhzH62E=
上面表格的内容其实是同一行的～那一行代表『 localhost 这部主机，利用的是 ssh-rsa 联机机制， 而
后续的数据则是那把 Server Key 的内容。』如果您确定这次的比对无法成功是正常的， 那么您可以将这
一行给他删除，这样下次要再登入时，就又会再次的出现问 (yes/no) 的画面啊！
• Linux Client: sftp
那么如何使用 SSH FTP 的功能呢？也是很容易啦！就是使用 sftp 这支程序即可！而登入的方式与 ssh 相
同，都是使用 sftp -l username hostname 或者直接以 sftp user@hosname 来书写！执行之后会有底下
的模样：
[root@linux ~]# sftp dmtsai@localhost
Connecting to localhost...
dmtsai@localhost's password: <== 这里请输入密码啊！
sftp> <== 这里就是在等待您输入 ftp 相关指令的地方了！
进入到 sftp 之后，那就跟在一般 FTP 模式下的操作方法没有两样了！底下我们就来谈一谈， sftp 这个
接口下的使用指令吧！
针对远方主机(Server)之行为
变换目录到 /etc/test 或其它目录 cd /etc/test
cd PATH
列出目前所在目录下的文件名 ls
dir
建立目录 mkdir directory
删除目录 rmdir directory
显示目前所在的目录 pwd
更改档案或目录群组 chgrp groupname PATH
更改档案或目录拥有者 chown username PATH
更改档案或目录的权限 chmod 644 PATH
其中， 644 与权限有关！回去看基础篇！
建立连结档 ln oldname newname
删除档案或目录 rm PATH
更改档案或目录名称 rename oldname newname
离开远程主机 exit (or) bye (or) quit
针对本机(Client)之行为(都加上 l, L 的小写 )
变换目录到本机的 PATH 当中 lcd PATH
列出目前本机所在目录下的文件名 lls
在本机建立目录 lmkdir
显示目前所在的本机目录 lpwd
针对资料上传/下载的行为
将档案由本机上传到远程主机
put [ 本机目录或档案] [ 远程]
put [ 本机目录或档案]
如果是这种格式，则档案会放置到目前远程主机的目录
下！
将档案由远程主机下载回来
get [ 远程主机目录或档案] [ 本机]
get [ 远程主机目录或档案]
若是这种格式，则档案会放置在目前本机所在的目录当
中！可以使用万用字符，例如：
get *
get *.rpm
亦是可以的格式！
就整体而言， sftp 在 Linux 底下，如果不考虑图形接口，那么他已经可以取代 FTP 了呢！因为所有的
功能都已经涵盖啦！因此，在不考虑到图形接口的 FTP 软件时，可以直接关掉 FTP 的服务，而改以
sftp-server 来提供 FTP 的服务吧！ ^_^
• Linux Client: scp
如果我要在两个主机之间复制档案的话，除了 sftp 之外，还有没有更简单的方式？ 有的，那就是利用 scp
这个指令啦！这个指令的用法与 cp 很相像，不过， 在远程主机的目录写法，比较需要注意就是了。举例
如下：
1. 将数据由本机上传到远程主机上去
[root@linux ~]# scp /etc/crontab dmtsai@localhost:/home/dmtsai/
dmtsai@localhost's password: <== 这里请输入密码啊！
crontab 100% 620 0.6KB/s 00:00
# 这个例子在说明，我将本机目录的 /etc/crontab 这个档案传送给 dmtsai
# 这个使用者，而这个使用者是在 "localhost" 那部主机上面喔！
# 仔细看一下，会有一个传输数据的讯息跑出来喔！
2. 将数据由远程主机下载到本机上！
[root@linux ~]# scp dmtsai@localhost:~/.bashrc .
# 这个例子则是在说明，我要将 localhost 那部机器上的 dmtsai 这个人，
# 他家目录下的 .bashrc 复制到我的机器上！
也就是说，远程主机上的档案或目录要复制时，是以『 hostname:PATH 』 方式来书写的～不要写错了呦！
而如果想要复制目录的话，那么可以加上 -r 的参数！
• Windows Client: putty
在 Linux 底下想要连接 SSH 服务器，可以直接利用 ssh 这个指令 ，那么如果在 Windows 操作系统底下，
又该如何连接到 SSH 服务器呢？可以直接使用 putty 或 pietty 这种类型的联机软件呢，他也是免费的
自由软件喔！取得的方式可以参考底下的网站：
• putty 官方网站： http://www.chiark.greenend.org.uk/~sgtatham/putty/
• pietty 官方网站： http://www.csie.ntu.edu.tw/~piaip/pietty/
在 putty 的官方网站上有很多的 client 软件可以使用的，包括 putty/pscp/psftp 等等。 他们分别对
应了 ssh/scp/sftp 这三个指令就是了。而上述的三个 putty/pscp/psftp 主要是在 Windows 上面连接到
Unix like 机器的 SSH 服务器的 Client 软件呢。请自行下载该软件喔。
事实上，鸟哥比较喜欢林弘德先生的 pietty，因为这个软件不但是完整支持 putty ，而且提供的文字编
码较丰富， 实在很好用。在你下载了 pietty 后直接双击他， 会有类似底下的图示出现。

很像在主机前面工作吧！而且上头还有选单可以随时调整类似字形、字体、字符编码等等。 尤其是字符编
码。有时候你会发现开启档案时，竟然画面当中会有乱码而不是正常的中文显示， 那就是编码的问题。要
解决这个问题时，你必须要牢记：
• 文本文件本身在存档时所挑选的语系；
• Linux 主机本身所使用的语系 (可用 LANG 变量调整)；
• pietty 所使用的语系。
这三个咚咚的语系要完全相同时才会正确的显示出中文！千要要牢记啊！ 那如何调整 pietty 的中文编码
呢？

详细设定 sshd 服务器
基本上，所有的 ssh 相关设定都放在 /etc/ssh/sshd_config 里面！不过，每个 Linux distribution 的
预设设定都不太相同， 所以我们有必要来了解一下整个设定值的意义为何才好！
[root@linux ~]# vi /etc/ssh/sshd_config
# 1. 关于 SSH Server 的整体设定，包含使用的 port 啦，以及使用的密码演算方式
# 先留意一下，在预设的档案内，只要是被批注的设定值(#)，即为『默认值！』
Port 22
# SSH 预设使用 22 这个 port，也可以使用多个 port，即重复使用 port 这个设定项目！
# 例如想要开放 sshd 在 22 与 443 ，则多加一行内容为：
# Port 443
# 这样就好了！不过，不建议修改 port number 啦！
Protocol 1,2
# 选择的 SSH 协议版本，可以是 1 也可以是 2 ，
# 如果要同时支持两者，就必须要使用 2,1 这个分隔了(Protocol 1,2)！
# 目前我们会建议您，直接使用 Protocol 2 即可！
#ListenAddress 0.0.0.0
# 监听的主机适配卡！举个例子来说，如果您有两个 IP，
# 分别是 192.168.0.100 及 192.168.2.20 ，那么只想要
# 开放 192.168.0.100 时，就可以写如同下面的样式：
ListenAddress 192.168.0.100
# 只监听来自 192.168.0.100 这个 IP 的 SSH 联机。
# 如果不使用设定的话，则预设所有接口均接受 SSH
#PidFile /var/run/sshd.pid
# 可以放置 SSHD 这个 PID 的档案！左列为默认值
#LoginGraceTime 2m
# 当使用者连上 SSH server 之后，会出现输入密码的画面，在该画面中，
# 在多久时间内没有成功连上 SSH server ，就断线！若无单位则预设时间为秒！
#Compression yes
# 是否可以使用压缩指令？当然可以啰
# 2. 说明主机的 Private Key 放置的档案，预设使用下面的档案即可！
#HostKey /etc/ssh/ssh_host_key # SSH version 1 使用的私钥
#HostKey /etc/ssh/ssh_host_rsa_key # SSH version 2 使用的 RSA 私钥
#HostKey /etc/ssh/ssh_host_dsa_key # SSH version 2 使用的 DSA 私钥
# 还记得我们在主机的 SSH 联机流程里面谈到的，这里就是 Host Key ～
# 2.1 关于 version 1 的一些设定！
#KeyRegenerationInterval 1h
# 由前面联机的说明可以知道， version 1 会使用 server 的 Public Key ，
# 那么如果这个 Public Key 被偷的话，岂不完蛋？所以需要每隔一段时间
# 来重新建立一次！这里的时间为秒！不过我们通常都仅使用 version 2 ，
# 所以这个设定可以被忽略喔！
#ServerKeyBits 768
# 没错！这个就是 Server key 的长度！用默认值即可。
# 3. 关于登录文件的讯息数据放置与 daemon 的名称！
SyslogFacility AUTHPRIV
# 当有人使用 SSH 登入系统的时候，SSH 会记录信息，这个信息要记录在什么 daemon name
# 底下？预设是以 AUTH 来设定的，即是 /var/log/secure 里面！什么？忘记了！
# 回到 Linux 基础 去翻一下。其它可用的 daemon name 为：DAEMON,USER,AUTH,
# LOCAL0,LOCAL1,LOCAL2,LOCAL3,LOCAL4,LOCAL5,
#LogLevel INFO
# 登录记录的等级！嘿嘿！任何讯息！同样的，忘记了就回去参考！
# 4. 安全设定项目！极重要！
# 4.1 登入设定部分
PermitRootLogin no
# 是否允许 root 登入！预设是允许的，但是建议设定成 no！
#UserLogin no
# 在 SSH 底下本来就不接受 login 这个程序的登入！
#StrictModes yes
# 当使用者的 host key 改变之后，Server 就不接受联机，可以抵挡部分的木马程序！
#RSAAuthentication yes # 是否使用纯的 RSA 认证！？仅针对 version 1 ！
#PubkeyAuthentication yes # 是否允许 Public Key ？当然允许啦！仅针对 version 2
#AuthorizedKeysFile .ssh/authorized_keys
# 上面这个在设定若要使用不需要密码登入的账号时，那么那个账号的存放档案所在档名！
# 这个设定值很重要喔！档名给他记一下！
# 4.2 认证部分
#RhostsAuthentication no
# 本机系统不使用 .rhosts，因为仅使用 .rhosts 太不安全了，所以这里一定要设定为 no
#IgnoreRhosts yes
# 是否取消使用 ~/.ssh/.rhosts 来做为认证！当然是！
#RhostsRSAAuthentication no #
# 这个选项是专门给 version 1 用的，使用 rhosts 档案在 /etc/hosts.equiv
# 配合 RSA 演算方式来进行认证！不要使用啊！
#HostbasedAuthentication no
# 这个项目与上面的项目类似，不过是给 version 2 使用的！
#IgnoreUserKnownHosts no
# 是否忽略家目录内的 ~/.ssh/known_hosts 这个档案所记录的主机内容？
# 当然不要忽略，所以这里就是 no 啦！
PasswordAuthentication yes
# 密码验证当然是需要的！所以这里写 yes 啰！
#PermitEmptyPasswords no
# 若上面那一项如果设定为 yes 的话，这一项就最好设定为 no ，
# 这个项目在是否允许以空的密码登入！当然不许！
ChallengeResponseAuthentication no
# 允许任何的密码认证！所以，任何 login.conf 规定的认证方式，均可适用！
# 但目前我们比较喜欢使用 PAM 模块帮忙管理认证，因此这个选项可以设定为 no 喔！
UsePAM yes
# 利用 PAM 管理使用者认证有很多好处，可以记录与管理。
# 所以这里我们建议您使用 UsePAM 且 ChallengeResponseAuthentication 设定为 no
# 4.3 与 Kerberos 有关的参数设定！因为我们没有 Kerberos 主机，所以底下不用设定！
#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosTgtPassing no
# 4.4 底下是有关在 X-Window 底下使用的相关设定！
X11Forwarding yes
#X11DisplayOffset 10
#X11UseLocalhost yes
# 4.5 登入后的项目：
PrintMotd no
# 登入后是否显示出一些信息呢？例如上次登入的时间、地点等等，预设是 yes
# 亦即是打印出 /etc/motd 这个档案的内容。但是，如果为了安全，可以考虑改为 no ！
PrintLastLog yes
# 显示上次登入的信息！可以啊！预设也是 yes ！
KeepAlive yes
# 一般而言，如果设定这项目的话，那么 SSH Server 会传送 KeepAlive 的讯息给
# Client 端，以确保两者的联机正常！在这个情况下，任何一端死掉后，SSH 可以立刻知道！
# 而不会有僵尸程序的发生！
UsePrivilegeSeparation yes
# 使用者的权限设定项目！就设定为 yes 吧！
MaxStartups 10
# 同时允许几个尚未登入的联机画面？当我们连上 SSH ，但是尚未输入密码时，
# 这个时候就是我们所谓的联机画面啦！在这个联机画面中，为了保护主机，
# 所以需要设定最大值，预设最多十个联机画面，而已经建立联机的不计算在这十个当中
# 4.6 关于使用者抵挡的设定项目：
DenyUsers *
# 设定受抵挡的使用者名称，如果是全部的使用者，那就是全部挡吧！
# 若是部分使用者，可以将该账号填入！例如下列！
DenyUsers test
DenyGroups test
# 与 DenyUsers 相同！仅抵挡几个群组而已！
# 5. 关于 SFTP 服务的设定项目！
Subsystem sftp /usr/lib/ssh/sftp-server
基本上，CentOS 预设的 sshd 服务已经算是挺安全的了，不过还不够！ 建议你 (1)将 root 的登入权限
取消； (2)将 ssh 版本设定为 2 。 其它的设定值就请您依照自己的喜好来设定了。通常不建议进行随便
修改啦！ 另外，如果您修改过上面这个档案(/etc/ssh/sshd_config)，那么就必需要重新启动一次 sshd 这
个 daemon 才行！亦即是：
• /etc/init.d/sshd restart
制作不用密码可立即登入的 ssh 用户：
咦！既然 SSH 可以使用 Key 来比对数据，并且提供使用者数据的加密功能， 那么可不可能利用这个 Key
就提供使用者自己进入主机，而不需要输入密码呢？ 呵呵！好主意！我们可以将 Client 产生的 Key 给
他拷贝到 Server 当中，所以， 以后 Client 登入 Server 时，由于两者在 SSH 要联机的讯号传递中，
就已经比对过 Key 了， 因此，可以立即进入数据传输接口中，而不需要再输入密码呢！在实作上的步骤
可以是：
1. 首先，先在 Client 上面建立 Public Key 跟 Private Key 这两把钥匙，利用的指令为
ssh-keygen 这个命令；
2. 再来，将 Private Key 放在 Client 上面的家目录，亦即 $HOME/.ssh/ ， 并且修改权限为仅有
该 User 可读的状态；
3. 最后，将那把 Public Key 放在任何一个您想要用来登入的主机的 Server 端的某 User 的家目
录内之 .ssh/ 里面的认证档案即可完成整个程序。
说是好像很困难的样子，其实步骤真的很简单，我们依序来进行作业好了！假设前提：
• Server 部分为 linux.dmtsai.tw 这部 192.168.0.2 的主机，欲使用的 User 为 test 这个账
号；
• Client 部分为 test2.dmtsai.tw 这部 192.168.0.100 PC 的 test2 这个账号， 他要用来登入
192.168.0.2 这部主机的 test 这个账号。
1. 在 Client 端建立 Public 与 Private Key ：
建立的方法真的是简单到不行！直接在 192.168.0.100 这个 Client 上面，以 test2 这个账号，
使用 ssh-keygen 这个指令来进行 Key 的产生即可！不过，需要注意的是， version 1 与
version 2 使用的密码演算方式不同，此外， version 2 提供两个密码演算的方法，我们这里仅
针对 version 2 的 RSA 这个演算方法进行说明！
[test2@test2 ~]$ ssh-keygen -t rsa <==这个步骤在产生 Key pair
Generating public/private rsa key pair.
Enter file in which to save the key (/home/test2/.ssh/id_rsa): <==这里按下 Enter
Enter passphrase (empty for no passphrase): <==这里按 Enter
Enter same passphrase again: <==再按一次 Enter
Your identification has been saved in /home/test2/.ssh/id_rsa. <==这是私钥
Your public key has been saved in /home/test2/.ssh/id_rsa.pub. <==这是公钥
The key fingerprint is:
c4:ae:d9:02:d1:ba:06:5d:07:e6:92:e6:6a:c8:14:ba test2@test2.linux.org
# 注意： -t 指的是『使用何种密码演算方式？』由于我们使用 RSA ，
# 所以直接输入 -t rsa 即可建立两支 Keys ！
# 此外，建立的两把 Keys 都放置在家目录下的 .ssh 这个目录中！
# 察看一下这两把 Keys 吧！
[test2@test2 ~]$ ll ~/.ssh
total 12
-rw------- 1 test2 test2 887 Nov 12 22:36 id_rsa
-rw-r--r-- 1 test2 test2 233 Nov 12 22:36 id_rsa. pub
-rw-r--r-- 1 test2 test2 222 Oct 31 11:20 known_hosts
请注意上面喔，我的身份是 test2 ，所以当我执行 ssh-keygen 时， 才会在我的家目录底下
的 .ssh/ 这个目录里面产生所需要的两把 Keys ，分别是私钥(id_rsa)与公钥(id_rsa.pub)。另
外一个要特别注意的就是那个 id_rsa 的档案权限啦！他必须要是 -rw------- 才好！否则内容
被人家知道了，那么您的 Keys 不就有可能外泄了？所以请特别留意他的权限喔！ 那么那个
id_rsa.pub 则是『公钥！』这个档案必须要被放置到 Server 端才行！
2. 在 Client 端放置私钥：
在预设的条件中，我们的私钥必需要放置在家目录底下的 .ssh 里面，那么如果是 version 2 的
RSA 算法，就需要放置在 $HOME/.ssh/id_rsa 当中！咦！刚好使用 ssh-keygen 就是已经产生在
这个目录下了，所以自然就不需要去调整他了！以我的 test2.dmtsai.tw 来看，那么我的档案就
会放置在 /home/test2/.ssh/id_rsa 这个档案就是私钥啦！
3. 在 Server 端放置可以登入的公钥：
既然我们要让 test2 可以用 test 这个账号登入 linux.dmtsai.tw 这部主机，那么这部主机自
然需要保有 test2 的 public key 啰！对的！所以我们必需要将 Client 端建立的 id_rsa.pub
档案给他拷贝到 linux.dmtsai.tw 里头的 test 这个使用者的家目录之下！那么如果您还记得上
面的 sshd_config 这个档案的设定的话，那么应该就记得『 AuthorizedKeysFile 』这个设定吧！
是的！ 在被登入的主机的某个账号，他的公钥放置的文件名称预设就是这个项目所记载的！而他
预设的档名就是 authorized_keys 这个文件名称啦！那么应该怎么做呢？
1. 先在 Client 端以 sftp 将公钥丢到 test 上面去！
[test2@test2 ~]$ cd ~/.ssh
[test2@test2 .ssh]$ scp id_rsa.pub test@192.168.0.2:~/
test@192.168.0.2's password:
id_rsa.pub 100% 233 0.2KB/s 00:00
2. 到 Server 上面，将公钥转存到 authorized_keys 档案中！
[test@linux ~]$ cd ~/.ssh
[test@linux .ssh]$ cat ../id_rsa.pub >> authorized_keys
请注意上面的机器！由于 authorized_keys 可以保存相当多的公钥内容，因此， 可以使用 >> 的
方式来将 Client 端的公钥新增到该档案内！呵呵！做完这一步一后，未来 test2 就可以直接在
test2.dmtsai.tw 以
[test2@test2 ~]$ ssh test@linux.dmtsai.tw
这样就可以不需要输入密码啰！但是请注意， test 不能以 test2 登入 test2.linux.org 喔！
很简单的步骤吧！这样一来，就可以不需密码的手续了！无论如何，您要记得的是：
• Client 必须制作出 Public & Private 这两把 keys，且 Private 需放到 ~/.ssh/ 内； 
• Server 必须要有 Public Key ，且放置到使用者家目录下的 ~/.ssh/authorized_keys；
未来，当您还想要登入其它的主机时，只要将您的 public key (就是 id_rsa.pub 这个档案) 给他 copy 到
其它主机上面去，并且新增到某账号的 ~/.ssh/authorized_keys 这个档案中！哈哈！成功！
安全设定：
老实说，大家都被『SSH 是个安全的服务』所欺骗了！其实 sshd 并不怎么安全的！翻开 openssh 的过去
历史来看，确实有很多人是利用 ssh 的程序漏洞来取得远程主机 root 的权限，进一步黑掉对方的主机！
sshd 之所谓的『安全』其实指的是『 sshd 的数据是加密过的，所以他的数据在 Internet 上面传递时是
比较安全的。 至于 sshd 这个服务本身就不是那样安全了！所以说：『非必要，不要将 sshd 对 Internet
开放可登入的权限，尽量局限在几个小范围内的 IP 或主机名称即可！ 这很重要的喔！
好了，那么关于安全的设定方面，有没有什么值得注意的呢？当然是有啦！ 我们可以先建议几个项目吧！
分别可以由：
• /etc/ssh/sshd_config
• /etc/hosts.allow, /etc/hosts.deny
• iptables
这三方面来着手进行！底下我们就说一说吧！
• /etc/ssh/sshd_config
一般而言，这个档案的预设项目就已经很完备了！所以，事实上是不太需要更动他的！ 但是，如果您有些
使用者方面的顾虑，那么可以这样修正一些问题呢！
• 禁止 root 的登入：
任何时候，不许 root 以远程联机的方式登入，都会是一个好主意！所以这里蛮建议大家直接将
root 的登入权限拿掉吧！所以，可以修改 /etc/ssh/sshd_config 这个档案的内容为：
[root@linux ~]# vi /etc/ssh/sshd_config
PermitRootLogin no <== 将他改成 no 吧！
[root@linux ~]# /etc/init.d/sshd restart
如此一来，以后 root 就不能以 ssh 登入啰！这样还是比较好的啦！ ^_^
• 不许某个群组登入：
有些特殊情况中，我们想要让使用者只能使用 sendmail, pop3, ftp 等，但是不希望他可以远程
联机进来，那么您可以这样做：
1. 将这些使用者都归纳在某一个特殊群组之下，例如 nossh 这个群组好了；
2. 在 /etc/ssh/sshd_config 当中加入这一行：『 DenyGroups nossh 』
3. 重新启动 sshd ： /etc/init.d/sshd restart
这样就 OK 啦！
• 不许某个使用者登入：
跟 DenyGroups 类似，使用 DenyUsers 即可！参考 sshd_config 的设定喔！
• /etc/hosts.allow 及 /etc/hosts.deny
简单的方法就是：
[root@linux ~]# vi /etc/hosts.allow
sshd: 192.168.0.1, 192.168.0.2, 192.168.0.3, 192.168.0.4, 192.168.0.5: allow
[root@linux ~]# vi /etc/hosts.deny
sshd : ALL : spawn (/bin/echo Security notice from host `/bin/hostname`; \
/bin/echo; /usr/sbin/safe_finger @%h ) | \
/bin/mail -s "%d -%h security" root@localhost & \
: twist ( /bin/echo -e "\n\nWARNING connectin not allowed.". )
• iptables
多几层保护也很好的！所以也可以使用 iptables 喔！参考： 简易防火墙架设 一文啰！
最后，『鸟哥呼吁大家，不要开放 SSH 的登入权限给所有 Internet 上面的主机～』 这很重要喔～因为
如果对方可以 ssh 进入您的主机，那么......太危险了～

RSH Client
这个 RSH client 的指令 rsh 预设是不给 root 执行的！所以不要使用 root 来测试！ 另外， RSH Client
最好与 RSH server 具有相同的账号来执行 rsh 比较不会有问题喔！
• 测试 RSH ：
接下来，当然要进行测试啰～请到 rsh.client 那部机器上面，使用 rsh 这个指令来下达指令吧！
[dmtsai@rshclient ~]$ rsh [-l 远程账号] [远程主机名] [远程主机指令]
参数：
-l ：一般来说， server 与 client 『要有相同的使用者账号名称』比较好的！
 如果没有的话，那么您必须要指定 server 的使用者账号名才行！
远程主机名 ：您要登入的那部 rsh.server 主机名称，记得与 /etc/hosts 相应！
远程主机指令：您要在远程机器上面下达什么指令？
范例一：在 rsh.server 上面下达 ls -l / 这个指令：
[dmtsai@rshclient ~]$ rsh rsh.server 'ls -l /'
.....输出省略.....
# 注意喔，我是使用 dmtsai 这个一般身份使用者，而且 rshserver rshclient
# 两部主机上面都有一个名为 dmtsai 的使用者账号才行喔！至于那个 ls -l /
# 则是在 rsh.server 主机上面的指令！留意留意！
一般来说，由于 RSH server/client 最好是要有相同的账号，如此一来才能够避免很多不必要的权限问题
( permission denied. )。所以说，通常 RSH 可能会搭配后续会继续谈到的 NIS/NFS 等服务器才是！ 这
样瞭呼？
另外， rsh 后续的指令通常仅适合单一指令而已，所以如果你的指令串很长 (接了很多参数)， 那最好将
那一整串指令用单引号括起来，可以避免指令下达错误的问题喔！ ^_^
• 利用 rcp 复制：
除了 rsh 可以在远程直接操控系统外，我们可以透过 rcp 来进行复制喔！其实这个 rcp 与 scp 几乎一
模一样啦！ 而且 rcp 的参数几乎与 cp 一模一样哩！另外， rcp 也是透过 RSH 这个 514 的 port 来进
行数据的传输的。 简单的说明如下：
范例：先查阅远程主机有什么数据，然后将他复制过来：
[dmtsai@rshclient ~]# rsh rsh.server 'ls -l ~'
drwx------ 3 dmtsai dmtsai 4096 Dec 27 2005 Desktop
-rw-r--r-- 1 dmtsai dmtsai 3385 May 29 17:52 bashrc
drwx------ 3 dmtsai dmtsai 4096 Mar 6 2006 mail
-rw-r--r-- 1 dmtsai dmtsai 883888 May 29 17:51 netcdf.tar.gz
drwxr-xr-x 2 dmtsai dmtsai 4096 Jul 26 16:05 test
-rw-rw-r-- 1 dmtsai dmtsai 34816 Mar 19 2006 testing.ppt
[dmtsai@rshclient ~]# rcp -r dmtsai@rsh.server:~/mail .
# 加上 -r 是为了要复制目录喔！否则的话，可以直接复制即可！
再说一次，其实这个 RSH 目前仅有在某些特殊的场合才会用到了！ 例如未来流行的新信息『 Cluster 』！
不过如果要玩 Cluster 的话， 得要加入 NIS/NFS 等服务器哩！那就等您好好发展啦！ ^_^
以 rsync 进行同步镜相备份
我们曾在基础篇里面谈过 Linux 的备份策略， 该篇曾介绍常用的备份指令，包括 tar, dd, cp 等等，不
过当时并未介绍网络，所以有个很棒的网络工具没有介绍， 那就是这个地方要谈到的 rsync 啦！这个
rsync 可以作为一个相当棒的异地备援系统的备份指令喔！ 因为 rsync 可以达到类似『镜相 (mirror) 』
的功能呢！
rsync 最早是想要取代 rcp 这个指令的，因为 rsync 不但传输的速度快，而且他在传输时， 可以比对本
地端与远程主机欲复制的档案内容，而仅复制两端有差异的档案而已，所以传输的时间就相对的降低很多！
此外， rsync 的传输方式至少可以透过三种方式来运作：
• 在本机上直接运作，用法就与 cp 几乎一模一样，例如：
rsync -av /etc /tmp (将 /etc/ 的资料备份到 /tmp/etc 内)
• 透过 rsh 或 ssh 的信道在 server / client 之间进行数据传输，例如：
rsync -av -e ssh user@rsh.server:/etc /tmp (将 rsh.server 的 /etc 备份到本地主机的 /tmp
内)
• 直接透过 rsync 提供的服务 (daemon) 来传输，此时 rsync 主机需要启动 873 port：
1. 你必须要在 server 端启动 rsync ， 看 /etc/xinetd.d/rsync 即可；
2. 你必须编辑 /etc/rsyncd.conf 设定档；
3. 你必须设定好 client 端联机的密码数据；
4. 在 client 端可以利用：rsync -av user@hostname::/dir/path /local/path
其实三种传输模式差异在于有没有冒号 (:) 而已，本地端传输不需要冒号，透过 ssh 或 rsh 时，就得要
利用一个冒号 (:)， 如果是透过 rsync daemon 的话，就得要两个冒号 (::) ，应该不难理解啦！因为本
地端处理很简单， 而我们的系统本来就有提供 ssh 的服务，所以，底下鸟哥将直接介绍利用 rsync 透过
ssh 来备份的动作喔。 不过，在此之前咱们先来看看 rsync 的语法吧！
[root@linux ~]# rsync [-avrlptgoD] [-e ssh] [user@host:/dir] [/local/path]
参数：
-v ：观察模式，可以列出更多的信息；
-q ：与 -v 相反，安静模式，输出的信息比较少；
-r ：递归复制！可以针对『目录』来处理！很重要！
-u ：仅更新 (update)，不会覆盖目标的新档案；
-l ：复制连结文件的属性，而非连结的目标源文件内容；
-p ：复制时，连同属性 (permission) 也保存不变！
-g ：保存源文件的拥有群组；
-o ：保存源文件的拥有人；
-D ：保存源文件的装置属性 (device)
-t ：保存源文件的时间参数；
-I ：忽略更新时间 (mtime) 的属性，档案比对上会比较快速；
-z ：加上压缩的参数！
-e ：使用的信道协议，例如使用 ssh 通道，则 -e ssh
-a ：相当于 -rlptgoD ，所以这个 -a 是最常用的参数了！
更多说明请参考 man rsync 的解说！
范例一：将 /etc 的资料备份到 /tmp 底下：
[root@linux ~]# rsync -av /etc /tmp
....前面输出省略....
sent 23007335 bytes received 32280 bytes 5119914.44 bytes/sec
total size is 22870014 speedup is 0.99
# 第一次运作时会花比较久的时间，因为首次建立嘛！如果再次备份呢？
[root@linux ~]# rsync -av /etc /tmp
building file list ... done
sent 77105 bytes received 20 bytes 154250.00 bytes/sec
total size is 22870014 speedup is 296.53
# 瞧！立刻就跑完了！传输的数据也很少！因为再次比对，仅有差异的档案会被复制。
范例二：利用 dmtsai 的身份，将 rsh.server 使用者家目录复制到 /tmp
[root@linux ~]# rsync -av -e ssh dmtsai@rsh.server:~ /tmp
The authenticity of host 'rsh.server (192.168.1.2)' can't be established.
RSA key fingerprint is 29:b8:a9:32:ea:d8:ff:97:6c:42:3b:aa:11:ab:55:dd.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'rsh.server' (RSA) to the list of known hosts.
dmtsai@rsh.server's password:
receiving file list ... done
....档案输出省略....
sent 8436 bytes received 43224862 bytes 2789245.03 bytes/sec
total size is 43189031 speedup is 1.00
[root@linux ~]# ll -d /tmp/dmtsai
drwxr-xr-x 22 dmtsai dmtsai 4096 Sep 18 23:25 /tmp/dmtsai
# 瞧！这样就做好备份啦！很简单吧！
你可以利用上面的范例二来做为备份 script 的参考！不过要注意的是， 因为 rsync 是透过 ssh 来传输
资料的，所以你可以针对 dmtsai 这个家伙制作出免用密码登入的 ssh 金钥！ 如此一来往后异地备援系
统就能够自动的以 crontab 来进行备份了！简单到爆！
免密码的 ssh 账号我们在上头已经讲过了，撰写 shell script 的能力也是必须要有的！ 利用 rsync 来
进行你的备份工作吧！ ^_^！ 至于更多的 rsync 用法可以参考本章后面所列出的参考数据网站喔！

重点回顾：
• 远程联机服务器可以让使用者在任何一部计算机登入主机，以使用主机的资源或管理与维护主机；
• 常见的远程登入服务有 rsh, telnet, ssh, vnc, 及 xdmcp 等；
• telnet 与 rsh 都是以明码传输数据，当数据在 Internet 上面传输时较不安全；
• telnet 与 rsh 预设无法让 root 的身份登入，不过可以藉由 pam 模块的修改而启用 root 登入
功能；
• ssh 由于使用金钥系统，因此数据在 Internet 上面传输时是加密过的，所以较为安全；
• 但 ssh 还是属于比较危险的服务，请不要对整个 Internet 开放 ssh 的可登入权限，可利用
iptables 规范可登入范围；
• ssh 的 public Key 是放在主机端，而 private key 是放在 client 端；
• ssh 的联机机制有两种版本，建议使用可确认联机正确性的 version 2 ；
• 使用 ssh 时，尽量使用类似 email 的方式来登入，亦即： ssh username@hostname
• client 端可以比对 server 传来的 public key 的一致性，利用的档案为
~user/.ssh/known_hosts；
• ssh 的 client 端软件提供 ssh, scp, sftp 等程序；
• 在 /etc/ssh/sshd_config 当中可以取消 root 的登入权限与修改支持的 ssh 金钥版本；
• 制作不需要密码的 ssh 账号可利用 ssh-keygen -t rsa 来制作 public, private Key pair；
• 上述指令所制作出的 public key 必须要上传到 server 的 ~user/.ssh/authorized_keys 档案
中；
• 如果想以 X 图形系统登入 Linux 主机，则你必须要在 Client 主机启动 X server ， 需要在
Linux 主机启动 X client ；
• Xdmcp 是透过 X display manager (xdm, gdm, kdm 等) 所提供的功能协议；
• 若 client 端为 Linux 时，需要在 X 环境下以 xhost 增加可连接到本机 X Server 的 IP 才
行；
• 除了 Xdmcp 之外，我们可以利用 VNC 来进行 X 的远程登入架构；
• VNC 预设开的 port number 为 5900 开始，每个 port 仅允许一个联机；
• 控制 rsh client 是否可以联机进入的设定档在 /etc/hosts.equiv 或 ~username/.rhosts ；
• rsh 支持的 client 端软件有 rsh, rlogin, rcp 等；
• rsync 可透过 ssh 的服务通道或 rsync --daemon 的方式来联机传输，其主要功能可以透过类似
镜像备份， 仅备份新的数据，因此传输备份速度相当快速！

课后练习
• Telnet 与 SSH 都是远程联机服务器，为何我们都会推荐使用 SSH 而避免使用 Telnet 呢？原因
何在？
因为 Telnet 除了使用『明码』传送数据外，本身 telnet 就是很容易被入侵的一个服务器，所
以当然也就比较危险了。 至于 ssh 其实也不是很安全的！由台湾计算机危机处理小组的文件可
以明显的发现 openssl + openssh 也是常常有漏洞在发布！不过，比起 telnet 来说，确实是稍
微安全一些！
• 请尝试说明 SSH 在 Server 与 Client 端联机时的封包加密机制；
利用 key pair 来达到加密的机制：Server 提供 Public Key 给 Client 端演算 Private key ，
以提供封包传送时的加密、解密！
• 请问 SSH 的设定档是哪一个？如果我要修改让 root 无法使用 SSH 联机进入我的 SSH 主机，应
该如何设定？又，如果要让 badbird 这个使用者无法登入 SSH 主机，该如何设定？
SSH 设定档档名为 sshd_config ，通常放置在 /etc/ssh/sshd_config 内；如果不想让 root 登
入，可以修改 sshd_config 内的参数成为：『PermitRootLogin no 』，并重新启动 ssh 来设定！
如果要让 badbird 使用者无法登入，同样在 sshd_config 里面设定为：『DenyUsers badbird』
即可！
• 在 Linux 上，预设的 Telnet 与 SSH 服务器使用的埠口(port number)各为多少？
telnet 与 ssh 的埠口分别是：23 与 22！请参考 /etc/services 喔！
• 如果发现我无法在 Client 端使用 ssh 程序登入我的 Linux 主机，但是 Linux 主机却一切正
常，可能的原因为何？(防火墙、known_hosts...)
无法登入的原因可能有很多，最好先查询一下 /var/log/messages 里面的错误讯息来判断，当然，
还有其它可能的原因为：
1. 被防火墙挡住了，请以 iptables -L -n 来察看，当然也要察看 /etc/hosts.deny；
2. 可能由于主机重新开机过， public key 改变了，请修改您的 ~/ssh/known_hosts 里面
的主机 IP ；
3. 可能由于 /etc/ssh/sshd_config 里面的设定问题，导致您这个使用者无法使用；
4. 在 /etc/passwd 里面，您的 user 不具有可以登入的 shell ；
5. 其它因素(如账号密码过期等等)
• 既然 ssh 是比较安全的资料封包传送方式，那么我就可以在 Internet 上面开放我的 Linux 主
机的 SSH 服务了吗？！请说明您选择的答案的原因！
最好不要对 Internet 开放您的 SSH 服务，因为 SSH 的加密函式库使用的是 openssl ，一般
Linux distribution 使用的 SSH 则是 openssh ，这两个套件事实上仍有不少的漏洞被发布过，
因此，最好不要对 Internet 开放，毕竟 SSH 对于主机的使用权限是很高的！
• 如果我想要将 server 的重要资料备份到 backserver，如果可以使用 rsync 透过 ssh 的通道，
你可以请尝试这样做：
1. 先在 server 上面以 root 建置 ssh 的 public 与 private key pair ；
2. 将 public key 传送与设定到 backserver 上的某个使用者环境下；
3. 在 backserver 上面制作好预计要存放备份数据的目录！重点在于『权限』的设定上！
4. 在 server 上面设定好 rsync 的备份 script ～
5. 利用 crontab 每隔一段时间自动异地备份。
请依照上述的作法在您的两部主机上面进行测试与实作。(未提供解答)
____________________________________________________________

无论如何，我们都可以透过 nslookup, host, dig 等等的指令来查询主机名称与 IP 的对应， 这些指令
的用法可以请您以 man command 来查询更多的用法喔！
____________________________________________________________

虚拟主机架设：
• 什么是虚拟主机 ( Virtual Host )？
咦！虚拟主机是什么东西吶！怎么说的好像很神奇的样子呢？他有什么功能？为什么大家都想要
玩一下虚拟主机吶？呵呵！所谓的虚拟主机，基本上，就是『让你的一部主机上面，有好多个"
主网页"存在，也就是说，硬件实际上只有一部主机，但是由网站网址上来看，则似乎有多部主机
存在的样子！』，举个例子来说好了，你可以由我的网页上面知道一件事情，那就是我的 WWW 主
机其实只有一部，那就是 pc510.ev.ncku.edu.tw 。不过，我这部主机其实有很多个 Domain name
存在，例如 linux.vbird.idv.tw 与 phorum.vbird.idv.tw 这两个网址。不过，上面这两个网址
其实也同时指到 pc510.ev.ncku.edu.tw 这部机器上面，亦即是 pc510.ev.ncku.edu.tw,
linux.vbird.idv.tw, phorum.vbird.idv.tw 这三个不同的主机名称，其实都是指向同一部计算
机主机！你可以在你的 Linux 机器上面以 nslookup 的指令搜寻一下这三个主机名称，你就晓得
为什么了！但是，当你在浏览器上面输入：
o http://pc510.ev.ncku.edu.tw
o http://linux.vbird.org
o http://phorum.vbird.org
怪了！怎么会显示不同的网页内容呢？好像是存在三部主机对吧！呵呵！这就是所谓的虚拟主机
啦！让你的一部机器上面，搞的好像好多部同的主机一样的一个简易的功能啦！ ^_^
• 架设的大前提：
那么要架设虚拟主机需要什么咚咚呢？呵呵！以刚刚我的网站的结果为例，我要架设三个主网页，
也就是必须要有多个 domain name 啰！对啦！这就是虚拟主机的大前提啦！『你必须要有多个主
机名称，亦即是需要多个 domain name, FQDN 』，例如上面我就具有三个 domain name 啰！在
需要多个 domain name 的情况下，你可以做的方式就是：
o 申请多个 host name 在 ISP 的管理上面；
o 自行设定经过合法授权的 DNS 主机来自行设定自己的 domain name ！
没错，就是这几个方法，因此，请确定你的主机名称已经搞定了！不然的话，怎么架设虚拟主机
呢？您说是吧！ ^_^
• 实际架设：
好了！又要来搞设定啦！又是 httpd.conf 这个档案啦！反正几乎只要跟 Apache 有关的，就是
动这个档案就对啦！这里先来说一下我的大前提设定啰！
o 已经设定好了三个 domain name ，分别是 mdk90.vbird.org, www.mdk90.vbird.org,
phorum.mdk90.vbird.org ，此外，这三个网域的主网页个别放置在 /home/mdk90,
/home/www.mdk90, /home/phorum.mdk90 ，亦即是：
 mdk90.vbird.org --> /home/mdk90
 www.mdk90.vbird.org --> /home/www.mdk90
 phorum.mdk90.vbird.org --> /home/phorum.mdk90
至于这个设定嘛！真的是很简单耶！只要几行就搞定了，设定完成之后还会让你偷笑ㄋㄟ～呵呵！看看实
例吧！
[root@test root]# cd /usr/local/apache2/conf
[root@test root]# vi httpd.conf
# 在这个档案的最下方加入底下这些字眼！
NameVirtualHost *  # 设定你的虚拟主机判定的依据！这里是＊ 亦即是
 # 所有连上这部机器的名称都会被使用来当作虚拟主机的设定之用！
<VirtualHost *>
 ServerName mdk90.vbird.net
 DocumentRoot /home/mdk90
</VirtualHost>
<VirtualHost *>
 ServerName www.mdk90.vbird.net
 DocumentRoot /home/www.mdk90
 CustomLog /var/log/httpd/www.access_log combined # 特别将登录档额外分离出来
</VirtualHost>
<VirtualHost *>
 ServerName phorum.mdk90.vbird.net
 DocumentRoot /home/phorum.mdk90
</VirtualHost>
要注意的是：
1. 在虚拟主机的设定上还有很多的可用的功能，不过，最低的限度是需要有 ServerName 及
DocumentRoot 这两个即可！
2. 虽然原来我就有 mdk90.vbird.net 这个网域，但是因为设定了虚拟主机之后，自己的原
来名称可能会不见去，所以，这里必须将自己的名称也写入才行！
3. 上面有发现一个 CustomLog 的设定喔！该设定会让以 www.mkd90.vbird.net 这个网域
登入的登录档不再写入原来的 /var/log/httpd/access_log 档案，而是自行写入
/var/log/httpd/www.access_log 这个档案！
马上测试看看！呵呵！会发现，咦！我真的有三个主网页了哩！很不错吧！这个作法可以让你的 WWW 网页
更有灵活度喔！举个例子来说，前一阵子因为酷学园讨论区(http://phorum.study-area.org) 常常挂点，
所以鸟哥就自告奋勇的跟站长说，只要将 phorum.study-area.org 这个 domain name 指向我的主机 IP ，
那么也可以直接进入我的讨论区，如此一来，只要修改一下 DNS 即可转换到我的讨论区啦！并且不需要再
进行任何额外的设定！对于网页维护的灵活度是真的很有帮助的喔！
• 需要注意的事项：

虚拟主机并没有什么值得特别注意的地方，只要设定正确，大致上就不会有太大的问题！不过，你可能需
要特别注意刚刚我们建立起来的新的登录档喔！为什么呢？我们上面不是提过说，登录档在大型的网站上
面成长的幅度是很可观的吗？所以需要进行 logrotate ，但是你刚刚建立的档案并不在原本的 logrotate
档案之内呀！呵呵！这个时候请自行加入 logrotate 个手续喔！否则.....嘿嘿嘿嘿！硬盘空间被用光可
不要怪鸟哥喔！ ^_^
____________________________________________________________

设定认证网页
是不是有过进入某个网站之后，按下某些连结，竟然出现一个对话框框，告诉你要登入该目录，
需要输入账号与密码才能登入？呵呵！那就是所谓的『认证网页』啰！这种认证的模式最起码可
以达到最小的保护作用，使你的数据比较保险啦！咦！那么使用 Limit 不就好了？但是 Limit 的
规定较为严格，若是改天你去外头的网咖店，然后想要联机进入你的主机作一些事情，如果你设
定除了内部 IP 之外，外部就无法以 Web 接口连进来的话，那么不就糗了吗？呵呵！这个时候认
证网页可就是你的好帮手啰！另外，目前很多学校老师也会将自己的讲义放在网站上，然后以认
证网页的方式提供自己的学生下载使用！所以说，这个也是蛮不错的一个变通方式哩！
那么认证网页怎么搞呀！？说来还真的是很容易ㄋㄟ！
9. 既然我们是『按了某个连结进入某个目录之后，才会出现对话窗口』，那么首先当然就是
要有那个设定为认证网页的『目录』啰！请注意，是要目录才行喔！
10. 然后，在对会窗口中，既然我们需要输入 ID 与密码，那么自然就需要密码文件啰！另
外，虽然 Apache 有支持 LDAP 及 MySQL 等等的认证机制，不过我们这里并不讨论其它
的认证机制，完全使用 Apache 的预设功能而已，所以，底下我们会使用基本 ( Basic )
的认证模式喔！
11. 再来，当然就是到 httpd.conf 档案中去设定我们刚刚建立的那个目录的相关信息啰！
12. 最后，重新启动就 OK 啦！
好了，那么我们来作个例子吧！假设，我要在 http://localhost/protect/ 这个目录下作一个认
证数据，在这个目录当中仅有 test.html 这个档案，此外，我要让 test 这个 ID ，密码为
testing 及 qqq 这个账号，密码为 qqqpass 做为登入的账号，那么我该如何设定我的数据呢？
一样的，一步一步来进行吧！
13. 制作保护目录：
第一步骤当然是制作保护目录啰！既然这个目录在 http://localhost/protect/ 底下，那么有哪
些方式可以达成呢？
 最简单的方是就是直接在 /usr/local/apache2/htdocs 这个目录下再建立一
个名为 protect 的子目录啰！不过，这样似乎太简单了 ^_^
 再来，如果您的网页支持 FollowSymLinks 这个参数(options)的话，那么在任
何一个目录下，只要你在 /usr/local/apache2/htdocs 利用 link ( ln ) 制
作一个连结档，那么也可以达成所要的目的！
 最后，哈哈！直接使用 Alias 就可以啦！
我们选择使用最简单的目录方式来达成好了：
[root@test root]# mkdir -p /usr/local/apache2/htdocs/protect
[root@test root]# cd /usr/local/apache2/htdocs/protect
[root@test root]# echo "This is a protect page" > test.html
上面我加一个 -p 的参数可以帮我递归的一直建立好这个目录喔！然后立刻就又做好一
个档案ㄋㄟ～
14. 制作密码文件：
制作密码文件只要使用 htpasswd 这个命令就可以啦！他的语法是这样的：
htpasswd
语法：
[root@test root]# htpasswd [-c] password_file_name User_name
说明：
-c ：当后面的 password_file_name 这个密码文件不存在时，那么就建立该档案
范例一：
新建一个档案，并建立 test 这个 ID
[root@test root]# cd /usr/local/apache2
[root test apache2]# htpasswd -c apache.passwd test
New password: 
Re-type new password: 
Adding password for user test
范例二：
已经存在密码文件了，要新增使用者账号
[root@test apache2]# htpasswd apache.passwd qqq
New password: 
Re-type new password: 
Adding password for user qqq
[root@test apache2]# more apache.passwd
test:gPxbCD4QIGFwg
qqq:5qPxrLrxRyRrg
15. 没错！这样就 OK 啦！你已经有两个账号( test 与 qqq )在
/usr/local/apache2/apache.passwd 这个档案中啰！不过，这里请注意，由于你的密码
文件可以存放在任何地方，但是毕竟这里面有你的重要信息，所以，请特别留意的是，
『不要将这个档案放置在浏览器可以浏览到的目录！』举个例子来说，放在
/usr/local/apache2/htdocs 就不是一个明智的选择！因为很可能会被别人浏览到这个
档案而失去『认证密码』了，那么岂不是很危险！？所以，尽量给他放在浏览器无法浏
览到的地方，例如我们提到的 /usr/local/apache2 这个目录就是一个还不错的目录！
16. 针对保护的目录设定认证的内容：
当然接下来我们要针对那个受保护的目录进行设定啦！就是要又开始搞设定档啰！怎么
搞？！就是要加入信息吶！加入哪些信息呢？这当中当然就包含了『密码文件的完整目
录与文件名、认证的类型、提示的字符、与允许登入的使用者』如果你看到认证网页的
登入窗口时，通常就会看到两个输入 ID 与密码的格子，所以自然要设定密码文件的档
案，而你也会看到该窗口上面有一些提示字符告诉你这个网页是干嘛用的！另外，像我
们刚刚制作了两个账号，那万一你只允许一个账号登入，另一个账号不许登入，那要如
何搞呢？可以这样搞喔：
[root@test root]# vi /usr/local/apache2/conf/httpd.conf
在这个档案的设定中，请特别留意设定的地方，不要设定错误地方，
一般而言，新的咚咚可以加在最后面一行开始，比较不会搞错地方！
加入底下这几行：
<Directory "/usr/local/apache2/htdocs/protect">
 AuthName "Protected Directory" #这个是显示在窗口上面的提示字符
 AuthType Basic #这个则是认证的类型！就选 Basic 即可， Apache 的
 AuthUserFile /usr/local/apache2/apache.passwd  #密码文件放置的地方啦！完整的目录与文件名
 require valid-user #允许的使用者， valid-user 为任何一个在认证档案
 #require user test #若将 # 移除，则表示只有 test 才是可以登入的账
</Directory>
17. 真的很简单啦！就只要上面的四行设定内容就够了！ AuthName 就是在出现要你输入 ID
与密码的那个提示字符啦！至于谁可以登入呢？以上面的说明为例，当设定为
valid-user 时，表示任何在认证档案中出现的使用者都接受登入，至于如果是 require
user test 那一行，则表示可以登入者仅有 test ，如果有两个以上呢？可以写成
『 require user test qqq 』的样式喔！
18. 重新启动与测试：
这个不用再讲了吧？！：
[root@test root]# /usr/local/apache2/bin/apachectl stop
[root@test root]# /usr/local/apache2/bin/apachectl start
19. 测试怎么测试？直接连上网页吶！在网址列输入：
『http://your.host.name.or.IP/protect/test.html』然后应该就会出现：
看到那个 Protected Directory 的字眼了吧！那就是 AuthName 啰！然后使用者名称与
密码即是我们刚刚建立的密码文件之内容啦！认证网页设定成功！恭喜喔！
.htaccess 档案与 AllowOverride 设定的用途：
从头到现在有的学的吧？ ^_^ 粉累喔！呵呵！尤其最累的是，如果万一你真的设定好了一个
Apache ，而且也真的很高兴的对外开放了！那么你是否会注意到一件事情，那就是，万一你有 20
的使用者，每个使用者都要求由他设定自己风格的家目录，亦即他们想要自己设定自己的认证网
页，想要自行管理自己的 Apache 底下的其它功能，怎么办？由于有关 Apache 的设定就一定需
要：
20. 修改 httpd.conf 这个档案；
21. 然后再重新开机，好让设定的结果可以正确的显现出来！
如此一来的话，难道：
o 我就要把 root 的密码给他们吗？好让他们可以自行修改 httpd.conf ？如此一来的
话，不就粉危险，而且，难保 A 君的设定被 B 君不小心给修改了～哇！真是伤脑筋～
o 我就要一个一个的帮他们修改吗？谁来就要帮谁改，难道改天我有 200 的使用者时，若
一天分配给一个人，我就要改 200 天的 Apache ，岂不讨厌～
这不是很累吗？呵呵！这个时候， .htaccess 的档案就『英雄有用武之地』咯！这个档案的最大
功能就是『可以取代 httpd.conf 里面，对于这个 .htacces 所在目录的设定内容！』也就是说，
如此一来，每个目录下的 .htaccess 可以让该目录拥有相关的权限、风格等等的设定！如此一来，
root 也就不会这么累了，并且，修改完这个档案之后，也不需要重新开机ㄋㄟ！棒吧！ ^_^，不
过，到底 .htaccess 这个档案可以工作的内容有哪些呢？呵呵！这个时候，可就需要
AllowOverride 在 httpd.conf 里面的设定来规定啰！所谓的 AllowOverride 说的是『允许取代
某些设定内容』的意思，而这个 AllowOverride 可以取代的数据有：
o Options：就是允许自行设定一些网页参数，例如 Index, ExecCGI....等等
o AuthConfig：就是网页认证的设定内容啦！
o Limit：就是上面我们提到过的关于安全的设定咯！
o All：上面的规定都可以允许 .htaccess 里面来设定
o None：上面的规定都不许由 .htaccess 来规定！
如果你想让 .htaccess 这个档案有最大的取代内容时，可以选择 AllowOverride All，若仅想让
这个档案具有取代网页认证的功能，那么就可以使用 AllowOverride AuthConfig 即可！
举个例子来说，刚刚我们设定 /usr/local/apache2/htdocs/protect 为保护目录，需要做的事情
最重要的为设定 httpd.conf 这个档案，并且需要设定有的没的一大堆，好了，现在假如我想让
所有的 user 都能自行在自己的家目录内进行？怎么利用 .htaccess 这个风格档案呢？这其中
当然涉及了(1)root 对于 httpd.conf 的设定以及(2)一般身份使用者对于自己家目录下的设定！
好了，现在我们分别以两种身份来设定自己家目录下的咚咚，以 test 这个使用者为例好了，来
看看怎么使用认证网页在一般使用者家目录下！
 关于 root 的设定项目：
0. 先确认底下这些信息可以在您的 httpd.conf 里面发现：
[root@test root]# cd /usr/local/apache2/conf
[root@test conf]# vi httpd.conf
AccessFileName .htaccess <==表示你的设定档案的档名！
<Files ~ "^\.ht">
 Order allow,deny
 Deny from all
</Files>
# 上面这个信息主要就是定义出你在某个目录底下有个控制档案，那个档案的档名啦！
1. 建立让每个使用者家目录下都能自行设定 AuthConfig 的规则！
[root@test root]# vi /usr/local/apache2/conf/httpd.conf
# 在一个新的角落( 可以在最后一行加入)加入底下的字眼
<Directory "/home/*/public_html/">
 AllowOverride AuthConfig
 Order allow,deny
 Allow from all
</Directory>
# 上面的说明是：在每个使用者家目录下，都可以使用 AuthConfig 的设定
# 在 .htaccess 这个档案中！设定完毕之后重新启动 Apache
3. 重新启动 Apache 啰！
[root@test root]# /usr/local/apache2/bin/apachectl stop
[root@test root]# /usr/local/apache2/bin/apachectl start
 关于一般身份使用者 (test 为例) 的设定项目：
0. 以一般身份使用者登入，或者使用 su 转换 test 的身份
[root@test root]# su test
1. 建立保护目录与网页内容
[test@test test]$ mkdir public_html
# 上面说明的是我要建立 test 底下的一个名为 public_html 的目录！
# 还记得上面提到的个人首页的设定吧！对啦！这个 public_html 请依你的规定设定！
# 此外，这个 test 必需已经存在你的 /etc/passwd 当中了！
[test@test test]$ cd public_html
[test@test public_html]$ mkdir protect2; cd protect2
[test@test protect2]$ echo "protect2 web page" > testing.html
# 上面可以建立目录与网页内容喔！
2. 建立 test 自己的密码文件
[test@test test]$ htpasswd -c /home/test/apache.passwd test
New password: 
Re-type new password: 
Adding password for user test
# 在 /home/test 底下建立密码记录文件，文件名  apache.passwd ，
# 并且建立起一个名为 test 的使用者！
3. 建立 .htaccess 档案的内容！
[test @test protect2]$ vi .htaccess
# 加入底下的字眼：
# This file is used to test the .htacces function
AuthName "Protect test by .htaccess"
Authtype Basic
AuthUserFile /home/test/apache.passwd
require user test
# 不论你信不信，这个时候当你要进入 http://your.host.name/~test/protect2/testing.html
# 就需要有认证密码才行了！很快乐吧！
赶快去测试看看吧！这样对于 Root 来说，是比较轻松一点，对于使用者来说，可以使用的规范
也比较多样化！但是，衍生出来的安全问题，可能就需要大家共同的维护了！当然啦，你也可以
使用 AllowOverride 来设定更多 .htaccess 可以规范的项目呢！

防火墙
一句老话啦！就是『如果你的 Server 不能动，但是确定设定都没有问题，那么除了持续查询 log
file 之外，最大的可能就是防火墙挡住了！』这句话应该没有什么太大的疑问才对～所以呢，万
一你的 Apache 不能动，那么请看看你的防火墙设定规则吧！因为防火墙我们已经提过了，请参
考『 简易防火墙设定』一文，这里不再赘述！
____________________________________________________________

增强 PHP 程序代码执行速度的模块：
MM Cache 增强速度模块：
我们上面的介绍都是在于安装与架设 LAMP 服务器(Linux + Apache + MySQL + PHP )，不过，如
果您曾经浏览过 PHP 的网页时，或许会发现：『咦！怎么 PHP 的速度慢慢的.....』，这是怎么
一回事啊！？PHP 不是号称速度上面的反应是很快速的吗？怎么会慢慢的呢？虽然 PHP 的程序已
经很快了，但是因为计算机仅认识 0 与 1 的 binary file 来执行，而由于 PHP 程序不需要编
译即可透过 PHP 核心与其相关函式库来执行，不过，如此一来还是多了一道手续，导致执行效能
还是不比传统的经过编译的程序语言来的快(例如C程序语言之类的！)。那怎么办？有办法加快
PHP 程序的速度吗？嗯！让我们先换个角度想，如果我们可以将 PHP 程序预先转换成为可直接执
行的 binary file ，那么不就可以直接读取，进而加快速度吗？没错！是这样～这东西称为预编
器～其中， MM Cache 就是一个很不错的 PHP 预编器。 MM Cache 可以将您的 PHP 程序与 PHP 核
心及相关函式库预先编译后暂存下来，以提供未来使用时，可以直接执行，加上他可以优化您的
PHP 程序，因此，可以让您的 PHP 网页速度增快不少喔！ MM Cache 啰！他的官方网站在：
http://turck-mmcache.sourceforge.net/index_old.html。目前 MM Cache 已经出到了 2.3.9
( 2003/04/10 释出)，不过，他仅在 PHP 4.1 以上版本以及 Apache 1.3 与 2.xx 版本测试过，
如果你的 Apache 与 PHP 不是这些版本，那就抱歉啦！不一定可以使用的！不过，呵呵！我们上
面提供的 Tarball 的安装方法本来就是这样的版本，所以您可以轻易的安装好 MM Cache 喔！废
话不多说，赶紧来安装吧！
o 下载：
你可以在官方网站下载最新的版本
(http://turck-mmcache.sourceforge.net/index_old.html)，也可以在我们网站下载鸟
哥试过的版本：
http://linux.vbird.org/download/index.php#www_mmcache

o 安装：
安装 MM Cache 真的是很简单喔！赶紧来安装吧！
[root@test root]# cd /usr/local/src
[root@test src]# tar -zxvf /完整路径/turck-mmcache-2.3.9.tar.gz
# 会产生一个名为 turck-mmcache-2.3.9 的目录
[root@test src]# cd turck-mmcache-2.3.9
[root@test turck-mmcache-2.3.9]# phpize
# 这个指令是 PHP 套件所提供的！可以建置好你的 mmcache 原始码
[root@test turck-mmcache-2.3.9]# ./configure --enable-mmcache=shared
[root@test turck-mmcache-2.3.9]# make && make install
# 这个动作会编译一个名为 mmcache.so 的动态函式库模块，
# 并且会主动的将他安装在 /usr/lib/php4 这个目录当中！
# 这样就安装完毕了！很简单吧！
o 
o 设定：
在 MM Cache 的设定方面需要更动两个地方，第一个是动态函式库加载的设定，第二个
则是 PHP 的设定！
1. 设定主动加载动态函式库模块：
[root@test root]# vi /etc/ld.so.conf
# 在这个档案内加入底下这一行：
/usr/lib/php4
[root@test root]# ldconfig
# 上面这两个步骤比较有趣一点，在 ldconfig 这个指令的功能是：
# 『加载动态函式库到内存当中做为快取』之用，至于加载的动态函式库则是
# 根据 /etc/ld.so.conf 这个档案的设定为准！这的动作只要第一次设定时进行
# 即可，未来在开机完成之后，系统会主动的加载动态函式库的！
# 另外请注意，  ld.so.conf 里面只要写『目录』即可！
2. 修改 php.ini 
# 请注意，由于每个人的 php.ini 都不相同，例如使用 RPM 安装者，应该是
# /etc/php.ini ，但是我上面的安装设定却是 /usr/local/php4/php.ini 
# 请依照您的主机来设定喔！
[root@test root]# vi /完整路径/php.ini 
# 在这个档案的最后一行加入底下这几行：
;;;;;;;;;;;; 
; MM Cache ; 
;;;;;;;;;;;; 
extension="mmcache.so"
mmcache.shm_size="16"
mmcache.cache_dir="/tmp/mmcache"
mmcache.enable="1"
mmcache.optimizer="1"
mmcache.check_mtime="1"
mmcache.debug="0"
mmcache.filter=""
; end of mmcache
3. 建立快取目录：
[root@test root]# mkdir /tmp/mmcache
[root@test root]# chmod 0777 /tmp/mmcache
4. 重新启动 Apache
[root@test root]# /etc/rc.d/init.d/httpd restart
# 或
[root@test root]# /usr/local/apache2/bin/apachectl restart
o 这样一个简单的小步骤，嘿嘿！您的 PHP 程序代码的反应性～啊～增快很多很多喔！ ^_^
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________
____________________________________________________________




